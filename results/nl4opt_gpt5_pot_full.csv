example_idx,gt,raw_response,parsed_answer,correct,abs_error,rel_error,latency_sec,error
0,1160.0,"```python
def solve():
    # We define:
    # x = number of boat trips
    # y = number of canoe trips
    #
    # Constraints:
    # 1) Duck requirement: 10x + 8y >= 300
    # 2) Boat trip limit: x <= 12
    # 3) At least 60% of trips by canoe: y >= 1.5x
    # 4) x, y >= 0
    #
    # Objective: minimize total time T = 20x + 40y
    #
    # Since the problem is small and integer in nature (trips), we brute-force
    # over integer x, y satisfying the constraints and find the minimum T.

    best_time = None

    # x cannot exceed 12 by constraint, and cannot be negative.
    for x in range(0, 13):
        # y must be at least 1.5x and nonnegative.
        # Also, from duck constraint: 10x + 8y >= 300 -> y >= (300 - 10x)/8
        y_min_canoe_ratio = 1.5 * x
        y_min_ducks = max(0.0, (300 - 10 * x) / 8.0)
        y_start = int(-(-max(y_min_canoe_ratio, y_min_ducks) // 1))  # ceil

        # Reasonable upper bound for y: enough to carry all ducks with no boats
        # 8y >= 300 -> y >= 37.5, so up to, say, 100 is safe.
        for y in range(y_start, 101):
            # Check duck constraint explicitly (for safety with integer rounding)
            if 10 * x + 8 * y < 300:
                continue
            # Check canoe ratio constraint
            if y < 1.5 * x:
                continue
            # Check boat trip limit
            if x > 12:
                continue

            time = 20 * x + 40 * y
            if best_time is None or time < best_time:
                best_time = time

    # Return the optimal objective value as float
    return float(best_time)
```",1160.0,True,0.0,0.0,4.039384365081787,
1,350.0,"```python
def solve():
    # We minimize filler: F = 2L + S
    # Subject to:
    # 1) Medicinal ingredient constraint: 3L + 2S <= 1000
    # 2) At least 100 large pills: L >= 100
    # 3) At least 60% small: S >= 1.5 * L
    #
    # This is a 2-variable linear program. The feasible region is a polygon;
    # the optimum lies at a vertex (intersection of constraints).
    #
    # We'll find all candidate vertices formed by intersecting pairs of
    # constraints (including bounds) and then check feasibility and objective.

    candidates = []

    # Helper to check feasibility and add candidate
    def add_candidate(L, S):
        # Feasibility checks with a small tolerance for float arithmetic
        eps = 1e-9
        if L + eps < 100:  # L >= 100
            return
        if S + eps < 1.5 * L:  # S >= 1.5L
            return
        if 3 * L + 2 * S - 1000 > eps:  # 3L + 2S <= 1000
            return
        if L < -eps or S < -eps:  # nonnegativity (implicit)
            return
        candidates.append((L, S))

    # 1) Intersection of S = 1.5L and 3L + 2S = 1000
    #    3L + 2(1.5L) = 3L + 3L = 6L = 1000 => L = 1000/6, S = 1.5 * L
    L1 = 1000.0 / 6.0
    S1 = 1.5 * L1
    add_candidate(L1, S1)

    # 2) Intersection of L = 100 and S = 1.5L
    L2 = 100.0
    S2 = 1.5 * L2
    add_candidate(L2, S2)

    # 3) Intersection of L = 100 and 3L + 2S = 1000
    #    3*100 + 2S = 1000 => 300 + 2S = 1000 => S = 350
    L3 = 100.0
    S3 = 350.0
    add_candidate(L3, S3)

    # 4) Potentially, intersection of S = 0 and others, but S >= 1.5L
    #    would force L <= 0, which conflicts with L >= 100, so no need.

    # Compute objective for all feasible candidates and return minimum
    best_val = float('inf')
    for L, S in candidates:
        filler = 2.0 * L + S
        if filler < best_val:
            best_val = filler

    return best_val
```",350.0,True,0.0,0.0,3.646419048309326,
2,100.0,"```python
def solve():
    # We need to minimize the total number of workers:
    # Let x = number of full-time workers (8 hours, $300)
    #     y = number of part-time workers (4 hours, $100)
    #
    # Constraints:
    # 1) Hours: 8x + 4y >= 500
    # 2) Budget: 300x + 100y <= 15000
    # 3) x, y >= 0 and integers
    #
    # Objective: minimize x + y
    
    best_value = None  # minimal number of workers
    # Upper bound for x from budget: 300x <= 15000 -> x <= 50
    # Also from hours alone: 8x <= 500 -> x <= 62.5, so 50 is tighter.
    for x in range(0, 51):
        # From budget: 300x + 100y <= 15000 -> y <= (15000 - 300x)/100
        max_y = (15000 - 300 * x) // 100
        if max_y < 0:
            continue
        
        # From hours: 8x + 4y >= 500 -> y >= (500 - 8x)/4
        # Need integer y, so take ceiling
        min_y_num = 500 - 8 * x
        if min_y_num <= 0:
            min_y = 0
        else:
            # ceiling division for positive numerator
            min_y = (min_y_num + 4 - 1) // 4
        
        if min_y > max_y:
            continue
        
        # Feasible y range is [min_y, max_y]; objective increases with y,
        # so choose smallest feasible y.
        y = min_y
        
        total_workers = x + y
        if best_value is None or total_workers < best_value:
            best_value = total_workers
    
    # Return the optimal objective value (minimal number of workers) as float
    return float(best_value)
```",100.0,True,0.0,0.0,2.5406434535980225,
3,7.0,"```python
def solve():
    # We want to minimize x + y
    # Subject to:
    # 80x + 150y >= 1000   (production)
    # 50x + 70y <= 500     (heat)
    # x, y >= 0 and integers (number of machines)
    #
    # We'll brute force over a reasonable range of integer x, y.
    # Upper bounds: from heat constraint:
    #   50x + 70y <= 500 -> x <= 10, y <= 500/70 < 8
    # So x in [0,10], y in [0,7] is enough.

    best_value = None

    for x in range(0, 11):
        for y in range(0, 8):
            # Check constraints
            if 80 * x + 150 * y >= 1000 and 50 * x + 70 * y <= 500:
                value = x + y
                if best_value is None or value < best_value:
                    best_value = value

    # Return the minimal number of machines as a float
    return float(best_value if best_value is not None else 0.0)
```",7.0,True,0.0,0.0,2.463557720184326,
4,327.6595744680851,"```python
def solve():
    # We solve the LP:
    # Minimize: 100x + 80y
    # Subject to:
    # 10x + 7y >= 30   (protein)
    #  8x +15y >= 50   (fat)
    # x, y >= 0
    
    # The optimal solution for a 2-variable LP with linear constraints
    # will occur at a corner (intersection of constraint lines or axes).
    # We check:
    # 1) Intersection of the two constraint lines
    # 2) Intersection with axes where feasible
    
    # 1) Solve the system:
    # 10x + 7y = 30
    #  8x +15y = 50
    
    # Solve via substitution / elimination:
    # Multiply first equation by 8, second by 10:
    # 80x + 56y = 240
    # 80x +150y = 500
    # Subtract first from second:
    # 94y = 260  =>  y = 260/94
    y = 260.0 / 94.0
    # Plug back into 10x + 7y = 30:
    # 10x = 30 - 7y
    x = (30.0 - 7.0 * y) / 10.0
    
    # Check feasibility (x, y >= 0 automatically holds from calculation here)
    # Compute cost at this intersection:
    cost_intersection = 100.0 * x + 80.0 * y
    
    # 2) Check axis intersections:
    # Case x = 0:
    # Protein: 7y >= 30 => y >= 30/7
    # Fat:    15y >= 50 => y >= 50/15
    y_x0 = max(30.0 / 7.0, 50.0 / 15.0)
    cost_x0 = 100.0 * 0.0 + 80.0 * y_x0
    
    # Case y = 0:
    # Protein: 10x >= 30 => x >= 30/10 = 3
    # Fat:     8x >= 50  => x >= 50/8
    x_y0 = max(30.0 / 10.0, 50.0 / 8.0)
    cost_y0 = 100.0 * x_y0 + 80.0 * 0.0
    
    # The optimal cost is the minimum of these feasible corner costs
    optimal_cost = min(cost_intersection, cost_x0, cost_y0)
    return optimal_cost
```",327.6595744680851,True,0.0,0.0,3.8908767700195312,
5,215000.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 2.5*x + 3*y
    # Subject to:
    #   20000 <= x <= 50000
    #   10000 <= y <= 30000
    #   x + y >= 60000
    
    # Since this is a 2-variable LP with simple bounds, we can enumerate
    # all corner points of the feasible region and pick the best.
    
    candidates = []
    
    # Bounds
    x_min, x_max = 20000.0, 50000.0
    y_min, y_max = 10000.0, 30000.0
    
    # Helper to check feasibility
    def feasible(x, y):
        return (x_min <= x <= x_max and
                y_min <= y <= y_max and
                x + y >= 60000.0)
    
    # List all potential corner points formed by intersecting constraints:
    # 1) (x_min, y_min), (x_min, y_max), (x_max, y_min), (x_max, y_max)
    pts = [
        (x_min, y_min),
        (x_min, y_max),
        (x_max, y_min),
        (x_max, y_max)
    ]
    
    # 2) Intersections with x + y = 60000:
    #    y = 60000 - x, with x at its bounds
    for x in [x_min, x_max]:
        y = 60000.0 - x
        pts.append((x, y))
    #    x = 60000 - y, with y at its bounds
    for y in [y_min, y_max]:
        x = 60000.0 - y
        pts.append((x, y))
    
    # Evaluate feasible points
    best_val = float(""-inf"")
    for x, y in pts:
        if feasible(x, y):
            val = 2.5 * x + 3.0 * y
            if val > best_val:
                best_val = val
    
    return best_val
```",215000.0,True,0.0,0.0,2.766770839691162,
6,513.0,"```python
def solve():
    # Let x = number of bikes, y = number of scooters
    # Maximize meals: 8x + 5y
    # Subject to:
    # 1) Charge: 3x + 2y <= 200
    # 2) Bike proportion: x <= 0.3(x + y)  ->  0.7x <= 0.3y  ->  7x <= 3y
    # 3) At least 20 scooters: y >= 20
    # 4) x, y >= 0
    
    best_value = float('-inf')
    
    # Since charge is limited, we can bound x and y.
    # Max x if only bikes: 3x <= 200 -> x <= 66
    # Max y if only scooters: 2y <= 200 -> y <= 100
    # We'll search integer solutions in these bounds.
    
    for x in range(0, 67):      # 0 to 66
        for y in range(20, 101):  # y >= 20, up to 100
            # Check constraints
            if 3 * x + 2 * y > 200:
                continue
            if 7 * x > 3 * y:
                continue
            
            value = 8 * x + 5 * y
            if value > best_value:
                best_value = value
    
    return float(best_value)
```",513.0,True,0.0,0.0,2.5603177547454834,
7,236.5,"```python
def solve():
    # We solve the LP:
    # Maximize 43x + 52y
    # subject to:
    # 1.4x + 1.1y <= 17   (stain)
    # 2x   + 3y   <= 11   (wood)
    # x, y >= 0
    
    # The maximum of a linear program with two variables occurs at a corner point
    # of the feasible region. The corner points are:
    # 1) Intersection with axes:
    #    - (0,0)
    #    - Stain-only: 1.4x = 17 -> (17/1.4, 0)
    #    - Wood-only: 2x = 11   -> (11/2, 0)
    #    - Stain-only: 1.1y = 17 -> (0, 17/1.1)
    #    - Wood-only: 3y = 11   -> (0, 11/3)
    # 2) Intersection of the two constraints:
    #    1.4x + 1.1y = 17
    #    2x   + 3y   = 11
    
    # We only keep points that satisfy both constraints and x,y >= 0.
    
    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 1.4 * x + 1.1 * y > 17 + 1e-9:
            return False
        if 2 * x + 3 * y > 11 + 1e-9:
            return False
        return True

    # Objective function
    def profit(x, y):
        return 43 * x + 52 * y

    candidates = []

    # (0,0)
    candidates.append((0.0, 0.0))

    # x-intercepts
    # From stain: 1.4x = 17
    x1 = 17.0 / 1.4
    if feasible(x1, 0.0):
        candidates.append((x1, 0.0))

    # From wood: 2x = 11
    x2 = 11.0 / 2.0
    if feasible(x2, 0.0):
        candidates.append((x2, 0.0))

    # y-intercepts
    # From stain: 1.1y = 17
    y1 = 17.0 / 1.1
    if feasible(0.0, y1):
        candidates.append((0.0, y1))

    # From wood: 3y = 11
    y2 = 11.0 / 3.0
    if feasible(0.0, y2):
        candidates.append((0.0, y2))

    # Intersection of:
    # 1.4x + 1.1y = 17
    # 2x   + 3y   = 11
    # Solve the system using substitution or elimination.
    # From second: x = (11 - 3y)/2
    # Substitute into first:
    # 1.4*(11 - 3y)/2 + 1.1y = 17
    # 0.7*(11 - 3y) + 1.1y = 17
    # 7.7 - 2.1y + 1.1y = 17
    # 7.7 - 1.0y = 17
    # -y = 9.3 -> y = -9.3 (infeasible since y >= 0)
    y_int = -9.3
    x_int = (11.0 - 3.0 * y_int) / 2.0
    # Check feasibility (it will fail due to negative y)
    if feasible(x_int, y_int):
        candidates.append((x_int, y_int))

    # Evaluate profits at all feasible candidates
    best = float('-inf')
    for x, y in candidates:
        val = profit(x, y)
        if val > best:
            best = val

    return float(best)
```",236.5,True,0.0,0.0,5.137372970581055,
8,400000.0,"```python
def solve():
    # We solve the LP:
    # Maximize 200x + 300y
    # subject to:
    #   2x + 4y <= 5000   (design hours)
    #   3x + 5y <= 6000   (engineering hours)
    #   x >= 0, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) (0,0)
    # 2) Intersection with x-axis (y=0):
    #    2x <= 5000 -> x <= 2500
    #    3x <= 6000 -> x <= 2000
    #    => (2000, 0)
    # 3) Intersection with y-axis (x=0):
    #    4y <= 5000 -> y <= 1250
    #    5y <= 6000 -> y <= 1200
    #    => (0, 1200)
    # 4) Intersection of 2x + 4y = 5000 and 3x + 5y = 6000:
    #    Solve:
    #      2x + 4y = 5000
    #      3x + 5y = 6000
    #    Multiply first eqn by 3: 6x + 12y = 15000
    #    Multiply second eqn by 2: 6x + 10y = 12000
    #    Subtract: 2y = 3000 -> y = 1500
    #    Then 2x + 4*1500 = 5000 -> 2x + 6000 = 5000 -> x = -500 (infeasible)
    # So that intersection is infeasible (x < 0), not in the feasible region.
    
    # Evaluate objective at feasible corners:
    candidates = [
        (0, 0),
        (2000, 0),
        (0, 1200)
    ]
    
    best_value = float('-inf')
    for x, y in candidates:
        value = 200 * x + 300 * y
        if value > best_value:
            best_value = value
    
    return float(best_value)
```",400000.0,True,0.0,0.0,2.8525776863098145,
9,950.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 20x + 30y
    # Subject to:
    #   10x + 20y <= 500   (water)
    #   15x + 20y <= 700   (powder)
    #   x >= 0, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) Intersections with axes:
    #    - x-axis (y = 0):
    #        10x <= 500  -> x <= 50
    #        15x <= 700  -> x <= 700/15
    #      So max x on x-axis is min(50, 700/15).
    x1 = min(500.0 / 10.0, 700.0 / 15.0)
    y1 = 0.0
    obj1 = 20.0 * x1 + 30.0 * y1

    #    - y-axis (x = 0):
    #        20y <= 500 -> y <= 25
    #        20y <= 700 -> y <= 35
    #      So max y on y-axis is min(25, 35) = 25.
    x2 = 0.0
    y2 = min(500.0 / 20.0, 700.0 / 20.0)
    obj2 = 20.0 * x2 + 30.0 * y2

    # 2) Intersection of the two constraints:
    #    10x + 20y = 500
    #    15x + 20y = 700
    # Subtract first from second:
    #    5x = 200 -> x = 40
    # Plug into first: 10*40 + 20y = 500 -> 400 + 20y = 500 -> y = 5
    x3 = 40.0
    y3 = 5.0
    obj3 = 20.0 * x3 + 30.0 * y3

    # Take the maximum objective value among feasible corners
    return max(obj1, obj2, obj3)
```",950.0,True,0.0,0.0,3.8948230743408203,
10,841.0,"```python
def solve():
    # We model:
    # x = number of carrier pigeons
    # y = number of owls
    #
    # Maximize letters:  L = 2x + 5y
    #
    # Constraints:
    # 1) Treats: 3x + 5y <= 1000
    # 2) Owl fraction: y <= 0.4(x + y)  ->  0.6y <= 0.4x  ->  3y <= 2x  ->  y <= (2/3)x
    # 3) At least 20 carrier pigeons: x >= 20
    # 4) x, y >= 0
    #
    # This is a small 2-variable LP; we can solve it analytically by checking corner points.

    # Corner 1: intersection of treats and owl-fraction constraints
    # 3x + 5y = 1000
    # 3y = 2x  ->  x = 1.5y
    # Substitute: 3(1.5y) + 5y = 1000 -> 4.5y + 5y = 1000 -> 9.5y = 1000
    y1 = 1000.0 / 9.5
    x1 = 1.5 * y1

    # Check x >= 20 (it is, but we keep general)
    if x1 < 20:
        # If this happened, we'd need to adjust, but numerically it doesn't.
        pass

    L1 = 2 * x1 + 5 * y1

    # Corner 2: intersection of treats constraint with x = 20
    # 3*20 + 5y = 1000 -> 60 + 5y = 1000 -> 5y = 940 -> y = 188
    x2 = 20.0
    y2 = 188.0
    # Check owl-fraction: y <= (2/3)x -> 188 <= 13.333... (violated), so infeasible.
    # We won't use this point.

    # Corner 3: intersection of owl-fraction with x = 20
    # y = (2/3)*20 = 40/3
    x3 = 20.0
    y3 = (2.0 / 3.0) * 20.0
    # Check treats: 3x + 5y <= 1000
    if 3 * x3 + 5 * y3 <= 1000:
        L3 = 2 * x3 + 5 * y3
    else:
        L3 = float('-inf')

    # Corner 4: x = 20, y = 0
    x4 = 20.0
    y4 = 0.0
    L4 = 2 * x4 + 5 * y4

    # The feasible region is bounded by these constraints; the optimum is at one of these corners.
    best = max(L1, L3, L4)

    return float(best)
```",842.1052631578947,False,1.105263157894683,0.001314224920206146,4.199543237686157,
11,80.0,"```python
def solve():
    # Let b = number of bikes, c = number of cars
    # Constraints:
    # 1) 3b + 5c >= 500  (capacity)
    # 2) c <= 0.4(b + c) => c <= (2/3)b => 3c <= 2b
    # 3) b, c >= 0
    # Objective: minimize b
    
    # From 3c <= 2b, we get b >= 1.5c.
    # To minimize b for a given c, set b = 1.5c.
    # Substitute into capacity: 3(1.5c) + 5c = 4.5c + 5c = 9.5c >= 500
    # => c >= 500 / 9.5
    c = 500.0 / 9.5
    b = 1.5 * c
    
    # The problem does not require integrality, so we return the minimal b as float.
    return b
```",78.94736842105263,False,1.05263157894737,0.01315789473667765,1.742100715637207,
12,37.0,"```python
def solve():
    # Let v = number of vans, c = number of cars
    # Constraints:
    # 1) 6v + 3c >= 200
    # 2) v <= 0.3(v + c)  ->  0.7v <= 0.3c  ->  7v <= 3c
    # Objective: minimize c
    
    # From 7v <= 3c, we get c >= (7/3)*v
    # From 6v + 3c >= 200, we get c >= (200 - 6v)/3
    # So c must be at least max((7/3)*v, (200 - 6v)/3), and c >= 0, v >= 0.
    # We search over nonnegative integers v, c.
    
    best_c = None
    
    # Upper bound for v: if all capacity from vans, 6v >= 200 -> v >= 34,
    # but van fraction constraint will limit v further. We'll just search a safe range.
    for v in range(0, 1000):
        # Compute minimal c from constraints
        c1 = (7 * v + 2) // 3  # ceil((7/3)*v)
        # For c2, only if 200 - 6v > 0; otherwise this constraint is inactive (c >= 0)
        if 200 - 6 * v > 0:
            num = 200 - 6 * v
            c2 = (num + 2) // 3  # ceil((200 - 6v)/3)
        else:
            c2 = 0
        
        c = max(c1, c2, 0)
        
        # Check constraints explicitly
        if 6 * v + 3 * c >= 200 and 7 * v <= 3 * c:
            if best_c is None or c < best_c:
                best_c = c
    
    # Return the optimal objective value (minimal number of cars) as float
    return float(best_c)
```",37.0,True,0.0,0.0,3.7889904975891113,
13,1.5,"```python
def solve():
    # Let x = minutes of Beam 1, y = minutes of Beam 2
    # Objective: minimize pancreas dose: 0.3x + 0.2y
    # Constraints:
    # 1) Skin dose: 0.2x + 0.1y <= 4
    # 2) Tumor dose: 0.6x + 0.4y >= 3
    # 3) x >= 0, y >= 0

    # We solve this small LP analytically by checking corner points of the feasible region.

    # Corner 1: Intersection of tumor constraint with x = 0
    # 0.6*0 + 0.4y >= 3 -> y >= 7.5
    # Check skin: 0.2*0 + 0.1*7.5 = 0.75 <= 4 (feasible)
    x1, y1 = 0.0, 7.5
    obj1 = 0.3 * x1 + 0.2 * y1

    # Corner 2: Intersection of tumor constraint with y = 0
    # 0.6x + 0.4*0 >= 3 -> x >= 5
    # Check skin: 0.2*5 + 0.1*0 = 1 <= 4 (feasible)
    x2, y2 = 5.0, 0.0
    obj2 = 0.3 * x2 + 0.2 * y2

    # Corner 3: Intersection of tumor and skin constraints
    # Tumor: 0.6x + 0.4y = 3
    # Skin:  0.2x + 0.1y = 4
    # Solve the system:
    # From skin: multiply by 2 -> 0.4x + 0.2y = 8
    # Subtract tumor: (0.4x + 0.2y) - (0.6x + 0.4y) = 8 - 3
    # => -0.2x - 0.2y = 5 -> x + y = -25 (infeasible, negative)
    # So there is no nonnegative intersection; skip this.

    # The feasible region is unbounded in the direction of increasing x,y,
    # but the objective coefficients are positive, so the minimum occurs at a corner.
    # Compare the objective values at the feasible corners we found.

    best_obj = min(obj1, obj2)

    return float(best_obj)
```",1.5,True,0.0,0.0,3.177403688430786,
14,75.00000000000001,"```python
def solve():
    # Let s = number of scooters, r = number of rickshaws
    # Constraints:
    # 1) 2s + 3r >= 300          (capacity)
    # 2) r <= 0.4(s + r)  ->  0.6r <= 0.4s  ->  3r <= 2s  ->  r <= (2/3)s
    # Objective: minimize s, with s, r >= 0 and (in reality) integers.
    #
    # We search over integer s and r satisfying constraints and find minimal s.
    
    best_s = None
    
    # Upper bound for s: worst case all scooters, 2s >= 300 -> s >= 150
    # So s in [0, 150] is enough to search.
    for s in range(151):
        # From pollution constraint: r <= (2/3)*s
        max_r = int((2 * s) // 3)  # integer r must satisfy this
        
        # We need some r in [0, max_r] such that 2s + 3r >= 300
        # This is equivalent to r >= (300 - 2s)/3
        if 2 * s >= 300:
            # Capacity already satisfied with r = 0
            r_min = 0
        else:
            # Need extra capacity from r
            needed = 300 - 2 * s
            # r must be at least ceil(needed / 3)
            r_min = (needed + 2) // 3  # integer ceiling
        
        if r_min <= max_r:
            # Feasible (s, r) exists
            if best_s is None or s < best_s:
                best_s = s
    
    # Return the optimal objective value as float
    return float(best_s)
```",75.0,True,1.4210854715202004e-14,1.8947806286683364e-16,3.379596710205078,
15,12860.0,"```python
def solve():
    # We need to solve the LP:
    # Minimize: 820*A + 550*V
    # Subject to:
    #   20A + 15V >= 320        (patient requirement)
    #   V <= 0.6(A + V)         (at most 60% of shifts are vans)
    #   A >= 0, V >= 0
    #
    # Convert the 60% constraint:
    #   V <= 0.6A + 0.6V
    #   0.4V <= 0.6A
    #   V <= 1.5A
    #
    # So constraints:
    #   20A + 15V >= 320
    #   V <= 1.5A
    #   A >= 0, V >= 0
    #
    # In 2D, the optimum of a linear program over a convex polyhedron
    # occurs at a vertex (intersection of constraints).
    #
    # Candidate vertices:
    # 1) Intersection of 20A + 15V = 320 and V = 1.5A
    # 2) Intersection of 20A + 15V = 320 and V = 0 (if feasible)
    # 3) Intersection of 20A + 15V = 320 and A = 0 (if feasible)
    #
    # Check each, enforce nonnegativity and V <= 1.5A, then compute cost.

    best_cost = None

    # 1) Intersection of 20A + 15V = 320 and V = 1.5A
    # Substitute V = 1.5A:
    #   20A + 15*(1.5A) = 320
    #   20A + 22.5A = 320
    #   42.5A = 320
    A1 = 320.0 / 42.5
    V1 = 1.5 * A1
    if A1 >= 0 and V1 >= 0 and V1 <= 1.5 * A1 and 20 * A1 + 15 * V1 >= 320 - 1e-9:
        cost1 = 820 * A1 + 550 * V1
        best_cost = cost1

    # 2) Intersection of 20A + 15V = 320 and V = 0
    #   20A = 320 -> A = 16
    A2 = 16.0
    V2 = 0.0
    if A2 >= 0 and V2 >= 0 and V2 <= 1.5 * A2 and 20 * A2 + 15 * V2 >= 320 - 1e-9:
        cost2 = 820 * A2 + 550 * V2
        if best_cost is None or cost2 < best_cost:
            best_cost = cost2

    # 3) Intersection of 20A + 15V = 320 and A = 0
    #   15V = 320 -> V = 320/15
    A3 = 0.0
    V3 = 320.0 / 15.0
    if A3 >= 0 and V3 >= 0 and V3 <= 1.5 * A3 and 20 * A3 + 15 * V3 >= 320 - 1e-9:
        cost3 = 820 * A3 + 550 * V3
        if best_cost is None or cost3 < best_cost:
            best_cost = cost3

    # Return the optimal objective value as float
    return float(best_cost)
```",12385.882352941175,False,474.11764705882524,0.03686762418808619,4.30271053314209,
16,1400.0,"```python
def solve():
    # Let x = units of cleansing chemical
    #     y = units of odor-removing chemical
    #
    # Objective: minimize total time
    # Time per unit: cleansing = 4 minutes, odor-removing = 6 minutes
    # Minimize: 4x + 6y
    #
    # Constraints:
    # 1) x >= 100                      (at least 100 units of cleansing)
    # 2) x + y >= 300                  (at least 300 total units)
    # 3) x <= 2y                       (at most twice as much cleansing as odor-removing)
    # 4) x >= 0, y >= 0
    #
    # This is a 2-variable LP; we can solve analytically by checking corner points.
    #
    # From constraints:
    # - From x + y >= 300 and x >= 100, feasible region starts at x >= 100, y >= 0.
    # - Also x <= 2y  =>  y >= x/2.
    #
    # Combine x + y >= 300 with y >= x/2:
    #   x + x/2 >= 300  =>  (3/2)x >= 300  =>  x >= 200.
    #
    # So feasible x must satisfy x >= 200, and then y must satisfy:
    #   y >= 300 - x
    #   y >= x/2
    #
    # For x >= 200, 300 - x <= 100, while x/2 >= 100, so y >= x/2 dominates.
    # Thus for any feasible x, minimal y is y = x/2.
    #
    # Objective as function of x:
    #   f(x) = 4x + 6*(x/2) = 4x + 3x = 7x
    # with x >= 200.
    #
    # Since 7x is increasing in x, minimum occurs at smallest feasible x, i.e. x = 200.
    # Then y = x/2 = 100.
    #
    # Optimal objective value:
    optimal_value = 4 * 200 + 6 * 100  # = 800 + 600 = 1400
    return float(optimal_value)
```",1400.0,True,0.0,0.0,2.6654255390167236,
17,500.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 5x + 4y
    # Subject to:
    # 50x + 40y <= 5000  (wood)
    # 20x + 30y <= 4000  (plastic)
    # x >= 0, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) x = 0:
    #    40y <= 5000 -> y <= 125
    #    30y <= 4000 -> y <= 4000/30
    y1 = min(5000.0 / 40.0, 4000.0 / 30.0)  # y when x=0
    x1 = 0.0
    z1 = 5 * x1 + 4 * y1

    # 2) y = 0:
    #    50x <= 5000 -> x <= 100
    #    20x <= 4000 -> x <= 200
    x2 = min(5000.0 / 50.0, 4000.0 / 20.0)  # x when y=0
    y2 = 0.0
    z2 = 5 * x2 + 4 * y2

    # 3) Intersection of:
    #    50x + 40y = 5000
    #    20x + 30y = 4000
    # Solve the system:
    # From second: 20x = 4000 - 30y -> x = (4000 - 30y)/20
    # Substitute into first:
    # 50*(4000 - 30y)/20 + 40y = 5000
    # Simplify:
    # (50/20)*(4000 - 30y) + 40y = 5000
    # (5/2)*(4000 - 30y) + 40y = 5000
    # (5/2)*4000 - (5/2)*30y + 40y = 5000
    # 10000 - 75y + 40y = 5000
    # 10000 - 35y = 5000
    # 35y = 5000
    # y = 5000/35
    y3 = 5000.0 / 35.0
    x3 = (4000.0 - 30.0 * y3) / 20.0
    z3 = 5 * x3 + 4 * y3

    # Optimal objective value is the maximum of z1, z2, z3
    return max(z1, z2, z3)
```",500.0,True,0.0,0.0,3.145817756652832,
18,60000.0,"```python
def solve():
    # We solve the LP:
    # Maximize 250x + 375y
    # subject to:
    # 30x + 20y <= 5000   (inspection time)
    # 120x + 145y <= 20000 (total schedule time: 90+30=120 for washer, 125+20=145 for freezer)
    # x, y >= 0
    
    # The optimum of a 2-variable LP lies at a corner (feasible vertex).
    # Candidate corners come from intersections of constraints and axes.
    
    # 1) Intersection with axes:
    # a) x = 0:
    #    30*0 + 20y <= 5000  -> y <= 250
    #    120*0 + 145y <= 20000 -> y <= 20000/145
    y1 = min(250, 20000.0 / 145.0)
    x1 = 0.0
    val1 = 250.0 * x1 + 375.0 * y1
    
    # b) y = 0:
    #    30x <= 5000 -> x <= 5000/30
    #    120x <= 20000 -> x <= 20000/120
    x2 = min(5000.0 / 30.0, 20000.0 / 120.0)
    y2 = 0.0
    val2 = 250.0 * x2 + 375.0 * y2
    
    # 2) Intersection of the two constraints:
    # 30x + 20y = 5000
    # 120x + 145y = 20000
    # Solve the system:
    # From first: y = (5000 - 30x)/20
    # Substitute into second:
    # 120x + 145*(5000 - 30x)/20 = 20000
    # We'll compute directly.
    import math
    
    # Solve linear system using determinant method:
    # a1 x + b1 y = c1
    # a2 x + b2 y = c2
    a1, b1, c1 = 30.0, 20.0, 5000.0
    a2, b2, c2 = 120.0, 145.0, 20000.0
    det = a1 * b2 - a2 * b1
    if abs(det) > 1e-12:
        x3 = (c1 * b2 - c2 * b1) / det
        y3 = (a1 * c2 - a2 * c1) / det
        # Check feasibility (nonnegative and satisfy constraints within tolerance)
        if x3 >= -1e-9 and y3 >= -1e-9:
            # Clip tiny negatives to zero
            x3 = max(0.0, x3)
            y3 = max(0.0, y3)
            # Check constraints
            if (30.0 * x3 + 20.0 * y3 <= 5000.0 + 1e-6 and
                120.0 * x3 + 145.0 * y3 <= 20000.0 + 1e-6):
                val3 = 250.0 * x3 + 375.0 * y3
            else:
                x3 = y3 = None
                val3 = -math.inf
        else:
            x3 = y3 = None
            val3 = -math.inf
    else:
        x3 = y3 = None
        val3 = -math.inf
    
    # Take the best of the feasible vertices
    best_val = max(val1, val2, val3)
    return float(best_val)
```",51724.137931034486,False,8275.862068965514,0.1379310344827563,4.844318628311157,
19,750.0,"```python
def solve():
    # Let x = packs of ramen, y = packs of fries
    # Minimize sodium: 100x + 75y
    # Subject to:
    # 1) Calories: 400x + 300y >= 3000
    # 2) Protein: 20x + 10y >= 80
    # 3) Ramen at most 30% of meals: x <= 0.3(x + y)
    # 4) x, y >= 0
    #
    # Convert constraint 3:
    # x <= 0.3x + 0.3y  ->  0.7x <= 0.3y  ->  7x <= 3y  ->  y >= (7/3)x

    # We solve analytically by checking intersection points of binding constraints.

    # Intersection of calories and ramen-fraction constraints:
    # 400x + 300y = 3000
    # y = (7/3)x
    # Substitute:
    # 400x + 300*(7/3)x = 3000
    # 400x + 700x = 3000
    # 1100x = 3000
    x = 3000.0 / 1100.0
    y = (7.0 / 3.0) * x

    # Check protein constraint:
    # 20x + 10y
    protein = 20.0 * x + 10.0 * y
    if protein < 80.0:
        # If this failed, we'd need more complex search, but it doesn't.
        # For completeness, we could implement a simple search, but it's unnecessary.
        pass

    # Compute sodium at this point:
    sodium = 100.0 * x + 75.0 * y
    return sodium
```",750.0,True,0.0,0.0,3.584832191467285,
20,1060.0,"```python
def solve():
    # We solve the LP:
    # Maximize 20x + 40y
    # subject to:
    # 2x + 1y = 70   (oven fully used)
    # 0.25x + 2y = 32 (chef fully used)
    # x, y >= 0
    
    # Solve the 2x2 linear system:
    # 2x + y = 70
    # 0.25x + 2y = 32
    
    # From first: y = 70 - 2x
    # Substitute into second:
    # 0.25x + 2(70 - 2x) = 32
    # 0.25x + 140 - 4x = 32
    # -3.75x = -108
    # x = 108 / 3.75
    x = 108.0 / 3.75
    # y = 70 - 2x
    y = 70.0 - 2.0 * x
    
    # Objective: 20x + 40y
    profit = 20.0 * x + 40.0 * y
    return profit
```",1072.0,False,12.0,0.011320754716970452,1.8676643371582031,
21,98.0,"```python
def solve():
    # We solve the linear program:
    # Maximize: 5x + 4y
    # Subject to:
    # 15x + 20y <= 450   (platinum)
    # 25x + 14y <= 390   (palladium)
    # x >= 0, y >= 0
    
    # The feasible region is a polygon; the optimum is at a vertex.
    # Vertices come from intersections of constraint lines and axes.
    
    candidates = []
    
    # 1) Intersection with axes:
    # x = 0:
    #   20y <= 450 -> y <= 22.5
    #   14y <= 390 -> y <= 27.857...
    # So y <= 22.5
    candidates.append((0.0, 22.5))
    
    # y = 0:
    #   15x <= 450 -> x <= 30
    #   25x <= 390 -> x <= 15.6
    # So x <= 15.6
    candidates.append((15.6, 0.0))
    
    # 2) Intersection of the two constraint lines:
    # 15x + 20y = 450
    # 25x + 14y = 390
    # Solve this 2x2 system.
    
    # We'll solve using basic algebra:
    # From first: 15x = 450 - 20y -> x = (450 - 20y)/15
    # Substitute into second:
    # 25*(450 - 20y)/15 + 14y = 390
    
    # To avoid floating issues, solve directly:
    # Multiply first eqn by 5: 75x + 100y = 2250
    # Multiply second eqn by 3: 75x + 42y = 1170
    # Subtract: (75x+100y) - (75x+42y) = 2250 - 1170
    # 58y = 1080 -> y = 1080/58
    y = 1080.0 / 58.0
    # Then x from first equation: 15x + 20y = 450
    x = (450.0 - 20.0 * y) / 15.0
    
    # Check feasibility (should be feasible by construction)
    if x >= 0 and y >= 0:
        # Also ensure it satisfies the inequalities (numerically)
        if 15*x + 20*y <= 450 + 1e-9 and 25*x + 14*y <= 390 + 1e-9:
            candidates.append((x, y))
    
    # Evaluate objective at all candidate points
    best_value = float('-inf')
    for x, y in candidates:
        value = 5.0 * x + 4.0 * y
        if value > best_value:
            best_value = value
    
    return best_value
```",100.34482758620689,False,2.3448275862068897,0.023926812103907784,3.6648924350738525,
22,160.0,"```python
def solve():
    # We need to minimize pollution: 7v + 10m
    # Subject to:
    # 1) 6v + 10m >= 150   (capacity)
    # 2) m <= 10           (at most 10 minibuses)
    # 3) v > m             (vans exceed minibuses)
    # 4) v, m are nonnegative integers
    
    best_value = None
    
    # m can range from 0 to 10 (inclusive)
    for m in range(0, 11):
        # v must be an integer, v > m, and satisfy capacity
        # From capacity: 6v + 10m >= 150 -> v >= (150 - 10m)/6
        min_v_capacity = (150 - 10 * m) / 6.0
        # v must be at least ceil of that, and also at least m+1
        v_start = int(min_v_capacity)
        if v_start < min_v_capacity:
            v_start += 1
        v_start = max(v_start, m + 1)
        
        if v_start < 0:
            continue
        
        # For fixed m, increasing v only increases pollution (7 per van),
        # so the best v is the smallest feasible v (v_start).
        v = v_start
        
        # Check feasibility again (for safety)
        if 6 * v + 10 * m >= 150 and v > m and m <= 10:
            pollution = 7 * v + 10 * m
            if best_value is None or pollution < best_value:
                best_value = pollution
    
    # Return the optimal objective value as float
    return float(best_value)
```",160.0,True,0.0,0.0,4.1011271476745605,
23,35.0,"```python
def solve():
    # We need integers:
    # L = number of large units
    # S = number of small units
    #
    # Constraints:
    # 1) Capacity: 6L + 2S >= 80
    # 2) At least 5 small units: S >= 5
    # 3) Large units at least 75% of all vehicles:
    #       L >= 0.75(L + S)
    #    => 4L >= 3L + 3S
    #    => L >= 3S
    #
    # Objective: minimize parking spots: 2L + S
    #
    # We'll brute force over reasonable integer ranges.

    best_value = None

    # Upper bounds: in worst case all small: 2S >= 80 => S <= 40
    # With L >= 3S, L can be up to, say, 3*40 = 120 in a naive bound.
    # We'll search within these safe bounds.
    for S in range(5, 41):  # S >= 5, and S <= 40 is enough for capacity
        # From L >= 3S
        L_min_ratio = 3 * S

        # From capacity: 6L + 2S >= 80 => 6L >= 80 - 2S
        rhs = 80 - 2 * S
        if rhs <= 0:
            L_min_capacity = 0
        else:
            # ceil(rhs / 6)
            L_min_capacity = (rhs + 5) // 6

        L_min = max(L_min_ratio, L_min_capacity)

        # No explicit upper bound needed; just check a small range above L_min
        # but we can reason: more L increases spots (2 per L), so minimal L is best.
        L = L_min

        # Check feasibility
        if 6 * L + 2 * S >= 80 and L >= 3 * S:
            spots = 2 * L + S
            if best_value is None or spots < best_value:
                best_value = spots

    # Return the minimal number of parking spots as float
    return float(best_value)
```",35.0,True,0.0,0.0,2.848689556121826,
24,7.0,"```python
def solve():
    # We want to minimize cost: 1*x + 3*y
    # Subject to:
    #   1.3x + 1.2y >= 5   (Z1 requirement)
    #   1.5x + 5y   >= 10  (D3 requirement)
    #   x >= 0, y >= 0
    #
    # For a 2-variable LP, the optimum lies at a corner (feasible vertex).
    # We'll:
    # 1) Enumerate candidate corner points:
    #    - Intersections of each pair of constraint boundaries
    #    - Intersections with axes (x=0 or y=0)
    # 2) Check feasibility and compute cost.
    # 3) Return the minimum cost.
    
    INF = float('inf')
    best = INF

    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 1.3 * x + 1.2 * y < 5 - 1e-9:
            return False
        if 1.5 * x + 5.0 * y < 10 - 1e-9:
            return False
        return True

    def cost(x, y):
        return 1.0 * x + 3.0 * y

    # 1) Intersection of the two main constraints:
    # 1.3x + 1.2y = 5
    # 1.5x + 5y   = 10
    # Solve via Cramer's rule.
    a11, a12, b1 = 1.3, 1.2, 5.0
    a21, a22, b2 = 1.5, 5.0, 10.0
    det = a11 * a22 - a12 * a21
    if abs(det) > 1e-12:
        x_int = (b1 * a22 - a12 * b2) / det
        y_int = (a11 * b2 - b1 * a21) / det
        if feasible(x_int, y_int):
            best = min(best, cost(x_int, y_int))

    # 2) Intersections with axes:
    # x = 0:
    #   1.3*0 + 1.2y >= 5  => y >= 5/1.2
    #   1.5*0 + 5y   >= 10 => y >= 10/5 = 2
    # So y must be >= max(5/1.2, 2)
    y0 = max(5.0 / 1.2, 2.0)
    if feasible(0.0, y0):
        best = min(best, cost(0.0, y0))

    # y = 0:
    #   1.3x >= 5  => x >= 5/1.3
    #   1.5x >= 10 => x >= 10/1.5
    x0 = max(5.0 / 1.3, 10.0 / 1.5)
    if feasible(x0, 0.0):
        best = min(best, cost(x0, 0.0))

    # Return the optimal objective value
    return float(best)
```",6.276595744680851,False,0.7234042553191493,0.1033434650308294,4.626108169555664,
25,4990.0,"```python
def solve():
    # We need to solve the LP:
    # Maximize 15x + 17y
    # Subject to:
    # 40 <= x <= 140
    # 60 <= y <= 170
    # x + y >= 200
    
    # Since this is a 2-variable linear program with simple bounds,
    # we can search over all feasible integer (x, y) pairs and find the maximum.
    # (The problem is naturally in integers: number of workbooks.)
    
    best_value = None
    
    for x in range(40, 141):   # x from 40 to 140 inclusive
        for y in range(60, 171):  # y from 60 to 170 inclusive
            if x + y >= 200:
                value = 15 * x + 17 * y
                if best_value is None or value > best_value:
                    best_value = value
    
    # Return the optimal objective value as a float
    return float(best_value)
```",4990.0,True,0.0,0.0,1.7077431678771973,
26,-99999.0,"```python
def solve():
    # We formulate the LP:
    # Maximize: 100*x + 300*y
    # Subject to:
    #   50*x + 100*y <= 1000   (budget)
    #   x <= y                (sled dog trips less than or equal to truck trips)
    #   x >= 0, y >= 0
    #
    # This is a 2-variable LP, so we can solve it analytically by checking corner points.
    #
    # Constraints:
    # 1) 50x + 100y <= 1000  ->  x + 2y <= 20
    # 2) x <= y
    # 3) x >= 0, y >= 0
    #
    # Feasible region corners come from intersections of:
    #   - x = 0
    #   - y = 0
    #   - x = y
    #   - x + 2y = 20
    #
    # Check candidate points:
    # A: (0, 0)
    # B: intersection of x = 0 and x + 2y = 20 -> (0, 10)
    # C: intersection of x = y and x + 2y = 20 -> 3y = 20 -> (20/3, 20/3)
    #
    # Also check where x = y and y = 0 -> (0, 0) already included.
    #
    # Verify feasibility and compute objective at each candidate.

    candidates = [
        (0.0, 0.0),
        (0.0, 10.0),
        (20.0 / 3.0, 20.0 / 3.0),
    ]

    best_value = float('-inf')
    for x, y in candidates:
        # Check feasibility
        if x < 0 or y < 0:
            continue
        if 50 * x + 100 * y > 1000 + 1e-9:
            continue
        if x - y > 1e-9:  # x <= y
            continue

        value = 100 * x + 300 * y
        if value > best_value:
            best_value = value

    # best_value is the optimal objective value
    return float(best_value)
```",3000.0,False,102999.0,1.0300003000029896,2.9884254932403564,
27,67.0,"```python
def solve():
    # We solve the LP:
    # Minimize: x + y
    # Subject to:
    # 1) 50x + 75y >= 5000   (washing capacity)
    # 2) 85x + 100y <= 7000  (energy)
    # 3) x <= (2/3) y        (at most 40% top-loading: x/(x+y) <= 0.4)
    # 4) y >= 10             (at least 10 front-loading)
    # 5) x >= 0, y >= 0
    
    # We'll solve this by enumerating intersection points of constraint boundaries
    # and checking feasibility, then picking the one with minimal x + y.
    
    best_val = float('inf')
    
    def check_and_update(x, y):
        nonlocal best_val
        # Feasibility checks with small tolerance
        if x < -1e-9 or y < 10 - 1e-9:
            return
        if 50*x + 75*y < 5000 - 1e-9:
            return
        if 85*x + 100*y > 7000 + 1e-9:
            return
        if x > (2.0/3.0)*y + 1e-9:
            return
        val = x + y
        if val < best_val:
            best_val = val
    
    # 1) Intersection of capacity and energy:
    # 50x + 75y = 5000
    # 85x + 100y = 7000
    # Solve:
    # From first: x = (5000 - 75y)/50
    # Substitute into second:
    # 85*(5000 - 75y)/50 + 100y = 7000
    # We'll solve directly.
    import math
    
    # Solve linear system A * [x,y]^T = b
    # A = [[50, 75],[85,100]], b = [5000,7000]
    det = 50*100 - 75*85
    if abs(det) > 1e-12:
        x = (5000*100 - 75*7000) / det
        y = (50*7000 - 5000*85) / det
        check_and_update(x, y)
    
    # 2) Intersection of capacity and x = (2/3) y
    # 50x + 75y = 5000, x = (2/3)y
    # 50*(2/3 y) + 75y = 5000 -> (100/3 + 75) y = 5000
    # 75 = 225/3, so (325/3) y = 5000 -> y = 5000 * 3 / 325
    y = 5000 * 3.0 / 325.0
    x = (2.0/3.0) * y
    check_and_update(x, y)
    
    # 3) Intersection of energy and x = (2/3) y
    # 85x + 100y = 7000, x = (2/3)y
    # 85*(2/3 y) + 100y = 7000 -> (170/3 + 100) y = 7000
    # 100 = 300/3, so (470/3) y = 7000 -> y = 7000 * 3 / 470
    y = 7000 * 3.0 / 470.0
    x = (2.0/3.0) * y
    check_and_update(x, y)
    
    # 4) Intersection of capacity and y = 10
    # 50x + 75*10 = 5000 -> 50x + 750 = 5000 -> 50x = 4250 -> x = 85
    y = 10.0
    x = (5000 - 75*y) / 50.0
    check_and_update(x, y)
    
    # 5) Intersection of energy and y = 10
    # 85x + 100*10 = 7000 -> 85x + 1000 = 7000 -> 85x = 6000 -> x = 6000/85
    y = 10.0
    x = (7000 - 100*y) / 85.0
    check_and_update(x, y)
    
    # 6) Intersection of y = 10 and x = (2/3) y
    y = 10.0
    x = (2.0/3.0) * y
    check_and_update(x, y)
    
    # Also consider potential boundary where capacity is just met and energy is slack,
    # or vice versa, but these are already covered by intersections above.
    
    # Return the optimal objective value (minimal number of machines)
    return float(best_val)
```",72.72727272727273,False,5.727272727272734,0.08548168249533211,5.550465106964111,
28,29.0,"```python
def solve():
    # We need nonnegative integers c (cows) and e (elephants)
    # Minimize total animals: c + e
    # Subject to:
    # 1) Brick capacity: 20c + 50e >= 1000
    # 2) e <= c
    # 3) c <= 2e
    
    best = None
    
    # Upper bound for search:
    # In the extreme case of only cows: 20c >= 1000 -> c >= 50
    # In the extreme case of only elephants: 50e >= 1000 -> e >= 20
    # But constraints tie c and e, so we search a reasonable range.
    # Since each animal carries at least 20 bricks, 1000/20 = 50 animals is a loose upper bound.
    # We'll search a bit beyond to be safe.
    max_animals = 100  # more than enough for this small problem
    
    for c in range(max_animals + 1):
        for e in range(max_animals + 1):
            # Apply constraints
            if e <= c and c <= 2 * e and 20 * c + 50 * e >= 1000:
                total = c + e
                if best is None or total < best:
                    best = total
    
    # best is the minimum number of animals
    return float(best if best is not None else 0.0)
```",29.0,True,0.0,0.0,2.047531843185425,
29,369.0,"```python
def solve():
    # We model:
    # x = number of catalyst processes
    # y = number of non-catalyst processes
    #
    # Maximize: 15x + 18y
    # Subject to:
    # 10x + 15y <= 300  (wood)
    # 20x + 12y <= 300  (oxygen)
    # x >= 0, y >= 0
    
    # We'll solve this small 2-variable LP by checking all corner points
    # of the feasible region.
    
    best_value = 0.0
    
    # 1) Corner at (0,0)
    def objective(x, y):
        return 15.0 * x + 18.0 * y
    
    # Check feasibility helper
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 10 * x + 15 * y > 300:
            return False
        if 20 * x + 12 * y > 300:
            return False
        return True
    
    # Check (0,0)
    if feasible(0.0, 0.0):
        best_value = max(best_value, objective(0.0, 0.0))
    
    # 2) Intersections with axes:
    # x-axis: y = 0
    #   10x <= 300 -> x <= 30
    #   20x <= 300 -> x <= 15
    # So max x on x-axis is 15
    if feasible(15.0, 0.0):
        best_value = max(best_value, objective(15.0, 0.0))
    
    # y-axis: x = 0
    #   15y <= 300 -> y <= 20
    #   12y <= 300 -> y <= 25
    # So max y on y-axis is 20
    if feasible(0.0, 20.0):
        best_value = max(best_value, objective(0.0, 20.0))
    
    # 3) Intersection of the two constraint lines:
    # 10x + 15y = 300
    # 20x + 12y = 300
    #
    # Solve the system:
    # From first: 10x = 300 - 15y -> x = (300 - 15y)/10
    # Substitute into second:
    # 20*(300 - 15y)/10 + 12y = 300
    # 2*(300 - 15y) + 12y = 300
    # 600 - 30y + 12y = 300
    # 600 - 18y = 300
    # 18y = 300
    # y = 300/18 = 50/3
    y_inter = 50.0 / 3.0
    x_inter = (300.0 - 15.0 * y_inter) / 10.0
    
    if feasible(x_inter, y_inter):
        best_value = max(best_value, objective(x_inter, y_inter))
    
    return float(best_value)
```",374.99999999999994,False,5.999999999999943,0.016260162601581796,3.687861204147339,
30,206250.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 300*T + 450*P
    # Subject to:
    #   T + P <= 500          (land)
    #   50*T + 90*P <= 40000  (water)
    #   80*T + 50*P <= 34000  (pesticide)
    #   T >= 0, P >= 0
    
    # The optimum of a 2-variable LP lies at a corner (feasible intersection of constraints).
    # We'll compute all candidate corner points and pick the best feasible one.
    
    import math

    def is_feasible(T, P):
        eps = 1e-9
        if T < -eps or P < -eps:
            return False
        if T + P > 500 + eps:
            return False
        if 50*T + 90*P > 40000 + eps:
            return False
        if 80*T + 50*P > 34000 + eps:
            return False
        return True

    def revenue(T, P):
        return 300*T + 450*P

    candidates = []

    # Intersections of pairs of constraints (treated as equalities)

    # 1) Land & Water:
    #    T + P = 500
    #    50T + 90P = 40000
    # Solve:
    # From first: T = 500 - P
    # Plug into second:
    # 50(500 - P) + 90P = 40000
    # 25000 - 50P + 90P = 40000
    # 25000 + 40P = 40000
    # 40P = 15000 -> P = 375, T = 125
    T, P = 125.0, 375.0
    if is_feasible(T, P):
        candidates.append((T, P))

    # 2) Land & Pesticide:
    #    T + P = 500
    #    80T + 50P = 34000
    # T = 500 - P
    # 80(500 - P) + 50P = 34000
    # 40000 - 80P + 50P = 34000
    # 40000 - 30P = 34000
    # 30P = 6000 -> P = 200, T = 300
    T, P = 300.0, 200.0
    if is_feasible(T, P):
        candidates.append((T, P))

    # 3) Water & Pesticide:
    #    50T + 90P = 40000
    #    80T + 50P = 34000
    # Solve the 2x2 system:
    # We'll do it algebraically:
    # Multiply first eqn by 8: 400T + 720P = 320000
    # Multiply second eqn by 5: 400T + 250P = 170000
    # Subtract: (400T+720P)-(400T+250P) = 320000-170000
    # 470P = 150000 -> P = 150000/470
    P = 150000.0 / 470.0
    # From 50T + 90P = 40000 -> T = (40000 - 90P)/50
    T = (40000.0 - 90.0 * P) / 50.0
    if is_feasible(T, P):
        candidates.append((T, P))

    # Intersections with axes:

    # 4) T = 0, satisfy constraints:
    #    P <= 500
    #    90P <= 40000 -> P <= 40000/90
    #    50P <= 34000 -> P <= 34000/50
    P_max_T0 = min(500.0, 40000.0/90.0, 34000.0/50.0)
    T, P = 0.0, P_max_T0
    if is_feasible(T, P):
        candidates.append((T, P))

    # 5) P = 0, satisfy constraints:
    #    T <= 500
    #    50T <= 40000 -> T <= 40000/50
    #    80T <= 34000 -> T <= 34000/80
    T_max_P0 = min(500.0, 40000.0/50.0, 34000.0/80.0)
    T, P = T_max_P0, 0.0
    if is_feasible(T, P):
        candidates.append((T, P))

    # Also include origin
    if is_feasible(0.0, 0.0):
        candidates.append((0.0, 0.0))

    # Evaluate all candidates
    best_val = -math.inf
    for T, P in candidates:
        val = revenue(T, P)
        if val > best_val:
            best_val = val

    return float(best_val)
```",206250.0,True,0.0,0.0,5.329617500305176,
31,84.0,"```python
def solve():
    # Let x = number of carts, y = number of trolleys
    # Objective: minimize workers = 2x + 4y
    # Constraints:
    # 1) Transport rate: 5x + 7y = 100  (must deliver exactly 100 kg/min)
    # 2) At least 12 trolleys: y >= 12
    # 3) At most 40% of transport via trolleys:
    #    7y <= 0.4 * 100 = 40  ->  y <= 40/7
    #
    # Combine 2) and 3): y must satisfy 12 <= y <= 40/7.
    # But 40/7 â‰ˆ 5.714, so there is no feasible y satisfying both.
    #
    # Therefore, the linear program is infeasible.
    # The problem asks for the optimal objective value; since no feasible
    # solution exists, we can return float('inf') to indicate infeasibility.

    return float('inf')
```",inf,False,inf,inf,1.6727991104125977,
32,600.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 15a + 12c
    # Subject to:
    #   200a + 300c >= 10000   (calories)
    #   20a  + 25c  >= 800     (protein)
    #   a >= 2c                (at least twice as many almonds as cashews)
    #   a >= 0, c >= 0
    #
    # We'll search over the feasible region's corner points by solving
    # pairs of constraint equalities and checking feasibility.
    
    import math

    def is_feasible(a, c):
        if a < 0 or c < 0:
            return False
        if 200*a + 300*c < 10000 - 1e-9:
            return False
        if 20*a + 25*c < 800 - 1e-9:
            return False
        if a < 2*c - 1e-9:
            return False
        return True

    def objective(a, c):
        return 15*a + 12*c

    candidates = []

    # 1) Intersection of calories and protein constraints:
    # 200a + 300c = 10000
    # 20a + 25c  = 800
    # Solve:
    # From second: 4a + 5c = 160
    # Multiply by 50: 200a + 250c = 8000
    # Subtract from first: (200a+300c)-(200a+250c)=10000-8000 => 50c=2000 => c=40
    # Then 4a + 5*40 = 160 => 4a + 200 = 160 => a = -10 (infeasible)
    a = -10.0
    c = 40.0
    if is_feasible(a, c):
        candidates.append((a, c))

    # 2) Calories and a = 2c:
    # 200a + 300c = 10000, a = 2c
    # 200*(2c) + 300c = 10000 => 700c = 10000 => c = 10000/700
    c = 10000.0 / 700.0
    a = 2.0 * c
    if is_feasible(a, c):
        candidates.append((a, c))

    # 3) Protein and a = 2c:
    # 20a + 25c = 800, a = 2c
    # 20*(2c) + 25c = 800 => 65c = 800 => c = 800/65
    c = 800.0 / 65.0
    a = 2.0 * c
    if is_feasible(a, c):
        candidates.append((a, c))

    # 4) Intersections with axes and a=2c where relevant:
    # c = 0:
    #   calories: 200a >= 10000 => a >= 50
    #   protein:  20a >= 800   => a >= 40
    #   a >= 2*0 => a >= 0
    # So minimal a on c=0 is a=50
    a = 50.0
    c = 0.0
    if is_feasible(a, c):
        candidates.append((a, c))

    # a = 0:
    #   a >= 2c => 0 >= 2c => c <= 0 and c>=0 => c=0
    #   But then calories and protein not satisfied, so infeasible.

    # Also consider where each main constraint just meets equality
    # under the a >= 2c condition by minimizing a for each:
    # For calories: 200a + 300c = 10000, a >= 2c
    # Express a = 2c, we already did that (candidate 2).
    # For protein: 20a + 25c = 800, a >= 2c
    # Express a = 2c, we already did that (candidate 3).

    # Now evaluate objective on all candidates
    if not candidates:
        return float('nan')

    best_val = float('inf')
    for a, c in candidates:
        val = objective(a, c)
        if val < best_val:
            best_val = val

    return float(best_val)
```",600.0,True,0.0,0.0,6.007383108139038,
33,239.0,"```python
def solve():
    # We solve the LP:
    # Maximize 5x + 9y
    # subject to:
    # 50x + 30y <= 3000  (shaping)
    # 90x + 150y <= 4000 (baking)
    # x >= 0, y >= 0
    
    # The optimal solution for a 2-variable LP lies at a corner (feasible vertex).
    # We'll compute all candidate corner points and evaluate the objective.
    
    best_value = 0.0
    
    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 50*x + 30*y > 3000:
            return False
        if 90*x + 150*y > 4000:
            return False
        return True
    
    # Candidate 1: intersection of shaping constraint with x-axis (y = 0)
    # 50x <= 3000 -> x = 3000/50
    x1, y1 = 3000.0 / 50.0, 0.0
    if feasible(x1, y1):
        best_value = max(best_value, 5*x1 + 9*y1)
    
    # Candidate 2: intersection of shaping constraint with y-axis (x = 0)
    # 30y <= 3000 -> y = 3000/30
    x2, y2 = 0.0, 3000.0 / 30.0
    if feasible(x2, y2):
        best_value = max(best_value, 5*x2 + 9*y2)
    
    # Candidate 3: intersection of baking constraint with x-axis (y = 0)
    # 90x <= 4000 -> x = 4000/90
    x3, y3 = 4000.0 / 90.0, 0.0
    if feasible(x3, y3):
        best_value = max(best_value, 5*x3 + 9*y3)
    
    # Candidate 4: intersection of baking constraint with y-axis (x = 0)
    # 150y <= 4000 -> y = 4000/150
    x4, y4 = 0.0, 4000.0 / 150.0
    if feasible(x4, y4):
        best_value = max(best_value, 5*x4 + 9*y4)
    
    # Candidate 5: intersection of the two constraints:
    # 50x + 30y = 3000
    # 90x + 150y = 4000
    # Solve the system:
    # From first: x = (3000 - 30y)/50
    # Substitute into second:
    # 90*(3000 - 30y)/50 + 150y = 4000
    # Simplify:
    # (90*3000)/50 - (90*30/50)*y + 150y = 4000
    # 5400 - 54y + 150y = 4000
    # 5400 + 96y = 4000
    # 96y = -1400 -> y = -1400/96 (negative, so infeasible)
    y5 = -1400.0 / 96.0
    x5 = (3000.0 - 30.0 * y5) / 50.0
    if feasible(x5, y5):
        best_value = max(best_value, 5*x5 + 9*y5)
    
    return float(best_value)
```",240.0,False,1.0,0.0041841004183925355,3.4820749759674072,
34,33.5,"```python
def solve():
    # We need to minimize total time:
    # Let b = number of bus trips, c = number of car trips.
    # Objective: minimize T = 2*b + 1.5*c
    #
    # Constraints:
    # 1) Capacity: 100*b + 40*c >= 1200
    # 2) At most 10 bus trips: b <= 10
    # 3) At least 60% of trips by car: c >= 1.5 * b
    # 4) b, c >= 0 and integer (trips are discrete)
    #
    # We'll brute-force over feasible integer (b, c) pairs with small bounds.

    best_time = None

    # Reasonable upper bounds:
    # b is at most 10 by constraint.
    # For c, even if b=0, we need 40*c >= 1200 => c >= 30.
    # We'll search c up to, say, 50 to be safe.
    for b in range(0, 11):  # b <= 10
        # Minimum c from 60% car trips: c >= 1.5*b
        c_min_ratio = int(1.5 * b)
        if 1.5 * b > c_min_ratio:
            c_min_ratio += 1  # ceil

        # Minimum c from capacity: 100*b + 40*c >= 1200
        # => 40*c >= 1200 - 100*b
        # If RHS <= 0, capacity is already satisfied by buses alone, so c can be 0.
        rhs = 1200 - 100 * b
        if rhs <= 0:
            c_min_capacity = 0
        else:
            c_min_capacity = rhs // 40
            if 40 * c_min_capacity < rhs:
                c_min_capacity += 1  # ceil

        c_start = max(c_min_ratio, c_min_capacity, 0)

        # Upper bound for c: just a safe bound, say 50
        for c in range(c_start, 51):
            # Check constraints explicitly (though they should already hold)
            if 100 * b + 40 * c < 1200:
                continue
            if c < 1.5 * b:
                continue

            time = 2 * b + 1.5 * c
            if best_time is None or time < best_time:
                best_time = time

    # Return the optimal objective value (minimal total time)
    return float(best_time)
```",33.5,True,0.0,0.0,3.7090682983398438,
35,4400.0,"```python
def solve():
    # We solve the LP by enumerating all corner points of the feasible region.
    # Variables:
    #   x = gallons of chocolate
    #   y = gallons of vanilla
    #
    # Constraints:
    #   1) 5 <= x <= 10
    #   2) 5 <= y <= 8
    #   3) Time: x + 2y <= 30
    #   4) Workers: x + 2y >= 6
    #
    # Objective: maximize 200x + 300y

    # We'll generate all candidate corner points from intersections of constraint boundaries
    # and then filter those that satisfy all inequalities.

    candidates = []

    # Helper to check feasibility
    def feasible(x, y):
        if x < 5 or x > 10:
            return False
        if y < 5 or y > 8:
            return False
        if x + 2*y > 30:
            return False
        if x + 2*y < 6:
            return False
        return True

    # Add all intersections of boundary lines:
    # Boundaries:
    #   x = 5, x = 10
    #   y = 5, y = 8
    #   x + 2y = 30
    #   x + 2y = 6

    # 1) Intersections of x=const with y=const
    for x in [5, 10]:
        for y in [5, 8]:
            if feasible(x, y):
                candidates.append((x, y))

    # 2) Intersections of x=const with x+2y=30 and x+2y=6
    for x in [5, 10]:
        for rhs in [30, 6]:
            y = (rhs - x) / 2.0
            if feasible(x, y):
                candidates.append((x, y))

    # 3) Intersections of y=const with x+2y=30 and x+2y=6
    for y in [5, 8]:
        for rhs in [30, 6]:
            x = rhs - 2.0 * y
            if feasible(x, y):
                candidates.append((x, y))

    # 4) Intersection of x+2y=30 and x+2y=6 is impossible (parallel, same left side),
    # so no need to compute.

    # Remove duplicates (if any)
    unique_candidates = []
    seen = set()
    for x, y in candidates:
        key = (round(x, 10), round(y, 10))
        if key not in seen:
            seen.add(key)
            unique_candidates.append((x, y))

    # Evaluate objective at each feasible corner
    best_value = None
    for x, y in unique_candidates:
        value = 200.0 * x + 300.0 * y
        if best_value is None or value > best_value:
            best_value = value

    # Return the optimal objective value
    return float(best_value)
```",4400.0,True,0.0,0.0,3.5677247047424316,
36,150000.0,"```python
def solve():
    # Let x = number of senior accountants
    #     y = number of junior accountants
    #
    # Minimize cost: 3000x + 1000y
    #
    # Subject to:
    # 1) x + y >= 100          (at least 100 accountants)
    # 2) x >= 5                (at least 5 seniors)
    # 3) x >= (1/3) y          (seniors at least a third of juniors)
    # 4) 3000x + 1000y <= 150000 (wage bill below or equal 150000)
    # 5) x, y >= 0
    #
    # This is a small 2-variable LP; we can solve it analytically by checking
    # all corner points formed by intersecting the constraint boundaries.
    #
    # We'll treat x, y as continuous (standard LP relaxation).
    
    import math

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if x + y < 100 - 1e-9:
            return False
        if x < 5 - 1e-9:
            return False
        if x < (1.0/3.0)*y - 1e-9:
            return False
        if 3000*x + 1000*y > 150000 + 1e-9:
            return False
        return True

    # Collect candidate points from intersections of constraint boundaries.
    candidates = []

    # Constraints as equalities (labels):
    # A: x + y = 100
    # B: x = 5
    # C: x = (1/3) y  -> 3x = y
    # D: 3000x + 1000y = 150000

    # Intersection A & B: x=5, x+y=100 -> y=95
    x = 5.0
    y = 100.0 - x
    candidates.append((x, y))

    # Intersection A & C: x + y = 100, y = 3x -> x + 3x = 100 -> x=25, y=75
    x = 25.0
    y = 75.0
    candidates.append((x, y))

    # Intersection A & D: x + y = 100, 3000x + 1000y = 150000
    # Substitute y = 100 - x:
    # 3000x + 1000(100 - x) = 150000
    # 3000x + 100000 - 1000x = 150000
    # 2000x = 50000 -> x = 25, y = 75 (same as A & C)
    x = 25.0
    y = 75.0
    candidates.append((x, y))

    # Intersection B & C: x=5, y=3x=15
    x = 5.0
    y = 15.0
    candidates.append((x, y))

    # Intersection B & D: x=5, 3000*5 + 1000y = 150000 -> 15000 + 1000y = 150000
    # 1000y = 135000 -> y = 135
    x = 5.0
    y = 135.0
    candidates.append((x, y))

    # Intersection C & D: y = 3x, 3000x + 1000(3x) = 150000
    # 3000x + 3000x = 150000 -> 6000x = 150000 -> x = 25, y = 75 (same)
    x = 25.0
    y = 75.0
    candidates.append((x, y))

    # Also consider intersections with non-negativity and minimum constraints:
    # x = 5 with A already done; x=5 with C, D done.
    # y = 0 with A: x=100; with C: x=0; with D: 3000x=150000 -> x=50.
    # Check these as well.
    # y = 0, x = 100 (from A)
    candidates.append((100.0, 0.0))
    # y = 0, x = 0 (from C)
    candidates.append((0.0, 0.0))
    # y = 0, x = 50 (from D)
    candidates.append((50.0, 0.0))

    # Now evaluate feasible candidates and pick minimum cost
    best_val = math.inf
    for x, y in candidates:
        if feasible(x, y):
            cost = 3000.0 * x + 1000.0 * y
            if cost < best_val:
                best_val = cost

    # In case numerical issues or missed corners, we can also do a small search
    # over a reasonable grid to ensure we didn't miss a better point.
    # This is safe because the feasible region is small.
    # We'll refine around the range suggested by constraints.
    # x must be at least 5 and at most 50 (from wage constraint with y>=0).
    # y must be at least 0 and at most 150 (from wage constraint with x>=0).
    for x in [5 + i * 0.5 for i in range(int((50 - 5) / 0.5) + 1)]:
        # From x + y >= 100 and wage constraint:
        # y >= 100 - x
        # y <= (150000 - 3000x)/1000
        y_min = max(0.0, 100.0 - x)
        y_max = (150000.0 - 3000.0 * x) / 1000.0
        if y_max < y_min:
            continue
        # Also must satisfy x >= y/3 -> y <= 3x
        y_max = min(y_max, 3.0 * x)
        if y_max < y_min:
            continue
        # Sample a few points between y_min and y_max
        for frac in [0.0, 0.25, 0.5, 0.75, 1.0]:
            y = y_min + frac * (y_max - y_min)
            if feasible(x, y):
                cost = 3000.0 * x + 1000.0 * y
                if cost < best_val:
                    best_val = cost

    return float(best_val)
```",150000.0,True,0.0,0.0,8.708335638046265,
37,648.0,"```python
def solve():
    # We solve the LP:
    # Maximize 12x + 10y + 15z
    # s.t.
    #   400x + 500y + 450z <= 20000   (batter)
    #   200x + 300y + 350z <= 14000   (milk)
    #   x, y, z >= 0
    #
    # With 3 variables and 2 constraints, the optimum lies at a corner point
    # where two constraints (including non-negativity) are tight.
    # We'll enumerate all candidate corner points formed by:
    # - Any two of the 4 constraints being equalities:
    #   C1: 400x + 500y + 450z = 20000
    #   C2: 200x + 300y + 350z = 14000
    #   C3: x = 0
    #   C4: y = 0
    #   C5: z = 0
    #
    # For each pair, we solve the resulting system (2 equations, 3 unknowns)
    # by setting the remaining variable to 0 if not already fixed, then check feasibility.

    best_val = float(""-inf"")

    # Helper to check feasibility and update best value
    def check_point(x, y, z):
        nonlocal best_val
        if x < -1e-9 or y < -1e-9 or z < -1e-9:
            return
        # Enforce non-negativity with small tolerance
        x = max(0.0, x)
        y = max(0.0, y)
        z = max(0.0, z)
        if 400*x + 500*y + 450*z <= 20000 + 1e-6 and 200*x + 300*y + 350*z <= 14000 + 1e-6:
            val = 12*x + 10*y + 15*z
            if val > best_val:
                best_val = val

    # 1) Intersections with two resource constraints and one variable set to 0

    # Case: C1 & C2 with x = 0
    # 500y + 450z = 20000
    # 300y + 350z = 14000
    # Solve 2x2
    def solve_2x2(a11, a12, b1, a21, a22, b2):
        det = a11 * a22 - a12 * a21
        if abs(det) < 1e-12:
            return None
        y = (b1 * a22 - a12 * b2) / det
        z = (a11 * b2 - b1 * a21) / det
        return y, z

    # x = 0
    res = solve_2x2(500, 450, 20000, 300, 350, 14000)
    if res is not None:
        y, z = res
        check_point(0.0, y, z)

    # y = 0
    # 400x + 450z = 20000
    # 200x + 350z = 14000
    res = solve_2x2(400, 450, 20000, 200, 350, 14000)
    if res is not None:
        x, z = res
        check_point(x, 0.0, z)

    # z = 0
    # 400x + 500y = 20000
    # 200x + 300y = 14000
    res = solve_2x2(400, 500, 20000, 200, 300, 14000)
    if res is not None:
        x, y = res
        check_point(x, y, 0.0)

    # 2) Intersections with one resource constraint and two variables set to 0

    # Batter constraint with two zeros
    # x = 0, y = 0 -> 450z = 20000
    check_point(0.0, 0.0, 20000.0 / 450.0)
    # x = 0, z = 0 -> 500y = 20000
    check_point(0.0, 20000.0 / 500.0, 0.0)
    # y = 0, z = 0 -> 400x = 20000
    check_point(20000.0 / 400.0, 0.0, 0.0)

    # Milk constraint with two zeros
    # x = 0, y = 0 -> 350z = 14000
    check_point(0.0, 0.0, 14000.0 / 350.0)
    # x = 0, z = 0 -> 300y = 14000
    check_point(0.0, 14000.0 / 300.0, 0.0)
    # y = 0, z = 0 -> 200x = 14000
    check_point(14000.0 / 200.0, 0.0, 0.0)

    # 3) Origin (all zero)
    check_point(0.0, 0.0, 0.0)

    return float(best_val)
```",648.0,True,0.0,0.0,5.937276363372803,
38,300.0,"```python
def solve():
    # We interpret the problem as:
    # Minimize total effectiveness time: 0.7*C + 0.9*L
    # Subject to:
    #   C >= 300
    #   C <= 550
    #   L <= 550
    #   C <= 3L   (at most thrice the amount of coconut oil as lavender)
    #   C, L >= 0
    #
    # This is a 2-variable linear program. We'll solve it by enumerating
    # all candidate corner points formed by intersecting the constraint lines.
    
    import math

    # Helper to check feasibility of a point
    def feasible(C, L):
        eps = 1e-9
        if C < -eps or L < -eps:
            return False
        if C + eps < 300:
            return False
        if C - eps > 550:
            return False
        if L - eps > 550:
            return False
        if C - 3*L > eps:
            return False
        return True

    # List of candidate points from intersections of boundary lines:
    candidates = []

    # 1) C = 300 with other bounds
    C = 300.0
    # L from C <= 3L => L >= C/3
    L1 = C / 3.0
    # Also L <= 550
    if feasible(C, L1):
        candidates.append((C, L1))
    # Also try L = 0 and L = 550 explicitly
    if feasible(C, 0.0):
        candidates.append((C, 0.0))
    if feasible(C, 550.0):
        candidates.append((C, 550.0))

    # 2) C = 550 with other bounds
    C = 550.0
    # From C <= 3L => L >= C/3
    L2 = C / 3.0
    if feasible(C, L2):
        candidates.append((C, L2))
    if feasible(C, 0.0):
        candidates.append((C, 0.0))
    if feasible(C, 550.0):
        candidates.append((C, 550.0))

    # 3) L = 0 with other bounds
    L = 0.0
    # C must satisfy: 300 <= C <= 550 and C <= 3*0 => C <= 0
    # So no feasible point here except possibly C=0, but that violates C>=300.
    # So nothing to add.

    # 4) L = 550 with other bounds
    L = 550.0
    # C must satisfy: 300 <= C <= 550 and C <= 3*550
    for C in [300.0, 550.0]:
        if feasible(C, L):
            candidates.append((C, L))

    # 5) Intersection of C = 3L with other bounds
    # With C = 3L and C >= 300 => 3L >= 300 => L >= 100
    # With C = 3L and C <= 550 => 3L <= 550 => L <= 550/3
    # With L <= 550 (automatically satisfied if L <= 550/3)
    # So L in [100, 550/3]
    # Endpoints:
    L_low = 100.0
    C_low = 3.0 * L_low
    if feasible(C_low, L_low):
        candidates.append((C_low, L_low))

    L_high = 550.0 / 3.0
    C_high = 3.0 * L_high
    if feasible(C_high, L_high):
        candidates.append((C_high, L_high))

    # Remove duplicates (within numerical tolerance)
    unique = []
    for C, L in candidates:
        if not any(abs(C - C2) < 1e-8 and abs(L - L2) < 1e-8 for C2, L2 in unique):
            unique.append((C, L))

    # Evaluate objective at all feasible unique candidates
    best_val = math.inf
    for C, L in unique:
        if feasible(C, L):
            val = 0.7 * C + 0.9 * L
            if val < best_val:
                best_val = val

    return float(best_val)
```",300.0,True,0.0,0.0,4.918780088424683,
39,8.0,"```python
def solve():
    # We model:
    # x = number of dual machines (integer, >= 0)
    # y = number of single machines (integer, >= 0)
    #
    # Constraints:
    # 1) 50x + 30y >= 300        (letters per minute)
    # 2) 20x + 15y <= 135        (glue units per minute)
    # 3) y > x  ->  y >= x + 1
    #
    # Objective: minimize x + y (total machines)
    #
    # Since the numbers are small, we can brute-force over a reasonable range.

    best_value = None

    # Upper bounds: from glue constraint, 20x + 15y <= 135
    # Max x if y=0: 20x <= 135 -> x <= 6.75 -> x <= 6
    # Max y if x=0: 15y <= 135 -> y <= 9
    # We'll search a bit beyond to be safe, but small.
    for x in range(0, 20):
        for y in range(0, 20):
            # Enforce constraints
            if 50 * x + 30 * y < 300:
                continue
            if 20 * x + 15 * y > 135:
                continue
            if y <= x:
                continue

            total = x + y
            if best_value is None or total < best_value:
                best_value = total

    # Return the minimal total number of machines as a float
    return float(best_value)
```",8.0,True,0.0,0.0,2.371067523956299,
40,142.0,"```python
def solve():
    # Let v = number of vintage bottles
    #     r = number of regular bottles
    #
    # Maximize: Z = v + r
    # Subject to:
    #   500v + 750r <= 100000
    #   r >= 4v
    #   v >= 10
    #   v, r >= 0
    #
    # We can reason analytically:
    # From r >= 4v, to maximize v + r under the volume constraint,
    # we should use the minimum r allowed for each v, i.e., r = 4v.
    #
    # Substitute r = 4v into the volume constraint:
    #   500v + 750(4v) <= 100000
    #   500v + 3000v <= 100000
    #   3500v <= 100000
    #   v <= 100000 / 3500 = 200/7 â‰ˆ 28.5714
    #
    # Also v >= 10, so feasible v is in [10, 200/7].
    # Objective with r = 4v: Z = v + 4v = 5v, which increases with v.
    # Thus optimal v is the largest feasible v: v* = 200/7.
    # Then r* = 4v* = 800/7.
    #
    # The maximum number of bottles:
    #   Z* = v* + r* = 200/7 + 800/7 = 1000/7.
    #
    # Return the optimal objective value as float.
    return 1000.0 / 7.0
```",142.85714285714286,False,0.8571428571428612,0.006036217303780458,2.8510310649871826,
41,540.0,"```python
def solve():
    # We solve the LP:
    # Maximize 10x + 15y
    # subject to:
    # 46x + 13y <= 1345   (A)
    # 43x +  4y <=  346   (B)
    # 56x + 45y <= 1643   (C)
    # x >= 0, y >= 0
    #
    # We'll solve by enumerating all corner points formed by intersections
    # of constraint lines and axes, then pick the feasible one with max profit.

    def intersect(a1, b1, c1, a2, b2, c2):
        # Solve:
        # a1 x + b1 y = c1
        # a2 x + b2 y = c2
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-12:
            return None  # parallel or nearly so
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)

    # Constraints in equality form for intersections:
    # A: 46x + 13y = 1345
    # B: 43x +  4y =  346
    # C: 56x + 45y = 1643

    candidates = []

    # Intersections of pairs of constraints
    A = (46.0, 13.0, 1345.0)
    B = (43.0, 4.0, 346.0)
    C = (56.0, 45.0, 1643.0)

    for (p, q) in [(A, B), (A, C), (B, C)]:
        pt = intersect(*p, *q)
        if pt is not None:
            candidates.append(pt)

    # Intersections with axes (x=0 or y=0) for each constraint
    # For x = 0: b y = c -> y = c / b
    # For y = 0: a x = c -> x = c / a
    for (a, b, c) in [A, B, C]:
        if abs(b) > 1e-12:
            candidates.append((0.0, c / b))
        if abs(a) > 1e-12:
            candidates.append((c / a, 0.0))

    # Also include origin
    candidates.append((0.0, 0.0))

    def feasible(x, y):
        if x < -1e-9 or y < -1e-9:
            return False
        if 46 * x + 13 * y - 1345 > 1e-9:
            return False
        if 43 * x + 4 * y - 346 > 1e-9:
            return False
        if 56 * x + 45 * y - 1643 > 1e-9:
            return False
        return True

    best_val = float(""-inf"")
    for (x, y) in candidates:
        if feasible(x, y):
            val = 10 * x + 15 * y
            if val > best_val:
                best_val = val

    return float(best_val)
```",547.6666666666667,False,7.6666666666667425,0.01419753086417138,3.7919812202453613,
42,17000.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 30x + 40y
    # Subject to:
    #   x + y <= 500        (land)
    #   20x + 15y <= 9000   (fuel)
    #   10x + 15y <= 6000   (waste)
    #   x >= 0, y >= 0
    
    # We'll do this by enumerating all corner points formed by intersections
    # of the constraint lines and checking feasibility and objective value.
    
    best_value = 0.0
    
    def is_feasible(x, y):
        if x < 0 or y < 0:
            return False
        if x + y > 500 + 1e-9:
            return False
        if 20*x + 15*y > 9000 + 1e-9:
            return False
        if 10*x + 15*y > 6000 + 1e-9:
            return False
        return True
    
    def update_best(x, y):
        nonlocal best_value
        if is_feasible(x, y):
            val = 30*x + 40*y
            if val > best_value:
                best_value = val
    
    # Candidate points come from intersections of:
    # x=0, y=0, x+y=500, 20x+15y=9000, 10x+15y=6000
    
    # 1) Axes intersections
    update_best(0.0, 0.0)
    
    # x=0 with other constraints
    # x=0, x+y=500 -> y=500
    update_best(0.0, 500.0)
    # x=0, 20x+15y=9000 -> y=9000/15
    update_best(0.0, 9000.0/15.0)
    # x=0, 10x+15y=6000 -> y=6000/15
    update_best(0.0, 6000.0/15.0)
    
    # y=0 with other constraints
    # y=0, x+y=500 -> x=500
    update_best(500.0, 0.0)
    # y=0, 20x+15y=9000 -> x=9000/20
    update_best(9000.0/20.0, 0.0)
    # y=0, 10x+15y=6000 -> x=6000/10
    update_best(6000.0/10.0, 0.0)
    
    # 2) Intersections of pairs of non-axis constraints
    
    # x + y = 500 and 20x + 15y = 9000
    # From x = 500 - y:
    # 20(500 - y) + 15y = 9000
    # 10000 - 20y + 15y = 9000
    # 10000 - 5y = 9000 -> 5y = 1000 -> y = 200, x = 300
    update_best(300.0, 200.0)
    
    # x + y = 500 and 10x + 15y = 6000
    # x = 500 - y:
    # 10(500 - y) + 15y = 6000
    # 5000 - 10y + 15y = 6000
    # 5000 + 5y = 6000 -> 5y = 1000 -> y = 200, x = 300
    update_best(300.0, 200.0)  # same point
    
    # 20x + 15y = 9000 and 10x + 15y = 6000
    # Subtract second from first:
    # (20x - 10x) + (15y - 15y) = 9000 - 6000 -> 10x = 3000 -> x = 300
    # Then 10*300 + 15y = 6000 -> 3000 + 15y = 6000 -> 15y = 3000 -> y = 200
    update_best(300.0, 200.0)  # same point again
    
    return float(best_value)
```",17000.0,True,0.0,0.0,4.5092737674713135,
43,990.0,"```python
def solve():
    # We want to minimize total number of light changes:
    # Let x = number of LED fixtures
    #     y = number of fluorescence lamps
    #
    # Objective: minimize 3x + 4y
    #
    # Constraints:
    # 1) x + y >= 300          (at least 300 fixtures)
    # 2) 5x + 8y <= 2000       (electricity limit)
    # 3) y >= 0.3(x + y)       (at least 30% fluorescence)
    #    => y >= 0.3x + 0.3y
    #    => 0.7y >= 0.3x
    #    => 7y >= 3x
    #    => x <= (7/3) y
    # 4) x, y >= 0
    #
    # This is a 2-variable LP; we can solve it by enumerating all corner points
    # formed by intersections of the constraint boundaries and checking feasibility.
    #
    # We'll treat x, y as real (not necessarily integer), as the problem is a standard LP.

    import math

    best_val = float('inf')

    # Helper to check feasibility and update best objective
    def check_point(x, y):
        nonlocal best_val
        # Feasibility checks with small tolerance
        eps = 1e-9
        if x < -eps or y < -eps:
            return
        if x + y < 300 - eps:
            return
        if 5 * x + 8 * y > 2000 + eps:
            return
        if 7 * y + eps < 3 * x:  # 7y >= 3x
            return
        val = 3 * x + 4 * y
        if val < best_val:
            best_val = val

    # List of candidate intersection points from pairs of constraint boundaries:
    # We'll solve each pair analytically.

    # 1) x + y = 300 and 5x + 8y = 2000
    #    From x = 300 - y:
    #    5(300 - y) + 8y = 2000 => 1500 - 5y + 8y = 2000 => 3y = 500 => y = 500/3
    #    x = 300 - 500/3 = 400/3
    x = 400.0 / 3.0
    y = 500.0 / 3.0
    check_point(x, y)

    # 2) x + y = 300 and x = (7/3) y  (from 7y = 3x)
    #    Substitute: (7/3)y + y = 300 => (10/3)y = 300 => y = 90, x = 210
    x = 210.0
    y = 90.0
    check_point(x, y)

    # 3) 5x + 8y = 2000 and x = (7/3) y
    #    5*(7/3 y) + 8y = 2000 => (35/3)y + 8y = 2000
    #    (35/3 + 24/3)y = 2000 => (59/3)y = 2000 => y = 6000/59, x = (7/3)*y
    y = 6000.0 / 59.0
    x = (7.0 / 3.0) * y
    check_point(x, y)

    # 4) Intersections with axes and single constraints:

    # a) On y-axis: x = 0
    #    Constraints: y >= 300, 8y <= 2000 => y <= 250, and 7y >= 0 (always)
    #    No feasible point since y must be >=300 and <=250 simultaneously.
    # So no candidate here.

    # b) On x-axis: y = 0
    #    Constraints: x >= 300, 5x <= 2000 => x <= 400, and 7*0 >= 3x => x <= 0
    #    No feasible point (x must be <=0 and >=300).
    # So no candidate here.

    # c) Intersection of x + y = 300 with axes already covered (x=300,y=0) and (x=0,y=300),
    #    but both violate other constraints, so we can still check explicitly:

    check_point(300.0, 0.0)
    check_point(0.0, 300.0)

    # d) Intersection of 5x + 8y = 2000 with axes:
    #    x=0 => y=250
    #    y=0 => x=400
    check_point(0.0, 250.0)
    check_point(400.0, 0.0)

    # e) Intersection of x = (7/3)y with axes:
    #    y=0 => x=0
    check_point(0.0, 0.0)

    # The optimal value is stored in best_val
    return float(best_val)
```",990.0,True,0.0,0.0,5.220527410507202,
44,-99999.0,"```python
def solve():
    # We solve the LP:
    # Maximize 100x + 225y
    # s.t.
    #   30x + 70y >= 1200      (transport)
    #   4x + 15y < 200         (pollution; treat as <= 200 for LP optimum)
    #   x <= (1/3) y           (motorcycle fraction <= 25% => x <= y/3)
    #   x, y >= 0
    
    # Since this is a 2-variable LP, we can solve by checking all corner points
    # formed by intersections of the constraint boundaries.
    # We'll treat the strict inequality as <= 200; the optimum will lie on or
    # below that boundary, and strictness does not change the maximum value.
    
    import math
    
    def feasible(x, y):
        # Check feasibility with a small tolerance
        if x < -1e-9 or y < -1e-9:
            return False
        if 30*x + 70*y < 1200 - 1e-9:
            return False
        if 4*x + 15*y > 200 + 1e-9:
            return False
        if x - y/3 > 1e-9:
            return False
        return True
    
    def objective(x, y):
        return 100*x + 225*y
    
    points = []
    
    # Intersections of pairs of constraints (as equalities):
    # 1) 30x + 70y = 1200
    # 2) 4x + 15y = 200
    # 3) x = y/3
    # 4) x = 0
    # 5) y = 0
    
    # Helper to solve 2x2 linear systems: a1 x + b1 y = c1, a2 x + b2 y = c2
    def solve_two(a1, b1, c1, a2, b2, c2):
        det = a1*b2 - a2*b1
        if abs(det) < 1e-12:
            return None
        x = (c1*b2 - c2*b1) / det
        y = (a1*c2 - a2*c1) / det
        return (x, y)
    
    # (1) & (2)
    sol = solve_two(30, 70, 1200, 4, 15, 200)
    if sol is not None:
        points.append(sol)
    
    # (1) & (3): 30x + 70y = 1200, x = y/3
    # Substitute x = y/3:
    # 30*(y/3) + 70y = 1200 => 10y + 70y = 1200 => 80y = 1200 => y = 15, x = 5
    points.append((5.0, 15.0))
    
    # (1) & (4): 30*0 + 70y = 1200 => y = 1200/70
    points.append((0.0, 1200.0/70.0))
    
    # (1) & (5): 30x + 70*0 = 1200 => x = 40
    points.append((40.0, 0.0))
    
    # (2) & (3): 4x + 15y = 200, x = y/3
    # 4*(y/3) + 15y = 200 => (4/3 + 15)y = 200 => (49/3)y = 200 => y = 600/49, x = 200/49
    y = 600.0/49.0
    x = 200.0/49.0
    points.append((x, y))
    
    # (2) & (4): 4*0 + 15y = 200 => y = 200/15
    points.append((0.0, 200.0/15.0))
    
    # (2) & (5): 4x + 15*0 = 200 => x = 50
    points.append((50.0, 0.0))
    
    # (3) & (4): x = 0, x = y/3 => y = 0
    points.append((0.0, 0.0))
    
    # (3) & (5): y = 0, x = y/3 => x = 0
    points.append((0.0, 0.0))  # already included
    
    # Also consider intersections with nonnegativity and single constraints:
    # For example, along x=0 or y=0 with each inequality as equality is already covered.
    
    best_val = -math.inf
    for (x, y) in points:
        if feasible(x, y):
            val = objective(x, y)
            if val > best_val:
                best_val = val
    
    # In case the optimum lies not exactly at an intersection due to strictness,
    # best_val is still the LP optimum; strict inequality can be approached arbitrarily.
    return float(best_val)
```",-inf,False,inf,inf,5.840914249420166,
45,960.0,"```python
def solve():
    # Let x = kg of first mix, y = kg of second mix
    # Constraints from ingredients:
    # Cat paw: 0.2x + 0.35y <= 20
    # Gold shark: 0.8x + 0.65y <= 50
    # x >= 0, y >= 0
    # Objective: maximize 12x + 15y

    # We'll solve this small LP analytically by checking corner points.

    best_value = 0.0

    # Corner 1: x = 0
    # Then constraints reduce to:
    # 0.35y <= 20  -> y <= 20 / 0.35
    # 0.65y <= 50  -> y <= 50 / 0.65
    y1 = min(20.0 / 0.35, 50.0 / 0.65)
    if y1 >= 0:
        val = 12.0 * 0.0 + 15.0 * y1
        if val > best_value:
            best_value = val

    # Corner 2: y = 0
    # Then constraints reduce to:
    # 0.2x <= 20  -> x <= 20 / 0.2
    # 0.8x <= 50  -> x <= 50 / 0.8
    x2 = min(20.0 / 0.2, 50.0 / 0.8)
    if x2 >= 0:
        val = 12.0 * x2 + 15.0 * 0.0
        if val > best_value:
            best_value = val

    # Corner 3: intersection of the two ingredient constraints
    # Solve:
    # 0.2x + 0.35y = 20
    # 0.8x + 0.65y = 50

    # Solve the system using basic algebra
    # Multiply first eqn by 4: 0.8x + 1.4y = 80
    # Subtract second eqn: (0.8x + 1.4y) - (0.8x + 0.65y) = 80 - 50
    # 0.75y = 30 -> y = 40
    y3 = 40.0
    # Plug back into first equation: 0.2x + 0.35*40 = 20
    # 0.2x + 14 = 20 -> 0.2x = 6 -> x = 30
    x3 = 30.0

    # Check feasibility (should be feasible by construction)
    if x3 >= 0 and y3 >= 0:
        # Check constraints numerically for safety
        if 0.2 * x3 + 0.35 * y3 <= 20.0000001 and 0.8 * x3 + 0.65 * y3 <= 50.0000001:
            val = 12.0 * x3 + 15.0 * y3
            if val > best_value:
                best_value = val

    return float(best_value)
```",960.0,True,0.0,0.0,3.5854170322418213,
46,290.5,"```python
def solve():
    # We solve the LP:
    # Maximize 4x + 2.5y
    # subject to:
    #   3x + 1.5y <= 350   (printing)
    #   5.5x + 3y <= 350   (scanning)
    #   x >= 0, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) Intersection with axes:
    #    a) x = 0:
    #       1.5y <= 350 -> y <= 350/1.5
    #       3y <= 350   -> y <= 350/3
    #       So y = min(350/1.5, 350/3)
    y_x0 = min(350.0 / 1.5, 350.0 / 3.0)
    x0_y = 0.0
    profit_x0 = 4.0 * x0_y + 2.5 * y_x0

    #    b) y = 0:
    #       3x <= 350   -> x <= 350/3
    #       5.5x <= 350 -> x <= 350/5.5
    #       So x = min(350/3, 350/5.5)
    x_y0 = min(350.0 / 3.0, 350.0 / 5.5)
    y0_x = 0.0
    profit_y0 = 4.0 * x_y0 + 2.5 * y0_x

    # 2) Intersection of the two machine constraints:
    #    3x + 1.5y = 350
    #    5.5x + 3y = 350
    #
    # Solve the system:
    # From first: 1.5y = 350 - 3x -> y = (350 - 3x)/1.5
    # Substitute into second:
    # 5.5x + 3 * (350 - 3x)/1.5 = 350
    # We'll solve directly using linear algebra formulas:
    # a1 x + b1 y = c1
    # a2 x + b2 y = c2
    a1, b1, c1 = 3.0, 1.5, 350.0
    a2, b2, c2 = 5.5, 3.0, 350.0
    det = a1 * b2 - a2 * b1
    if det != 0:
        x_int = (c1 * b2 - c2 * b1) / det
        y_int = (a1 * c2 - a2 * c1) / det
        # Check feasibility (nonnegative and within constraints, allowing small tolerance)
        if x_int >= -1e-9 and y_int >= -1e-9:
            # Clip tiny negatives to zero
            x_int = max(0.0, x_int)
            y_int = max(0.0, y_int)
            # Check constraints
            if (3.0 * x_int + 1.5 * y_int <= 350.0 + 1e-6 and
                5.5 * x_int + 3.0 * y_int <= 350.0 + 1e-6):
                profit_int = 4.0 * x_int + 2.5 * y_int
            else:
                profit_int = float('-inf')
        else:
            profit_int = float('-inf')
    else:
        profit_int = float('-inf')

    # Also consider the origin (0,0)
    profit_origin = 0.0

    # Maximum profit among all candidate corner points
    max_profit = max(profit_x0, profit_y0, profit_int, profit_origin)
    return float(max_profit)
```",291.6666666666667,False,1.1666666666666856,0.004016064257014353,4.302685499191284,
47,4190.0,"```python
def solve():
    # We maximize 50x + 80y
    # Subject to:
    # 1) x >= 2y
    # 2) x <= 70
    # 3) 15 <= y <= 50
    # 4) x + y <= 70
    # 5) x, y >= 0 and integers
    
    best_value = float('-inf')
    
    # y is between 15 and 50 inclusive
    for y in range(15, 51):
        # x must satisfy:
        # x >= 2y
        # x <= 70
        # x + y <= 70  -> x <= 70 - y
        x_min = 2 * y
        x_max = min(70, 70 - y)
        
        if x_min > x_max:
            continue  # no feasible x for this y
        
        # Since objective is increasing in x (50 per unit),
        # choose the largest feasible x
        x = x_max
        
        value = 50 * x + 80 * y
        if value > best_value:
            best_value = value
    
    return float(best_value)
```",4190.0,True,0.0,0.0,1.6863720417022705,
48,5.851851851851852,"```python
def solve():
    # We solve the LP:
    # Minimize: 2x + 3y
    # Subject to:
    #   1.5x + 5y >= 5   (nitrous oxide)
    #   3x   + 1y >= 8   (vitamin mix)
    #   x >= 0, y >= 0

    # The optimum for a 2-variable LP with linear constraints occurs at a corner point.
    # Candidate corner points come from intersections of constraint lines and axes.

    candidates = []

    # 1) Intersection of the two constraint lines:
    #   1.5x + 5y = 5
    #   3x   + 1y = 8
    # Solve this system:
    # From second: y = 8 - 3x
    # Substitute into first:
    #   1.5x + 5(8 - 3x) = 5
    #   1.5x + 40 - 15x = 5
    #   -13.5x = -35
    #   x = 35 / 13.5
    x = 35.0 / 13.5
    y = 8.0 - 3.0 * x
    if x >= 0 and y >= 0:
        candidates.append((x, y))

    # 2) Intersection of each constraint with x = 0 (y-axis), if feasible:
    # For 1.5x + 5y >= 5 with x = 0: 5y >= 5 -> y >= 1
    # For 3x + y >= 8 with x = 0: y >= 8
    # So the tightest is y = 8 (satisfies both).
    x, y = 0.0, 8.0
    candidates.append((x, y))

    # 3) Intersection of each constraint with y = 0 (x-axis), if feasible:
    # For 1.5x + 5y >= 5 with y = 0: 1.5x >= 5 -> x >= 10/3
    # For 3x + y >= 8 with y = 0: 3x >= 8 -> x >= 8/3
    # The tightest is x = 10/3 (satisfies both).
    x, y = 10.0 / 3.0, 0.0
    candidates.append((x, y))

    # Evaluate objective 2x + 3y at all candidate points and take the minimum.
    best_value = float('inf')
    for x, y in candidates:
        cost = 2.0 * x + 3.0 * y
        if cost < best_value:
            best_value = cost

    return best_value
```",5.851851851851852,True,0.0,0.0,3.2318053245544434,
49,3.0,"```python
def solve():
    # We solve the LP:
    # Minimize:  C = 1*x + 2*y
    # Subject to:
    #   40x + 15y >= 100  (calcium)
    #   25x + 30y >= 50   (iron)
    #   x, y >= 0
    
    # The optimal solution for a 2-variable LP with linear constraints
    # will occur at a corner (intersection of constraint lines or axes).
    # We compute candidate corner points and choose the feasible one
    # with minimum cost.
    
    candidates = []
    
    # 1) Intersection of the two constraint lines:
    #    40x + 15y = 100
    #    25x + 30y = 50
    # Solve this 2x2 system.
    # From the first: 40x = 100 - 15y -> x = (100 - 15y)/40
    # Substitute into second:
    # 25*(100 - 15y)/40 + 30y = 50
    # Multiply both sides by 40:
    # 25*(100 - 15y) + 1200y = 2000
    # 2500 - 375y + 1200y = 2000
    # 2500 + 825y = 2000
    # 825y = -500
    # y = -500/825 (negative, so infeasible)
    y = -500.0 / 825.0
    x = (100.0 - 15.0 * y) / 40.0
    # Check feasibility
    if x >= 0 and y >= 0 and 40*x + 15*y >= 100 - 1e-9 and 25*x + 30*y >= 50 - 1e-9:
        candidates.append((x, y))
    
    # 2) Intersection with x-axis (y = 0):
    # Calcium: 40x >= 100 -> x >= 2.5
    # Iron:    25x >= 50  -> x >= 2
    # So minimum feasible x is 2.5
    x = 2.5
    y = 0.0
    if 40*x + 15*y >= 100 - 1e-9 and 25*x + 30*y >= 50 - 1e-9:
        candidates.append((x, y))
    
    # 3) Intersection with y-axis (x = 0):
    # Calcium: 15y >= 100 -> y >= 100/15
    # Iron:    30y >= 50  -> y >= 50/30
    # So minimum feasible y is 100/15
    x = 0.0
    y = 100.0 / 15.0
    if 40*x + 15*y >= 100 - 1e-9 and 25*x + 30*y >= 50 - 1e-9:
        candidates.append((x, y))
    
    # Evaluate objective at all candidates and return minimum cost
    best_cost = float('inf')
    for x, y in candidates:
        cost = x + 2.0 * y
        if cost < best_cost:
            best_cost = cost
    
    return best_cost
```",2.5,False,0.5,0.1666666666111111,4.787190198898315,
50,14375.0,"```python
def solve():
    # We solve the LP:
    # Maximize 56x + 75y
    # subject to:
    #   x + y <= 300        (land)
    #   6x + 3y <= 575      (labor)
    #   22x + 25y <= 10000  (water)
    #   x >= 0, y >= 0
    
    # We'll solve by checking all corner points of the feasible region.
    # Constraints in standard form:
    # C1: x + y <= 300
    # C2: 6x + 3y <= 575
    # C3: 22x + 25y <= 10000
    # C4: x >= 0
    # C5: y >= 0
    
    # Helper to compute objective
    def objective(x, y):
        return 56 * x + 75 * y

    # List to store candidate points
    points = []

    # Intersections with axes:
    # y = 0:
    #   From C1: x <= 300
    #   From C2: 6x <= 575 -> x <= 575/6
    #   From C3: 22x <= 10000 -> x <= 10000/22
    x_max_y0 = min(300, 575.0/6.0, 10000.0/22.0)
    if x_max_y0 >= 0:
        points.append((x_max_y0, 0.0))

    # x = 0:
    #   From C1: y <= 300
    #   From C2: 3y <= 575 -> y <= 575/3
    #   From C3: 25y <= 10000 -> y <= 10000/25
    y_max_x0 = min(300, 575.0/3.0, 10000.0/25.0)
    if y_max_x0 >= 0:
        points.append((0.0, y_max_x0))

    # Intersection C1 & C2:
    # x + y = 300
    # 6x + 3y = 575
    # From first: y = 300 - x
    # Substitute: 6x + 3(300 - x) = 575 -> 6x + 900 - 3x = 575 -> 3x = -325 -> x = -325/3 (infeasible)
    # So no feasible intersection here.

    # Intersection C1 & C3:
    # x + y = 300
    # 22x + 25y = 10000
    # y = 300 - x
    # 22x + 25(300 - x) = 10000
    # 22x + 7500 - 25x = 10000
    # -3x = 2500 -> x = -2500/3 (infeasible)
    # So no feasible intersection here.

    # Intersection C2 & C3:
    # 6x + 3y = 575
    # 22x + 25y = 10000
    # Solve:
    # From first: 3y = 575 - 6x -> y = (575 - 6x)/3
    # Substitute into second:
    # 22x + 25*(575 - 6x)/3 = 10000
    # Multiply by 3:
    # 66x + 25*(575 - 6x) = 30000
    # 66x + 14375 - 150x = 30000
    # -84x = 15625
    # x = -15625/84 (infeasible)
    # So no feasible intersection here.

    # Intersection with non-negativity and each constraint individually:
    # Already considered x-axis and y-axis intersections.
    # Also consider the origin (0,0)
    points.append((0.0, 0.0))

    # Now filter points that satisfy all constraints
    feasible_points = []
    for x, y in points:
        if x < 0 or y < 0:
            continue
        if x + y > 300 + 1e-9:
            continue
        if 6*x + 3*y > 575 + 1e-9:
            continue
        if 22*x + 25*y > 10000 + 1e-9:
            continue
        feasible_points.append((x, y))

    # If no feasible points found (should not happen here), return 0
    if not feasible_points:
        return 0.0

    # Compute maximum objective over feasible points
    best_value = None
    for x, y in feasible_points:
        val = objective(x, y)
        if best_value is None or val > best_value:
            best_value = val

    return float(best_value)
```",14375.0,True,0.0,0.0,7.033827781677246,
51,25.0,"```python
def solve():
    # We solve the LP:
    # Minimize: x + y
    # Subject to:
    # 1) 10000x + 5000y >= 150000
    # 2) 12x + 5y <= 160
    # 3) x <= 0.35(x + y)  ->  0.65x <= 0.35y  -> 13x <= 7y
    # 4) y >= 8
    # 5) x >= 0, y >= 0
    #
    # We'll solve it analytically and return the optimal objective value.
    #
    # From constraints:
    # (1) 10000x + 5000y >= 150000  ->  2x + y >= 30
    # (2) 12x + 5y <= 160
    # (3) 13x <= 7y
    # (4) y >= 8
    #
    # The feasible region is a polygon; the optimum of a linear program lies at a vertex.
    # We find candidate vertices by intersecting boundary lines and checking feasibility.

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 2 * x + y < 30 - 1e-9:  # demand
            return False
        if 12 * x + 5 * y > 160 + 1e-9:  # technicians
            return False
        if 13 * x > 7 * y + 1e-9:  # high-volume proportion
            return False
        if y < 8 - 1e-9:  # minimum low-volume pipes
            return False
        return True

    candidates = []

    # 1) Intersection of demand (2x + y = 30) and technicians (12x + 5y = 160)
    # Solve:
    # 2x + y = 30  -> y = 30 - 2x
    # 12x + 5(30 - 2x) = 160 -> 12x + 150 - 10x = 160 -> 2x = 10 -> x = 5, y = 20
    x1, y1 = 5.0, 20.0
    if feasible(x1, y1):
        candidates.append((x1, y1))

    # 2) Intersection of demand (2x + y = 30) and proportion (13x = 7y)
    # From 13x = 7y -> y = (13/7)x
    # 2x + (13/7)x = 30 -> (27/7)x = 30 -> x = 210/27 = 70/9, y = (13/7)*(70/9) = 130/9
    x2 = 70.0 / 9.0
    y2 = 130.0 / 9.0
    if feasible(x2, y2):
        candidates.append((x2, y2))

    # 3) Intersection of technicians (12x + 5y = 160) and proportion (13x = 7y)
    # y = (13/7)x
    # 12x + 5*(13/7)x = 160 -> (12 + 65/7)x = 160 -> (149/7)x = 160 -> x = 1120/149
    # y = (13/7)*x = 2080/149
    x3 = 1120.0 / 149.0
    y3 = 2080.0 / 149.0
    if feasible(x3, y3):
        candidates.append((x3, y3))

    # 4) Intersection of demand (2x + y = 30) and y = 8
    # 2x + 8 = 30 -> x = 11
    x4, y4 = 11.0, 8.0
    if feasible(x4, y4):
        candidates.append((x4, y4))

    # 5) Intersection of technicians (12x + 5y = 160) and y = 8
    # 12x + 40 = 160 -> x = 10
    x5, y5 = 10.0, 8.0
    if feasible(x5, y5):
        candidates.append((x5, y5))

    # 6) Intersection of proportion (13x = 7y) and y = 8
    # y = 8 -> x = 56/13
    x6, y6 = 56.0 / 13.0, 8.0
    if feasible(x6, y6):
        candidates.append((x6, y6))

    # Also consider potential boundary points where one constraint is tight and others are just satisfied.
    # For completeness, we can also scan along y >= 8 for intersections with constraints.
    # But the above cover all pairwise intersections of active constraints that can define vertices.

    if not candidates:
        return float('nan')

    # Objective: minimize x + y
    best_val = float('inf')
    for x, y in candidates:
        val = x + y
        if val < best_val:
            best_val = val

    return float(best_val)
```",25.0,True,0.0,0.0,5.274358510971069,
52,1000.0,"```python
def solve():
    # We solve the LP by enumerating feasible integer solutions for
    # number of liquid (L) and foam (F) sanitizers.
    #
    # Maximize: 30L + 20F
    # Subject to:
    #   40L + 60F <= 2000   (water)
    #   50L + 40F <= 2100   (alcohol)
    #   F > L               (foam exceeds liquid)
    #   L <= 30             (at most 30 liquid)
    #   L, F >= 0 and integers
    
    best_value = float('-inf')
    
    # L can be from 0 to 30
    for L in range(0, 31):
        # F must be at least L+1 (since F > L)
        F_min = L + 1
        
        # Upper bounds from constraints:
        # 40L + 60F <= 2000  -> 60F <= 2000 - 40L
        #                    -> F <= (2000 - 40L) / 60
        if 2000 - 40 * L < 0:
            continue
        F_max_water = (2000 - 40 * L) // 60
        
        # 50L + 40F <= 2100  -> 40F <= 2100 - 50L
        #                    -> F <= (2100 - 50L) / 40
        if 2100 - 50 * L < 0:
            continue
        F_max_alcohol = (2100 - 50 * L) // 40
        
        F_max = min(F_max_water, F_max_alcohol)
        
        if F_min > F_max:
            continue
        
        # Since objective is increasing in F (coefficient 20 > 0),
        # best F for this L is F_max.
        F = F_max
        
        value = 30 * L + 20 * F
        if value > best_value:
            best_value = value
    
    return float(best_value)
```",970.0,False,30.0,0.029999999999970002,3.089059829711914,
53,690.0,"```python
def solve():
    # Let x = number of calcium pills
    #     y = number of vitamin D pills
    #
    # Constraints:
    # 1) x + y >= 130
    # 2) y >= 40
    # 3) x > y  (strict, but we'll treat as x >= y + 1 for integers)
    # 4) x, y are integers and nonnegative
    #
    # Objective: minimize total time = 5x + 6y
    #
    # Because coefficients are positive, at optimum we'll have x + y = 130
    # (otherwise we could reduce both x and y while keeping constraints).
    #
    # So set x = 130 - y.
    # Then constraints become:
    # - y >= 40
    # - x > y  -> 130 - y > y -> 130 > 2y -> y < 65
    # - x, y >= 0 automatically satisfied in this range.
    #
    # So y is integer with 40 <= y <= 64.
    # Objective: 5(130 - y) + 6y = 650 - 5y + 6y = 650 + y
    # This is increasing in y, so minimize y.
    #
    # Thus y = 40, x = 90.
    # Minimum total time = 5*90 + 6*40 = 450 + 240 = 690.
    
    return float(690)
```",690.0,True,0.0,0.0,2.1127192974090576,
54,1680.0,"```python
def solve():
    # We want to maximize electricity:
    # Let x = number of alpha experiments
    #     y = number of beta experiments
    #
    # Maximize:  8x + 10y
    # Subject to:
    #   3x + 5y <= 800   (metal)
    #   5x + 4y <= 750   (acid)
    #   x >= 0, y >= 0
    #
    # This is a 2-variable linear program; the optimum lies at a corner (feasible vertex).
    # Candidate vertices come from intersections of constraint lines and axes.

    # 1) Intersection of the two constraints:
    #    3x + 5y = 800
    #    5x + 4y = 750
    #
    # Solve the system:
    # From first: 3x = 800 - 5y  => x = (800 - 5y)/3
    # Substitute into second:
    #   5*(800 - 5y)/3 + 4y = 750
    #   (4000 - 25y)/3 + 4y = 750
    #   4000 - 25y + 12y = 2250
    #   4000 - 13y = 2250
    #   13y = 1750
    #   y = 1750 / 13
    y_inter = 1750.0 / 13.0
    x_inter = (800.0 - 5.0 * y_inter) / 3.0

    # Check feasibility (should be feasible by construction)
    candidates = []

    # Intersection point
    if x_inter >= 0 and y_inter >= 0:
        candidates.append((x_inter, y_inter))

    # 2) Intersection with x-axis (y = 0):
    #    3x <= 800  => x <= 800/3
    #    5x <= 750  => x <= 150
    # So max feasible x on x-axis is min(800/3, 150)
    x_axis = min(800.0 / 3.0, 150.0)
    candidates.append((x_axis, 0.0))

    # 3) Intersection with y-axis (x = 0):
    #    5y <= 800  => y <= 160
    #    4y <= 750  => y <= 187.5
    # So max feasible y on y-axis is min(160, 187.5) = 160
    candidates.append((0.0, 160.0))

    # Evaluate objective 8x + 10y at all candidate points
    best_value = None
    for x, y in candidates:
        value = 8.0 * x + 10.0 * y
        if (best_value is None) or (value > best_value):
            best_value = value

    return best_value
```",1684.6153846153845,False,4.615384615384528,0.00274725274725106,3.3814384937286377,
55,25.0,"```python
def solve():
    # We want to minimize total number of lifts: x + y
    # x = number of densely-seated lifts
    # y = number of loosely-seated lifts
    #
    # Constraints:
    # 1) Capacity: 45x + 20y >= 1000
    # 2) Electricity: 30x + 22y <= 940
    # 3) At least 5 loosely-seated lifts: y >= 5
    # 4) x, y are nonnegative integers
    #
    # We'll brute-force over feasible integer values of y and compute the minimal x
    # that satisfies the constraints, then choose the combination with minimal x + y.

    best_value = None

    # Upper bounds: from electricity and capacity
    # From electricity: 30x + 22y <= 940 => x <= (940 - 22y)/30
    # From capacity:   45x + 20y >= 1000 => x >= (1000 - 20y)/45
    # Also x >= 0, y >= 5
    #
    # For y, electricity gives: 22y <= 940 => y <= 42 (since 22*42 = 924, 22*43 = 946 > 940)
    # Capacity alone doesn't give an upper bound on y (more y only helps).
    # So we can safely search y from 5 to 42.

    for y in range(5, 43):
        # Compute minimal x satisfying capacity
        # 45x + 20y >= 1000 => x >= (1000 - 20y)/45
        min_x_capacity = (1000 - 20 * y) / 45.0
        # x must be at least this, and integer, and nonnegative
        if min_x_capacity < 0:
            x_start = 0
        else:
            # ceiling of min_x_capacity
            x_start = int(min_x_capacity)
            if x_start < min_x_capacity:
                x_start += 1

        # Now increase x from x_start until electricity constraint is violated
        # or we find a feasible x.
        # Electricity: 30x + 22y <= 940 => x <= (940 - 22y)/30
        max_x_electricity = (940 - 22 * y) / 30.0
        if max_x_electricity < 0:
            # No feasible x for this y
            continue

        # x must be <= floor(max_x_electricity)
        x_end = int(max_x_electricity)

        if x_start > x_end:
            # No feasible integer x for this y
            continue

        # The smallest feasible x is x_start
        x = x_start

        # Check feasibility (should be feasible by construction, but we verify)
        if 45 * x + 20 * y >= 1000 and 30 * x + 22 * y <= 940:
            total_lifts = x + y
            if best_value is None or total_lifts < best_value:
                best_value = total_lifts

    # Return the optimal objective value (minimal total number of lifts) as float
    return float(best_value)
```",25.0,True,0.0,0.0,3.789985179901123,
56,7.0,"```python
def solve():
    # We need to minimize total printers: x + y
    # x = number of premium printers
    # y = number of regular printers
    #
    # Constraints:
    # 1) 30x + 20y >= 200   (pages per minute)
    # 2) 4x + 3y <= 35      (ink units per minute)
    # 3) y < x              (regular less than premium)
    # 4) x, y are nonnegative integers
    #
    # We'll brute force over a reasonable range of x and y.
    # Upper bounds: from ink constraint, 4x + 3y <= 35
    # implies x <= 35/4 < 9, y <= 35/3 < 12, so we can search x in [0, 9], y in [0, 12].

    best_value = None

    for x in range(0, 10):      # 0..9
        for y in range(0, 13):  # 0..12
            # Check constraints
            if 30 * x + 20 * y < 200:
                continue
            if 4 * x + 3 * y > 35:
                continue
            if not (y < x):
                continue

            total = x + y
            if best_value is None or total < best_value:
                best_value = total

    # Return the optimal objective value (minimum total number of printers)
    # as a float, per the requirement.
    return float(best_value if best_value is not None else 0.0)
```",7.0,True,0.0,0.0,2.2523014545440674,
57,85500.0,"```python
def solve():
    # We need to solve the LP:
    # Maximize: 30x + 180y
    # Subject to:
    #   200x + 447y <= 250000   (budget)
    #   x + y <= 475           (sales limit)
    #   x >= 0, y >= 0
    #
    # We'll solve by enumerating corner points of the feasible region.

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 200 * x + 447 * y > 250000 + 1e-9:
            return False
        if x + y > 475 + 1e-9:
            return False
        return True

    # List of candidate corner points:
    candidates = []

    # 1) Intersections with axes from each constraint

    # From budget with y = 0: 200x = 250000 -> x = 1250
    x = 250000 / 200.0
    y = 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # From budget with x = 0: 447y = 250000 -> y = 250000/447
    x = 0.0
    y = 250000 / 447.0
    if feasible(x, y):
        candidates.append((x, y))

    # From sales limit with y = 0: x = 475
    x = 475.0
    y = 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # From sales limit with x = 0: y = 475
    x = 0.0
    y = 475.0
    if feasible(x, y):
        candidates.append((x, y))

    # 2) Intersection of budget and sales limit:
    #   200x + 447y = 250000
    #   x + y = 475 -> x = 475 - y
    # Substitute:
    #   200(475 - y) + 447y = 250000
    #   95000 - 200y + 447y = 250000
    #   95000 + 247y = 250000
    #   247y = 155000
    #   y = 155000 / 247
    y = 155000.0 / 247.0
    x = 475.0 - y
    if feasible(x, y):
        candidates.append((x, y))

    # 3) Origin (0,0) is also a corner
    if feasible(0.0, 0.0):
        candidates.append((0.0, 0.0))

    # Evaluate objective at all candidates
    best_value = float('-inf')
    for x, y in candidates:
        value = 30.0 * x + 180.0 * y
        if value > best_value:
            best_value = value

    return best_value
```",85500.0,True,0.0,0.0,3.7717599868774414,
58,9000.0,"```python
def solve():
    # Let x = loaves of bread, y = batches of cookies
    # Maximize: 5x + 3y
    # Subject to:
    #   Mixer: 1*x + 0.5*y <= 3000
    #   Oven:  3*x + 1*y   <= 3000
    #   x >= 0, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) x = 0:
    #    0.5y <= 3000 -> y <= 6000
    #    y <= 3000
    #    So (0, 3000)
    #
    # 2) y = 0:
    #    x <= 3000
    #    3x <= 3000 -> x <= 1000
    #    So (1000, 0)
    #
    # 3) Intersection of:
    #    x + 0.5y = 3000
    #    3x + y   = 3000
    #
    # From first: y = 6000 - 2x
    # Plug into second:
    #   3x + (6000 - 2x) = 3000
    #   x + 6000 = 3000
    #   x = -3000 (infeasible, negative)
    #
    # So feasible corner points are (0,0), (0,3000), (1000,0).
    
    candidates = [(0.0, 0.0), (0.0, 3000.0), (1000.0, 0.0)]
    
    best_value = float('-inf')
    for x, y in candidates:
        value = 5.0 * x + 3.0 * y
        if value > best_value:
            best_value = value
    
    return best_value
```",9000.0,True,0.0,0.0,2.3479952812194824,
59,2200.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 50*x + 30*y
    # Subject to:
    #   100*x + 80*y >= 5000
    #   0 <= y <= 30
    #   x >= 0
    #
    # Because there are only two variables and a simple bound on y,
    # we can search over feasible integer y in [0, 30] and compute
    # the minimal x for each y, then evaluate the objective.
    
    best_value = float('inf')
    
    for y in range(0, 31):
        # Compute minimal x satisfying 100*x + 80*y >= 5000
        required = 5000 - 80 * y
        if required <= 0:
            x = 0.0
        else:
            # x must be at least required/100; we allow fractional x
            x = required / 100.0
        
        # x must be nonnegative
        if x < 0:
            continue
        
        value = 50.0 * x + 30.0 * y
        if value < best_value:
            best_value = value
    
    return best_value
```",2200.0,True,0.0,0.0,1.8717894554138184,
60,150000.0,"```python
def solve():
    # We solve the LP:
    # Maximize  2.1*L + 3.3*C
    # Subject to:
    #   15000 <= L <= 40000
    #   5000  <= C <= 20000
    #   L + C >= 50000
    
    # Since the feasible region is a convex polygon and the objective is linear,
    # the optimum occurs at a vertex. We enumerate all candidate vertices formed
    # by intersecting the constraint boundaries and then pick the best feasible one.
    
    candidates = []
    
    # Boundaries:
    # L = 15000 or 40000
    # C = 5000 or 20000
    # L + C = 50000
    
    # 1) Intersections of L/C bounds with L+C=50000
    # L = 15000 -> C = 35000
    candidates.append((15000.0, 50000.0 - 15000.0))
    # L = 40000 -> C = 10000
    candidates.append((40000.0, 50000.0 - 40000.0))
    # C = 5000 -> L = 45000
    candidates.append((50000.0 - 5000.0, 5000.0))
    # C = 20000 -> L = 30000
    candidates.append((50000.0 - 20000.0, 20000.0))
    
    # 2) Corners from simple bounds (without forcing L+C=50000)
    # (L, C) in {15000,40000} x {5000,20000}
    bound_points = [
        (15000.0, 5000.0),
        (15000.0, 20000.0),
        (40000.0, 5000.0),
        (40000.0, 20000.0),
    ]
    candidates.extend(bound_points)
    
    best_value = None
    
    for L, C in candidates:
        # Check feasibility:
        if not (15000.0 <= L <= 40000.0):
            continue
        if not (5000.0 <= C <= 20000.0):
            continue
        if L + C < 50000.0:
            continue
        
        value = 2.1 * L + 3.3 * C
        if (best_value is None) or (value > best_value):
            best_value = value
    
    # best_value is the optimal objective value
    return float(best_value)
```",150000.0,True,0.0,0.0,3.3813071250915527,
61,19.0,"```python
def solve():
    # We need integers t (tractors) and c (cars)
    # Constraints:
    # 1) 40t + 20c >= 500
    # 2) c >= 2t
    # Objective: minimize t + c
    
    best_value = None
    
    # Upper bound for search: in worst case, use only cars: 20c >= 500 -> c >= 25
    # Also, tractors carry more, so t won't exceed 13 (since 40*13 = 520).
    # We'll search a reasonable range for t and c.
    for t in range(0, 20):
        for c in range(0, 50):
            if 40 * t + 20 * c >= 500 and c >= 2 * t:
                total = t + c
                if best_value is None or total < best_value:
                    best_value = total
    
    # Return the minimal total number of vehicles as a float
    return float(best_value)
```",19.0,True,0.0,0.0,2.051830530166626,
62,62.5,"```python
def solve():
    # Let x = units of fertilizer, y = units of seeds
    # Objective: minimize T = 0.5x + 1.5y
    # Constraints:
    # 1) x + y <= 300
    # 2) x >= 50
    # 3) x <= 2y
    # 4) x, y >= 0
    
    # This is a 2-variable LP; we can solve by checking all corner points
    # formed by intersections of the constraint boundaries.
    
    import math

    def feasible(x, y):
        return (
            x + y <= 300 + 1e-9 and
            x >= 50 - 1e-9 and
            x <= 2 * y + 1e-9 and
            x >= -1e-9 and
            y >= -1e-9
        )

    def T(x, y):
        return 0.5 * x + 1.5 * y

    candidates = []

    # Intersections of constraint boundaries:

    # 1) x = 50, x + y = 300 -> y = 250
    x, y = 50.0, 250.0
    if feasible(x, y):
        candidates.append((x, y))

    # 2) x = 50, x = 2y -> 50 = 2y -> y = 25
    x, y = 50.0, 25.0
    if feasible(x, y):
        candidates.append((x, y))

    # 3) x + y = 300, x = 2y -> 2y + y = 300 -> y = 100, x = 200
    x, y = 200.0, 100.0
    if feasible(x, y):
        candidates.append((x, y))

    # Also check potential boundary points where constraints meet axes,
    # though many will be infeasible due to x >= 50 and x <= 2y.

    # 4) x = 50, y = 0
    x, y = 50.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # 5) y = 0, x + y = 300 -> x = 300
    x, y = 300.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # 6) y = 0, x = 2y -> x = 0
    x, y = 0.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # 7) x + y = 300, y = 0 already considered as (300, 0)

    # Now evaluate objective at all feasible candidates
    best_val = math.inf
    for x, y in candidates:
        val = T(x, y)
        if val < best_val:
            best_val = val

    return float(best_val)
```",62.5,True,0.0,0.0,4.288931608200073,
63,37.0,"```python
def solve():
    # We want to minimize total time: x + y
    # Subject to:
    # 20x + 10y >= 700   (allergy pills)
    # 15x + 30y >= 600   (fever pills)
    # 20x + 30y <= 1000  (rare compound)
    # x, y >= 0
    
    # This is a 2-variable linear program; we can solve by checking all corner points
    # formed by intersections of constraint boundaries and axes.
    
    import math

    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 20*x + 10*y < 700:
            return False
        if 15*x + 30*y < 600:
            return False
        if 20*x + 30*y > 1000:
            return False
        return True

    candidates = []

    # 1) Intersections of pairs of constraint boundaries

    # a) 20x + 10y = 700 and 15x + 30y = 600
    # Simplify:
    # 2x + y = 70
    # x + 2y = 40
    # Solve:
    # From first: y = 70 - 2x
    # Plug into second: x + 2(70 - 2x) = 40 -> x + 140 - 4x = 40 -> -3x = -100 -> x = 100/3
    # y = 70 - 2*(100/3) = 70 - 200/3 = (210 - 200)/3 = 10/3
    x = 100.0 / 3.0
    y = 10.0 / 3.0
    if feasible(x, y):
        candidates.append((x, y))

    # b) 20x + 10y = 700 and 20x + 30y = 1000
    # Simplify:
    # 2x + y = 70
    # 2x + 3y = 100
    # Subtract first from second: 2y = 30 -> y = 15
    # Then 2x + 15 = 70 -> 2x = 55 -> x = 27.5
    x = 27.5
    y = 15.0
    if feasible(x, y):
        candidates.append((x, y))

    # c) 15x + 30y = 600 and 20x + 30y = 1000
    # Simplify:
    # x + 2y = 40
    # 2x + 3y = 100
    # From first: x = 40 - 2y
    # Plug into second: 2(40 - 2y) + 3y = 100 -> 80 - 4y + 3y = 100 -> -y = 20 -> y = -20 (infeasible)
    # So no feasible intersection here.

    # 2) Intersections with axes (x=0 or y=0) for each constraint boundary

    # For 20x + 10y = 700:
    # x=0 -> y=70
    x, y = 0.0, 70.0
    if feasible(x, y):
        candidates.append((x, y))
    # y=0 -> x=35
    x, y = 35.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # For 15x + 30y = 600:
    # x=0 -> y=20
    x, y = 0.0, 20.0
    if feasible(x, y):
        candidates.append((x, y))
    # y=0 -> x=40
    x, y = 40.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # For 20x + 30y = 1000:
    # x=0 -> y=1000/30
    x, y = 0.0, 1000.0 / 30.0
    if feasible(x, y):
        candidates.append((x, y))
    # y=0 -> x=50
    x, y = 50.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # Now evaluate objective x + y at all feasible candidates
    best_val = math.inf
    for x, y in candidates:
        val = x + y
        if val < best_val:
            best_val = val

    return float(best_val)
```",36.66666666666667,False,0.3333333333333286,0.009009009008765395,5.032155752182007,
64,52.0,"```python
def solve():
    # Let w = number of wide pipes, n = number of narrow pipes
    # Constraints:
    # 1) 25w + 15n >= 900
    # 2) w <= n / 3  ->  3w <= n
    # 3) w >= 5
    # Objective: minimize w + n, with w, n integers and w, n >= 0
    
    best_value = None
    
    # From constraint 1 and 3w <= n, we can bound w.
    # Using n = 3w (smallest n for given w), 25w + 15*(3w) = 70w >= 900 -> w >= 900/70
    # So w >= 12.857..., but also w >= 5, so start from w = 13.
    # For an upper bound, if we used only wide pipes: 25w >= 900 -> w <= 36.
    # So search w in [5, 36] safely.
    
    for w in range(5, 37):
        # n must satisfy:
        # n >= 3w (from 3w <= n)
        # 25w + 15n >= 900 -> n >= (900 - 25w) / 15
        n_min_from_capacity = (900 - 25 * w) / 15.0
        if n_min_from_capacity < 0:
            n_min_from_capacity = 0.0
        
        # Take the ceiling of the max lower bound for n
        n_lower_bound = max(3 * w, int(n_min_from_capacity) if n_min_from_capacity.is_integer() else int(n_min_from_capacity) + 1)
        
        # Now we have a feasible (w, n_lower_bound)
        n = n_lower_bound
        
        # Check feasibility explicitly
        if 25 * w + 15 * n >= 900 and 3 * w <= n and w >= 5:
            total_pipes = w + n
            if best_value is None or total_pipes < best_value:
                best_value = total_pipes
    
    # Return the optimal objective value as float
    return float(best_value)
```",52.0,True,0.0,0.0,3.485238552093506,
65,580.0,"```python
def solve():
    # We solve the LP:
    # Minimize diesel: 30x + 40y
    # Subject to:
    # 1) 50x + 70y >= 1000        (enough gifts)
    # 2) x <= 15                  (new company trip limit)
    # 3) y >= (2/3) x             (at least 40% of trips by old company)
    # 4) x >= 0, y >= 0
    
    # This is a 2-variable LP; we can solve it by checking corner points
    # of the feasible region formed by the constraints.
    
    best_value = None
    
    # We'll search over possible x values (continuous) by considering
    # the key candidate points analytically instead of brute force.
    # However, to keep code simple and robust without external libraries,
    # we can discretize x finely enough; the problem is small-scale.
    #
    # But to avoid any approximation, we instead compute all intersection
    # points of constraint boundaries exactly and then check feasibility.
    
    candidates = []
    
    # Helper to add candidate if feasible
    def add_if_feasible(x, y):
        if x < 0 or y < 0:
            return
        if x > 15 + 1e-9:
            return
        if y + 1e-9 < (2.0/3.0) * x:
            return
        if 50*x + 70*y + 1e-9 < 1000:
            return
        candidates.append((x, y))
    
    # 1) Intersection of gift constraint and x=15
    # 50*15 + 70y = 1000 -> y
    x = 15.0
    y = (1000 - 50*x) / 70.0
    add_if_feasible(x, y)
    
    # 2) Intersection of gift constraint and y = (2/3)x
    # 50x + 70*(2/3)x = 1000
    # 50x + (140/3)x = 1000
    # (150/3 + 140/3)x = (290/3)x = 1000
    # x = 1000 * 3 / 290
    x = 1000.0 * 3.0 / 290.0
    y = (2.0/3.0) * x
    add_if_feasible(x, y)
    
    # 3) Intersection of x=15 and y = (2/3)x
    x = 15.0
    y = (2.0/3.0) * x
    add_if_feasible(x, y)
    
    # 4) Intersection of gift constraint with y=0
    # 50x = 1000 -> x=20 (but x<=15, so infeasible; still check via helper)
    x = 20.0
    y = 0.0
    add_if_feasible(x, y)
    
    # 5) Intersection of gift constraint with x=0
    # 70y = 1000 -> y
    x = 0.0
    y = 1000.0 / 70.0
    add_if_feasible(x, y)
    
    # 6) Corner x=0 with y from ratio constraint: y >= 0, ratio gives y>=0
    # Need enough gifts: 70y >= 1000 -> y=1000/70
    x = 0.0
    y = 1000.0 / 70.0
    add_if_feasible(x, y)
    
    # 7) Corner y = (2/3)x with x=0 -> (0,0) but fails gift constraint
    x = 0.0
    y = 0.0
    add_if_feasible(x, y)
    
    # Also, because feasible region is closed and bounded in this context,
    # the optimum is at one of these boundary intersections.
    
    for x, y in candidates:
        value = 30.0 * x + 40.0 * y
        if (best_value is None) or (value < best_value):
            best_value = value
    
    # best_value is the minimal diesel usage
    return float(best_value)
```",571.4285714285714,False,8.571428571428555,0.014778325123127201,5.016819000244141,
66,-99999.0,"```python
def solve():
    # We will brute-force over all feasible integer doses of A and B.
    # Let x = doses of A, y = doses of B.
    # Constraints:
    # 1) 30x + 40y <= 300  (imported material)
    # 2) 50x + 30y <= 400  (mRNA)
    # 3) x <= 5
    # 4) y > x
    # 5) x, y >= 0 and integers
    # Objective: maximize 12x + 8y
    
    best_value = float('-inf')
    
    # Upper bounds for search: from constraints
    # x <= 5, and from materials:
    # 30x + 40y <= 300 => y <= (300 - 30x)/40
    # 50x + 30y <= 400 => y <= (400 - 50x)/30
    # We'll just search a safe range for x and y.
    
    for x in range(0, 6):  # x can be 0..5
        # For each x, compute max possible y from material constraints
        max_y1 = (300 - 30 * x) // 40 if 300 - 30 * x >= 0 else -1
        max_y2 = (400 - 50 * x) // 30 if 400 - 50 * x >= 0 else -1
        max_y = min(max_y1, max_y2)
        if max_y < 0:
            continue
        
        # y must be integer, >= 0, and > x
        for y in range(x + 1, max_y + 1):
            # Check constraints explicitly (though already enforced by bounds)
            if 30 * x + 40 * y <= 300 and 50 * x + 30 * y <= 400 and x <= 5:
                value = 12 * x + 8 * y
                if value > best_value:
                    best_value = value
    
    # Return the optimal objective value as a float
    return float(best_value)
```",76.0,False,100075.0,1.000760007600066,3.2769484519958496,
67,60.0,"```python
def solve():
    # We want to maximize slime: 4x + 5y
    # subject to:
    # 3x + 8y <= 100   (powder)
    # 5x + 6y <= 90    (glue)
    # 2x + 4y <= 30    (mess)
    # x, y >= 0
    
    # We'll solve this small LP by enumerating all corner points formed by
    # intersections of constraint lines and axes, then checking feasibility.
    
    import math

    def intersect(a1, b1, c1, a2, b2, c2):
        # Solve:
        # a1 x + b1 y = c1
        # a2 x + b2 y = c2
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-9:
            return None
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)

    # Constraints in equality form for intersections:
    # 1) 3x + 8y = 100
    # 2) 5x + 6y = 90
    # 3) 2x + 4y = 30

    candidates = []

    # Intersections of each pair of constraint lines
    pairs = [
        ((3, 8, 100), (5, 6, 90)),
        ((3, 8, 100), (2, 4, 30)),
        ((5, 6, 90), (2, 4, 30)),
    ]

    for (a1, b1, c1), (a2, b2, c2) in pairs:
        pt = intersect(a1, b1, c1, a2, b2, c2)
        if pt is not None:
            candidates.append(pt)

    # Intersections with axes (x=0 or y=0) for each constraint
    # For x = 0: b y <= c  => y = c/b
    # For y = 0: a x <= c  => x = c/a
    constraints = [(3, 8, 100), (5, 6, 90), (2, 4, 30)]

    for a, b, c in constraints:
        # x = 0
        if abs(b) > 1e-9:
            y = c / b
            candidates.append((0.0, y))
        # y = 0
        if abs(a) > 1e-9:
            x = c / a
            candidates.append((x, 0.0))

    # Also include origin
    candidates.append((0.0, 0.0))

    def feasible(x, y):
        if x < -1e-9 or y < -1e-9:
            return False
        if 3 * x + 8 * y > 100 + 1e-9:
            return False
        if 5 * x + 6 * y > 90 + 1e-9:
            return False
        if 2 * x + 4 * y > 30 + 1e-9:
            return False
        return True

    best_value = -math.inf
    for x, y in candidates:
        if feasible(x, y):
            value = 4 * x + 5 * y
            if value > best_value:
                best_value = value

    return float(best_value)
```",60.0,True,0.0,0.0,4.814830541610718,
68,2400.0,"```python
def solve():
    # Let T = amount invested in telecom
    #     H = amount invested in healthcare
    #
    # Constraints:
    # 1) T + H = 100000
    # 2) T >= 3H
    # 3) T <= 70000
    # Objective: maximize 0.03*T + 0.01*H
    
    # From T + H = 100000 => H = 100000 - T
    # Substitute into T >= 3H:
    # T >= 3(100000 - T)
    # T >= 300000 - 3T
    # 4T >= 300000
    # T >= 75000
    #
    # But we also have T <= 70000, so there is no feasible solution
    # that satisfies all constraints simultaneously.
    #
    # In a standard LP setting, this means the problem is infeasible.
    # Since the task requires returning a float, we can signal infeasibility
    # using float('nan').
    
    return float('nan')
```",,False,,,2.3570950031280518,
69,735.0,"```python
def solve():
    # Let x = number of painkiller pills
    #     y = number of sleeping pills
    #
    # Constraints:
    # 1) Morphine: 10x + 6y <= 3000
    # 2) At least 50 painkillers: x >= 50
    # 3) At least 70% sleeping pills: y >= 0.7(x + y) -> 0.3y >= 0.7x -> y >= (7/3)x
    # 4) x, y >= 0
    #
    # Objective: minimize digestive medicine: 3x + 5y
    #
    # This is a 2-variable LP; we can solve it analytically and then verify numerically.
    #
    # From y >= (7/3)x and x >= 50, the smallest feasible x is 50.
    # For fixed x, objective increases with y (since coefficient of y is positive),
    # so we take the smallest feasible y for that x, i.e. y = (7/3)x, as long as
    # morphine constraint is satisfied.
    #
    # Check morphine at x=50, y=(7/3)*50:
    # y = 350/3
    # 10x + 6y = 10*50 + 6*(350/3) = 500 + 700 = 1200 <= 3000, so feasible.
    #
    # Increasing x increases both x and y (since y = (7/3)x), and thus increases
    # morphine usage and the objective. So the minimum is at the smallest x, i.e. x=50.
    #
    # Compute objective at x=50, y=350/3:
    x = 50.0
    y = (7.0 / 3.0) * x
    objective = 3.0 * x + 5.0 * y
    return float(objective)
```",733.3333333333334,False,1.6666666666666288,0.002267573696141988,3.3832356929779053,
70,14.0,"```python
def solve():
    # Let v = number of vans, t = number of trucks
    # Constraints:
    # 1) 50v + 100t >= 2000
    # 2) t <= v
    # 3) v, t are nonnegative integers
    #
    # We want to minimize v.
    #
    # From 50v + 100t >= 2000, divide by 50:
    # v + 2t >= 40
    #
    # Also t <= v.
    #
    # For a given v, the minimum t that satisfies v + 2t >= 40 is:
    # t >= (40 - v) / 2
    #
    # Also t must be <= v and t >= 0.
    #
    # We search for the smallest integer v for which there exists an integer t
    # satisfying all constraints.

    best_v = None
    # Upper bound for v: in worst case, use only vans: 50v >= 2000 => v >= 40
    # So v won't need to exceed 40 to meet demand; but t <= v, so v at least 0.
    for v in range(0, 41):
        # Compute minimal feasible t from demand constraint
        min_t = (40 - v + 1) // 2 if (40 - v) > 0 else 0  # ceil((40 - v)/2) if positive, else 0
        # Ensure min_t is not negative
        if min_t < 0:
            min_t = 0

        # t must be integer, between min_t and v
        if min_t <= v:
            # Check if there exists such t that satisfies v + 2t >= 40
            # Since min_t is chosen from that constraint, it's enough to check feasibility bounds
            t = min_t
            if v + 2 * t >= 40 and t <= v:
                best_v = v
                break

    # best_v is the minimal number of vans
    return float(best_v)
```",14.0,True,0.0,0.0,3.2767066955566406,
71,1480.0,"```python
def solve():
    # We maximize water = 40*s + 100*l
    # Subject to:
    # 1) s <= 30
    # 2) l <= 10
    # 3) s >= 2*l
    # 4) s + l <= 25
    # 5) l >= 5
    # 6) s, l >= 0
    #
    # We assume s and l are integers (kegs).
    
    best_value = float('-inf')
    
    # l ranges from 5 to 10 (due to constraints l >= 5 and l <= 10)
    for l in range(5, 11):
        # s must satisfy:
        # s >= 2*l
        # s <= 30
        # s + l <= 25  -> s <= 25 - l
        s_min = 2 * l
        s_max = min(30, 25 - l)
        
        if s_min > s_max:
            continue
        
        # Since objective is increasing in s (40 per small keg),
        # choose the largest feasible s.
        s = s_max
        
        value = 40 * s + 100 * l
        if value > best_value:
            best_value = value
    
    return float(best_value)
```",1480.0,True,0.0,0.0,2.050212860107422,
72,1.5,"```python
def solve():
    # We solve the LP:
    # Minimize:  0.3 x1 + 0.5 x2
    # Subject to:
    #   0.5 x1 + 0.3 x2 <= 8      (heart)
    #   0.8 x1 + 1.0 x2 >= 4      (brain)
    #   x1 >= 0, x2 >= 0
    
    # The feasible region is a convex polygon; the optimum of a linear program
    # occurs at a vertex (corner). We enumerate all candidate vertices formed by
    # intersecting pairs of constraint boundaries and then check feasibility.
    
    import math

    candidates = []

    # 1) Intersection of heart and brain constraints:
    #   0.5 x1 + 0.3 x2 = 8
    #   0.8 x1 + 1.0 x2 = 4
    # Solve this 2x2 system.
    # Use Cramer's rule or direct algebra.
    # a11=0.5, a12=0.3, b1=8
    # a21=0.8, a22=1.0, b2=4
    det = 0.5 * 1.0 - 0.3 * 0.8
    if abs(det) > 1e-12:
        x1 = (8 * 1.0 - 0.3 * 4) / det
        x2 = (0.5 * 4 - 8 * 0.8) / det
        candidates.append((x1, x2))

    # 2) Intersection of heart constraint with x1 = 0:
    #   0.5*0 + 0.3 x2 = 8  => x2 = 8 / 0.3
    x1 = 0.0
    x2 = 8.0 / 0.3
    candidates.append((x1, x2))

    # 3) Intersection of heart constraint with x2 = 0:
    #   0.5 x1 + 0*0.3 = 8 => x1 = 16
    x1 = 16.0
    x2 = 0.0
    candidates.append((x1, x2))

    # 4) Intersection of brain constraint with x1 = 0:
    #   0.8*0 + 1.0 x2 = 4 => x2 = 4
    x1 = 0.0
    x2 = 4.0
    candidates.append((x1, x2))

    # 5) Intersection of brain constraint with x2 = 0:
    #   0.8 x1 + 1.0*0 = 4 => x1 = 5
    x1 = 5.0
    x2 = 0.0
    candidates.append((x1, x2))

    # 6) Intersection of nonnegativity: (0,0)
    candidates.append((0.0, 0.0))

    def feasible(x1, x2):
        if x1 < -1e-9 or x2 < -1e-9:
            return False
        # heart: <= 8
        if 0.5 * x1 + 0.3 * x2 - 8.0 > 1e-9:
            return False
        # brain: >= 4
        if 0.8 * x1 + 1.0 * x2 - 4.0 < -1e-9:
            return False
        return True

    best_val = math.inf
    for x1, x2 in candidates:
        if feasible(x1, x2):
            val = 0.3 * x1 + 0.5 * x2
            if val < best_val:
                best_val = val

    # best_val is the minimal waste
    return float(best_val)
```",1.5,True,0.0,0.0,5.53484582901001,
73,6.4,"```python
def solve():
    # We solve the LP:
    # Maximize: 0.8 x1 + 0.4 x2
    # Subject to:
    #   Legs: 0.5 x1 + 0.7 x2 >= 4
    #   Sleep: 0.3 x1 + 0.6 x2 <= 8
    #   x1, x2 >= 0
    #
    # We'll find the optimal solution by enumerating corner points of the feasible region.

    # Helper to compute objective
    def obj(x1, x2):
        return 0.8 * x1 + 0.4 * x2

    candidates = []

    # 1) Intersection of legs and sleep constraints:
    #   0.5 x1 + 0.7 x2 = 4
    #   0.3 x1 + 0.6 x2 = 8
    # Solve this 2x2 system manually:
    # From second: 0.3 x1 = 8 - 0.6 x2 => x1 = (8 - 0.6 x2)/0.3
    # Substitute into first:
    # 0.5*(8 - 0.6 x2)/0.3 + 0.7 x2 = 4
    # We'll just solve numerically here.

    # Solve linear system A * [x1, x2]^T = b
    # A = [[0.5, 0.7],
    #      [0.3, 0.6]]
    # b = [4, 8]
    det = 0.5 * 0.6 - 0.7 * 0.3
    if abs(det) > 1e-12:
        x1 = (4 * 0.6 - 0.7 * 8) / det
        x2 = (0.5 * 8 - 4 * 0.3) / det
        if x1 >= 0 and x2 >= 0:
            # Check feasibility with inequalities (allow small tolerance)
            if 0.5 * x1 + 0.7 * x2 >= 4 - 1e-9 and 0.3 * x1 + 0.6 * x2 <= 8 + 1e-9:
                candidates.append((x1, x2))

    # 2) Intersection of legs constraint with x1 = 0:
    #   0.5*0 + 0.7 x2 >= 4 => x2 >= 4 / 0.7
    x2 = 4.0 / 0.7
    x1 = 0.0
    # Check sleep constraint
    if 0.3 * x1 + 0.6 * x2 <= 8 + 1e-9:
        candidates.append((x1, x2))

    # 3) Intersection of legs constraint with x2 = 0:
    #   0.5 x1 >= 4 => x1 >= 8
    x1 = 8.0
    x2 = 0.0
    if 0.3 * x1 + 0.6 * x2 <= 8 + 1e-9:
        candidates.append((x1, x2))

    # 4) Intersection of sleep constraint with x1 = 0:
    #   0.3*0 + 0.6 x2 <= 8 => x2 <= 8 / 0.6
    #   Also must satisfy legs: 0.7 x2 >= 4 => x2 >= 4 / 0.7
    x2_min = 4.0 / 0.7
    x2_max = 8.0 / 0.6
    if x2_min <= x2_max + 1e-9:
        # The objective is linear and increasing in x2 when x1=0 (0.4 x2),
        # so the best point on this edge is x2 = x2_max.
        x1 = 0.0
        x2 = x2_max
        candidates.append((x1, x2))

    # 5) Intersection of sleep constraint with x2 = 0:
    #   0.3 x1 <= 8 => x1 <= 8 / 0.3
    #   Also must satisfy legs: 0.5 x1 >= 4 => x1 >= 8
    x1_min = 8.0
    x1_max = 8.0 / 0.3
    if x1_min <= x1_max + 1e-9:
        # Objective with x2=0 is 0.8 x1, increasing in x1,
        # so best is x1 = x1_max.
        x1 = x1_max
        x2 = 0.0
        candidates.append((x1, x2))

    # Remove duplicates (within tolerance)
    unique = []
    for (a, b) in candidates:
        if not any(abs(a - c) < 1e-8 and abs(b - d) < 1e-8 for (c, d) in unique):
            unique.append((a, b))

    # Evaluate objective at all candidate points
    best_val = float(""-inf"")
    for (x1, x2) in unique:
        val = obj(x1, x2)
        if val > best_val:
            best_val = val

    return float(best_val)
```",21.333333333333336,False,14.933333333333335,2.33333333296875,6.453808784484863,
74,5050.0,"```python
def solve():
    # We solve the LP:
    # Maximize 200x + 70y
    # subject to:
    #   x <= 20
    #   y <= 30
    #   x + y <= 35
    #   x >= 0, y >= 0
    
    # The feasible region is a polygon; the optimum of a linear program
    # occurs at a vertex (corner point). We enumerate all corner points
    # formed by intersecting the constraints and pick the best.
    
    candidates = []
    
    # Helper to check feasibility
    def feasible(x, y):
        return (0 <= x <= 20 and
                0 <= y <= 30 and
                x + y <= 35)
    
    # List all potential intersection points of constraints:
    # 1) (0,0)
    candidates.append((0.0, 0.0))
    
    # 2) x = 20 with other constraints
    x = 20.0
    # with y = 0
    candidates.append((x, 0.0))
    # with x + y = 35 -> y = 15
    candidates.append((x, 35.0 - x))
    
    # 3) y = 30 with other constraints
    y = 30.0
    # with x = 0
    candidates.append((0.0, y))
    # with x + y = 35 -> x = 5
    candidates.append((35.0 - y, y))
    
    # 4) x + y = 35 with nonnegativity
    # with x = 0 -> y = 35
    candidates.append((0.0, 35.0))
    # with y = 0 -> x = 35
    candidates.append((35.0, 0.0))
    
    best_value = float('-inf')
    
    for x, y in candidates:
        if feasible(x, y):
            value = 200.0 * x + 70.0 * y
            if value > best_value:
                best_value = value
    
    return best_value
```",5050.0,True,0.0,0.0,4.1775243282318115,
75,1800.0,"```python
def solve():
    # We formulate the LP:
    # Let x = acres processed by windrower
    #     y = acres processed by hay harvester
    #
    # Maximize hay processed: 10x + 8y
    #
    # Subject to:
    # 1) Land:      x + y <= 200
    # 2) Fuel:      2x + y <= 300
    # 3) Methane:   5x + 3y <= 800
    # 4) x >= 0, y >= 0
    #
    # We'll solve by checking all corner points of the feasible region.

    def is_feasible(x, y):
        return (
            x >= 0 and y >= 0 and
            x + y <= 200 + 1e-9 and
            2 * x + y <= 300 + 1e-9 and
            5 * x + 3 * y <= 800 + 1e-9
        )

    candidates = []

    # Intersections of pairs of constraints (treated as equalities)

    # 1) x + y = 200 and 2x + y = 300
    # Subtract: (2x + y) - (x + y) = 300 - 200 => x = 100, then y = 100
    x, y = 100.0, 100.0
    if is_feasible(x, y):
        candidates.append((x, y))

    # 1) x + y = 200 and 5x + 3y = 800
    # From x + y = 200 => y = 200 - x
    # 5x + 3(200 - x) = 800 => 5x + 600 - 3x = 800 => 2x = 200 => x = 100, y = 100
    x, y = 100.0, 100.0
    if is_feasible(x, y):
        candidates.append((x, y))

    # 2) 2x + y = 300 and 5x + 3y = 800
    # From 2x + y = 300 => y = 300 - 2x
    # 5x + 3(300 - 2x) = 800 => 5x + 900 - 6x = 800 => -x = -100 => x = 100, y = 100
    x, y = 100.0, 100.0
    if is_feasible(x, y):
        candidates.append((x, y))

    # Intersections with axes:

    # x = 0
    # Then constraints reduce to:
    # y <= 200, y <= 300, 3y <= 800 => y <= 800/3
    y_max = min(200.0, 300.0, 800.0 / 3.0)
    x, y = 0.0, y_max
    if is_feasible(x, y):
        candidates.append((x, y))

    # y = 0
    # Then constraints reduce to:
    # x <= 200, 2x <= 300 => x <= 150, 5x <= 800 => x <= 160
    x_max = min(200.0, 150.0, 800.0 / 5.0)
    x, y = x_max, 0.0
    if is_feasible(x, y):
        candidates.append((x, y))

    # Also include the origin
    candidates.append((0.0, 0.0))

    # Remove duplicates (if any)
    unique_candidates = []
    seen = set()
    for x, y in candidates:
        key = (round(x, 9), round(y, 9))
        if key not in seen:
            seen.add(key)
            unique_candidates.append((x, y))

    # Evaluate objective 10x + 8y at each feasible corner
    best_value = float('-inf')
    for x, y in unique_candidates:
        if is_feasible(x, y):
            value = 10.0 * x + 8.0 * y
            if value > best_value:
                best_value = value

    return best_value
```",1800.0,True,0.0,0.0,4.834807395935059,
76,1965.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 50x + 43y
    # Subject to:
    # 1) x + y <= 40          (total shifts)
    # 2) 5x + 6y <= 230       (energy)
    # 3) 10x + 7y >= 320      (orders)
    # 4) y >= 5               (min scooter shifts)
    # 5) x >= 0, y >= 0
    
    # We'll solve by enumerating all corner points formed by intersections
    # of the constraint boundaries and checking feasibility and objective.
    
    import math
    
    best_val = -math.inf
    
    def check_and_update(x, y):
        nonlocal best_val
        # Feasibility checks with small tolerance
        eps = 1e-9
        if x < -eps or y < 5 - eps:
            return
        if x + y > 40 + eps:
            return
        if 5*x + 6*y > 230 + eps:
            return
        if 10*x + 7*y < 320 - eps:
            return
        val = 50*x + 43*y
        if val > best_val:
            best_val = val
    
    # Helper to solve 2x2 linear systems: a1 x + b1 y = c1, a2 x + b2 y = c2
    def solve_two(a1, b1, c1, a2, b2, c2):
        det = a1*b2 - a2*b1
        if abs(det) < 1e-12:
            return None
        x = (c1*b2 - c2*b1) / det
        y = (a1*c2 - a2*c1) / det
        return (x, y)
    
    # List of boundary equations (as equalities):
    # We'll encode each as (a, b, c) meaning a*x + b*y = c
    boundaries = [
        (1, 1, 40),    # x + y = 40
        (5, 6, 230),   # 5x + 6y = 230
        (10, 7, 320),  # 10x + 7y = 320
        (0, 1, 5),     # y = 5
        (1, 0, 0)      # x = 0
    ]
    
    # Intersections of all pairs of boundaries
    n = len(boundaries)
    for i in range(n):
        for j in range(i+1, n):
            a1, b1, c1 = boundaries[i]
            a2, b2, c2 = boundaries[j]
            sol = solve_two(a1, b1, c1, a2, b2, c2)
            if sol is not None:
                x, y = sol
                check_and_update(x, y)
    
    # Also check some obvious boundary points that might not come from pairwise intersections
    # but from single constraints with variable bounds.
    # y = 5 with other inequalities (scan x range)
    # However, intersections above already include y=5 with others and x=0 with others,
    # so main corners are covered. Still, we can check a few integer points around.
    
    # Small grid search around feasible region to be safe (coarse, but constraints are small).
    # This is not necessary but ensures robustness without external libs.
    for x in [i * 0.5 for i in range(0, 81)]:  # x in [0,40]
        # derive feasible y range from constraints roughly
        # y >= 5
        # y <= 40 - x
        # y <= (230 - 5x)/6
        # y >= (320 - 10x)/7
        y_min = max(5, (320 - 10*x)/7)
        y_max = min(40 - x, (230 - 5*x)/6)
        if y_min <= y_max:
            # check both ends
            check_and_update(x, y_min)
            check_and_update(x, y_max)
    
    return float(best_val)
```",1965.0,True,0.0,0.0,4.713293552398682,
77,310.0,"```python
def solve():
    # We maximize total mail: 3R + 10C
    # Subject to:
    # 1) Time: 4R + 2C <= 200
    # 2) Canoe fraction: C <= (1/3)(R + C)  ->  2C <= R
    # 3) R >= 4
    # 4) R, C >= 0 (continuous, not necessarily integer)
    #
    # This is a 2-variable LP; we can solve analytically by checking corner points.

    # Constraints in standard form:
    # (i) 4R + 2C <= 200
    # (ii) 2C <= R
    # (iii) R >= 4
    # (iv) R >= 0, C >= 0

    # Corner points come from intersections of constraint boundaries:
    # A: R = 4, C = 0
    # B: R = 4, 4R + 2C = 200
    # C: 2C = R, 4R + 2C = 200
    # D: 2C = R, R = 4

    # A: (4, 0)
    R_A, C_A = 4.0, 0.0

    # B: R = 4, 4R + 2C = 200 -> 16 + 2C = 200 -> C = 92
    R_B, C_B = 4.0, 92.0

    # C: 2C = R and 4R + 2C = 200
    # Substitute R = 2C into time: 4*(2C) + 2C = 200 -> 8C + 2C = 200 -> 10C = 200 -> C = 20, R = 40
    R_C, C_C = 40.0, 20.0

    # D: 2C = R and R = 4 -> C = 2
    R_D, C_D = 4.0, 2.0

    # Check feasibility of each point:
    def feasible(R, C):
        if R < 4 or R < 0 or C < 0:
            return False
        if 4*R + 2*C > 200 + 1e-9:
            return False
        if 2*C > R + 1e-9:
            return False
        return True

    points = [(R_A, C_A), (R_B, C_B), (R_C, C_C), (R_D, C_D)]

    best_val = float('-inf')
    for R, C in points:
        if feasible(R, C):
            val = 3*R + 10*C
            if val > best_val:
                best_val = val

    # best_val is the optimal objective value
    return float(best_val)
```",320.0,False,10.0,0.032258064516024976,4.092540502548218,
78,14.0,"```python
def solve():
    # We want to minimize total vehicles: x + y
    # x = number of buses, y = number of personal cars
    # Constraints:
    # 1) Capacity: 9x + 4y >= 100
    # 2) More buses than cars: x > y  -> x >= y + 1 (integer)
    # 3) At least 5 personal cars: y >= 5
    #
    # We assume x, y are nonnegative integers.
    #
    # Since the problem is small, we can brute force over a reasonable range.

    best_value = None

    # Upper bounds: in the worst case, all vehicles are cars: 4y >= 100 -> y >= 25
    # So y won't need to exceed, say, 30. For x, buses carry more, so x won't need
    # to exceed 100/9 ~ 12, but to be safe we can go a bit higher.
    for y in range(5, 31):          # y >= 5
        for x in range(y + 1, 31):  # x > y
            if 9 * x + 4 * y >= 100:
                total = x + y
                if best_value is None or total < best_value:
                    best_value = total

    # Return the minimal total number of vehicles as a float
    return float(best_value)
```",14.0,True,0.0,0.0,7.579985618591309,
79,36900.0,"```python
def solve():
    # We solve the LP:
    # Maximize 550x + 750y + 950z
    # subject to:
    # 3x + 6y + 9z <= 250   (compound A)
    # 3x + 2y + 3z <= 150   (compound B)
    # x, y, z >= 0
    #
    # This is a 3-variable LP with 2 constraints; the optimum lies at a vertex
    # where two constraints are tight (including possibly nonnegativity).
    #
    # We'll enumerate all candidate vertices formed by:
    # - Setting two of {x, y, z} to 0 and solving for the third from constraints
    # - Intersections of the two resource constraints with one variable set to 0
    # Then we check feasibility and compute the objective.

    best_value = 0.0

    def check_and_update(x, y, z):
        nonlocal best_value
        if x < -1e-9 or y < -1e-9 or z < -1e-9:
            return
        # Enforce nonnegativity numerically
        x = max(0.0, x)
        y = max(0.0, y)
        z = max(0.0, z)
        if 3*x + 6*y + 9*z <= 250 + 1e-9 and 3*x + 2*y + 3*z <= 150 + 1e-9:
            val = 550*x + 750*y + 950*z
            if val > best_value:
                best_value = val

    # 1) Ax and Bx constraints with y=z=0
    # 3x <= 250, 3x <= 150 -> x <= 50
    x = min(250/3.0, 150/3.0)
    check_and_update(x, 0.0, 0.0)

    # 2) Ay and By constraints with x=z=0
    # 6y <= 250, 2y <= 150 -> y <= min(250/6, 75)
    y = min(250/6.0, 150/2.0)
    check_and_update(0.0, y, 0.0)

    # 3) Az and Bz constraints with x=y=0
    # 9z <= 250, 3z <= 150 -> z <= min(250/9, 50)
    z = min(250/9.0, 150/3.0)
    check_and_update(0.0, 0.0, z)

    # 4) Intersection of A and B with x = 0
    # 6y + 9z = 250
    # 2y + 3z = 150
    # Solve:
    # From second: 2y = 150 - 3z -> y = 75 - 1.5z
    # Plug into first: 6(75 - 1.5z) + 9z = 250
    # 450 - 9z + 9z = 250 -> 450 = 250 -> no solution
    # So no feasible intersection with x=0.

    # 5) Intersection of A and B with y = 0
    # 3x + 9z = 250
    # 3x + 3z = 150
    # Subtract second from first: 6z = 100 -> z = 100/6
    z = 100.0 / 6.0
    x = (150 - 3*z) / 3.0  # from 3x + 3z = 150
    check_and_update(x, 0.0, z)

    # 6) Intersection of A and B with z = 0
    # 3x + 6y = 250
    # 3x + 2y = 150
    # Subtract second from first: 4y = 100 -> y = 25
    y = 25.0
    x = (150 - 2*y) / 3.0  # from 3x + 2y = 150
    check_and_update(x, y, 0.0)

    return float(best_value)
```",37083.333333333336,False,183.33333333333576,0.004968383017163436,4.204538345336914,
80,6.0,"```python
def solve():
    # Let x = number of retail stores
    #     y = number of factory outlets
    #
    # Constraints:
    # 1) Customer requirement: 200x + 80y >= 1200
    # 2) Employee limit:       6x + 4y <= 50
    # 3) x, y >= 0
    #
    # Objective: minimize number of stores: z = x + y
    #
    # Since the problem is small and no external libraries are allowed,
    # we can brute-force over a reasonable range of integer store counts.
    #
    # Upper bounds:
    # - Employees: each store uses at least 4 employees, so max stores <= 50/4 = 12.5 -> 12
    # We'll search x, y in [0, 50] safely (more than enough).
    
    best_value = None
    
    # We assume x and y are integers (number of stores).
    for x in range(0, 51):
        for y in range(0, 51):
            # Check constraints
            if 200 * x + 80 * y >= 1200 and 6 * x + 4 * y <= 50:
                z = x + y
                if best_value is None or z < best_value:
                    best_value = z
    
    # Return the optimal objective value as float
    return float(best_value if best_value is not None else 0.0)
```",6.0,True,0.0,0.0,1.9458184242248535,
81,17.714285714285715,"```python
def solve():
    # We solve the LP:
    # Minimize:  5x + 2.5y
    # Subject to:
    #   600x + 250y >= 2000   (calories)
    #   1.5x + 5y   >= 16     (protein)
    #   x >= 0, y >= 0
    #
    # The optimum for a 2-variable LP with linear constraints occurs at a corner (vertex)
    # of the feasible region. We check all relevant vertices:
    #
    # 1) Intersection of the two constraint lines:
    #    600x + 250y = 2000
    #    1.5x + 5y   = 16
    #
    # Solve this system analytically:
    # From second: 1.5x + 5y = 16  =>  x = (16 - 5y)/1.5
    # Substitute into first:
    #   600 * (16 - 5y)/1.5 + 250y = 2000
    #   400 * (16 - 5y) + 250y = 2000
    #   6400 - 2000y + 250y = 2000
    #   6400 - 1750y = 2000
    #   1750y = 4400
    #   y = 4400 / 1750 = 88 / 35
    # Then x = (16 - 5y)/1.5 = (16 - 5*(88/35))/1.5
    #   5*(88/35) = 440/35 = 88/7
    #   16 = 112/7
    #   16 - 88/7 = 24/7
    #   x = (24/7) / 1.5 = (24/7) / (3/2) = (24/7)*(2/3) = 16/7
    #
    # So intersection point: x = 16/7, y = 88/35 (both >= 0, so feasible).
    #
    # Objective value at this point:
    #   z = 5x + 2.5y
    #     = 5*(16/7) + 2.5*(88/35)
    #     = 80/7 + (2.5*88)/35
    #     = 80/7 + 220/35
    #     = 80/7 + 44/7
    #     = 124/7
    #
    # We also check boundary points where one variable is zero:
    #
    # 2) x = 0:
    #    Calories: 250y >= 2000 => y >= 8
    #    Protein:  5y   >= 16   => y >= 3.2
    #    So y >= 8. Take y = 8:
    #    z = 5*0 + 2.5*8 = 20
    #
    # 3) y = 0:
    #    Calories: 600x >= 2000 => x >= 2000/600 = 10/3
    #    Protein:  1.5x >= 16   => x >= 16/1.5 = 32/3
    #    So x >= 32/3. Take x = 32/3:
    #    z = 5*(32/3) = 160/3 â‰ˆ 53.33
    #
    # Compare objective values:
    #   At intersection: 124/7 â‰ˆ 17.7142857
    #   At (0, 8):       20
    #   At (32/3, 0):    160/3 â‰ˆ 53.33
    #
    # Minimum is 124/7.
    return 124.0 / 7.0
```",17.714285714285715,True,0.0,0.0,3.889213800430298,
82,1001.0,"```python
def solve():
    # Let x = number of salinity tests
    #     y = number of pH tests
    #
    # Minimize probes:  minimize 3x + 2y
    #
    # Subject to:
    # 1) y >= 250          (at least 250 pH tests)
    # 2) x + y >= 400      (at least 400 total tests)
    # 3) y <= 1.5x         (at most 1.5 times more pH than salinity)
    # 4) x >= 0, y >= 0
    #
    # This is a 2-variable LP; the optimum lies at a vertex of the feasible region.
    # We find all candidate vertices by intersecting constraint boundaries and
    # checking feasibility, then choose the one with minimal objective 3x + 2y.

    candidates = []

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if y < 250:
            return False
        if x + y < 400:
            return False
        if y > 1.5 * x:
            return False
        return True

    # 1) Intersection of y = 250 and x + y = 400
    y = 250.0
    x = 400.0 - y
    if feasible(x, y):
        candidates.append((x, y))

    # 2) Intersection of y = 250 and y = 1.5x  ->  250 = 1.5x
    x = 250.0 / 1.5
    y = 250.0
    if feasible(x, y):
        candidates.append((x, y))

    # 3) Intersection of x + y = 400 and y = 1.5x
    #    1.5x + x = 400 -> 2.5x = 400 -> x = 160, y = 240
    x = 400.0 / 2.5
    y = 1.5 * x
    if feasible(x, y):
        candidates.append((x, y))

    # Also consider boundary intersections with axes if relevant:
    # y = 250 with x = 0
    x, y = 0.0, 250.0
    if feasible(x, y):
        candidates.append((x, y))

    # x + y = 400 with x = 0 -> y = 400
    x, y = 0.0, 400.0
    if feasible(x, y):
        candidates.append((x, y))

    # x + y = 400 with y = 250 -> already considered as case 1

    # y = 1.5x with x = 0 -> y = 0 (violates y >= 250), so skip

    # Compute objective for all feasible candidates and return minimum
    best_value = None
    for x, y in candidates:
        value = 3.0 * x + 2.0 * y
        if best_value is None or value < best_value:
            best_value = value

    # best_value is the minimal number of probes
    return float(best_value)
```",1000.0,False,1.0,0.000999000999000001,3.528688430786133,
83,390.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 5x + 7y
    # Subject to:
    #   3x + 1y >= 90   (antioxidants)
    #   5x + 7y >= 100  (minerals)
    #   y >= 3x         (strawberries at least 3 times blueberries)
    #   x >= 0, y >= 0
    #
    # We'll find the intersection points of constraint boundaries and
    # check feasibility and objective value at each candidate.
    
    def is_feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 3*x + y < 90:
            return False
        if 5*x + 7*y < 100:
            return False
        if y < 3*x:
            return False
        return True

    def obj(x, y):
        return 5*x + 7*y

    candidates = []

    # 1) Intersection of 3x + y = 90 and 5x + 7y = 100
    # Solve:
    #   3x + y = 90  -> y = 90 - 3x
    #   5x + 7(90 - 3x) = 100
    #   5x + 630 - 21x = 100
    #   -16x = -530 -> x = 530/16
    x1 = 530.0 / 16.0
    y1 = 90.0 - 3.0 * x1
    candidates.append((x1, y1))

    # 2) Intersection of 3x + y = 90 and y = 3x
    #   3x + 3x = 90 -> 6x = 90 -> x = 15, y = 45
    x2, y2 = 15.0, 45.0
    candidates.append((x2, y2))

    # 3) Intersection of 5x + 7y = 100 and y = 3x
    #   5x + 7(3x) = 100 -> 5x + 21x = 100 -> 26x = 100 -> x = 100/26
    x3 = 100.0 / 26.0
    y3 = 3.0 * x3
    candidates.append((x3, y3))

    # 4) Intersections with axes where possible:
    #    a) x = 0 with constraints:
    #       3*0 + y >= 90 -> y >= 90
    #       5*0 + 7y >= 100 -> y >= 100/7
    #       y >= 3*0 -> y >= 0
    #       So minimal y on x=0 is y = 90
    x4, y4 = 0.0, 90.0
    candidates.append((x4, y4))

    #    b) y = 0 with constraints:
    #       3x >= 90 -> x >= 30
    #       5x >= 100 -> x >= 20
    #       0 >= 3x -> x <= 0
    #       No feasible point with y=0, so skip.

    best_val = None
    for x, y in candidates:
        if is_feasible(x, y):
            val = obj(x, y)
            if best_val is None or val < best_val:
                best_val = val

    # Return the optimal objective value (grams of sugar)
    return float(best_val)
```",390.0,True,0.0,0.0,3.540369749069214,
84,81000.0,"```python
def solve():
    # We want to maximize: 5000*x1 + 8500*x2
    # Subject to:
    # 0 <= x1 <= 8
    # 0 <= x2 <= 6
    # x1 + x2 <= 12

    best_value = float('-inf')

    # Since constraints are small and integral, we can brute-force over integer values
    for x1 in range(0, 9):   # 0 to 8
        for x2 in range(0, 7):  # 0 to 6
            if x1 + x2 <= 12:
                value = 5000 * x1 + 8500 * x2
                if value > best_value:
                    best_value = value

    return float(best_value)
```",81000.0,True,0.0,0.0,1.631826400756836,
85,72.0,"```python
def solve():
    # Let x = number of turkey dinners
    #     y = number of tuna sandwiches
    #
    # Constraints:
    # 1) Protein: 20x + 18y >= 150
    # 2) Carbs:   30x + 25y >= 200
    # 3) At most 40% turkey: x <= 0.4(x + y)
    #    => x <= 0.4x + 0.4y
    #    => 0.6x <= 0.4y
    #    => 3x <= 2y
    #    => y >= 1.5x
    # 4) x, y >= 0
    #
    # Objective: minimize fat = 12x + 8y
    #
    # This is a 2-variable LP; we can solve by checking all corner points
    # formed by intersections of the constraint boundaries.
    #
    # We'll systematically compute candidate points and pick the best feasible one.

    import math

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 20 * x + 18 * y < 150 - 1e-9:
            return False
        if 30 * x + 25 * y < 200 - 1e-9:
            return False
        if 3 * x - 2 * y > 1e-9:  # 3x <= 2y
            return False
        return True

    # Helper to compute objective
    def objective(x, y):
        return 12 * x + 8 * y

    candidates = []

    # 1) Intersection of protein and carb constraints:
    #    20x + 18y = 150
    #    30x + 25y = 200
    # Solve the 2x2 system:
    # From first: 20x = 150 - 18y => x = (150 - 18y)/20
    # Substitute into second:
    # 30*(150 - 18y)/20 + 25y = 200
    # Simplify:
    # (4500 - 540y)/20 + 25y = 200
    # 4500/20 - 540y/20 + 25y = 200
    # 225 - 27y + 25y = 200
    # 225 - 2y = 200
    # -2y = -25 => y = 12.5
    # x = (150 - 18*12.5)/20 = (150 - 225)/20 = -75/20 = -3.75 (infeasible due to x<0)
    x = -3.75
    y = 12.5
    candidates.append((x, y))

    # 2) Intersection of protein and turkey-ratio (y = 1.5x):
    #    20x + 18y = 150
    #    y = 1.5x
    # => 20x + 18*(1.5x) = 150
    # => 20x + 27x = 150
    # => 47x = 150 => x = 150/47, y = 1.5 * 150/47
    x = 150.0 / 47.0
    y = 1.5 * x
    candidates.append((x, y))

    # 3) Intersection of carb and turkey-ratio (y = 1.5x):
    #    30x + 25y = 200
    #    y = 1.5x
    # => 30x + 25*(1.5x) = 200
    # => 30x + 37.5x = 200
    # => 67.5x = 200 => x = 200/67.5, y = 1.5 * 200/67.5
    x = 200.0 / 67.5
    y = 1.5 * x
    candidates.append((x, y))

    # 4) Intersections with axes and ratio constraint:
    #    With x = 0:
    #       Protein: 18y >= 150 => y >= 150/18
    #       Carbs:   25y >= 200 => y >= 200/25 = 8
    #       Ratio:   3*0 <= 2y => always true
    #    So minimal y on x=0 is max(150/18, 8)
    y = max(150.0 / 18.0, 8.0)
    x = 0.0
    candidates.append((x, y))

    #    With y = 0:
    #       Protein: 20x >= 150 => x >= 150/20
    #       Carbs:   30x >= 200 => x >= 200/30
    #       Ratio:   3x <= 0 => x <= 0
    #    So only possible is x=0, but then protein and carbs not satisfied.
    x = 0.0
    y = 0.0
    candidates.append((x, y))

    # 5) Intersection of protein and carb with y = 1.5x already considered.
    # No other linear constraints to combine.

    best_val = math.inf
    for x, y in candidates:
        if feasible(x, y):
            val = objective(x, y)
            if val < best_val:
                best_val = val

    # Return the optimal objective value as float
    return float(best_val)
```",66.66666666666667,False,5.333333333333329,0.0740740740730452,7.078982830047607,
86,4000000.0,"```python
def solve():
    # We solve the LP by enumerating all basic feasible solutions (BFS)
    # for the 3-variable problem:
    #
    # Variables: x = z-tube ads, y = soorchle ads, z = wassa ads
    #
    # Maximize viewers:
    #   maximize 400000 x + 5000 y + 3000 z
    #
    # Subject to:
    #   (1) Budget: 1000 x + 200 y + 100 z <= 10000
    #   (2) Soorchle limit: y <= 15
    #   (3) Wassa balance: z <= (x + y + z)/3  ->  2z <= x + y  ->  2z - x - y <= 0
    #   (4) Z-tube minimum: x >= 0.05 (x + y + z)
    #       -> 20x >= x + y + z -> 19x - y - z >= 0
    #   (5) x, y, z >= 0
    #
    # We convert inequalities to equalities by considering them active (tight)
    # in combinations of 3 constraints (since we have 3 variables) and solve.
    #
    # Constraints in standard form (<= or >=):
    #   C1: 1000x + 200y + 100z <= 10000
    #   C2: y <= 15
    #   C3: 2z - x - y <= 0
    #   C4: 19x - y - z >= 0
    #   C5: x >= 0
    #   C6: y >= 0
    #   C7: z >= 0
    #
    # We'll treat each as an equality when ""active"":
    #   E1: 1000x + 200y + 100z = 10000
    #   E2: y = 15
    #   E3: 2z - x - y = 0
    #   E4: 19x - y - z = 0
    #   E5: x = 0
    #   E6: y = 0
    #   E7: z = 0
    #
    # Then check feasibility against all original inequalities and nonnegativity.

    import itertools

    # Each constraint as (A_row, b, sense)
    # sense: '<=' or '>='
    constraints = [
        ([1000.0, 200.0, 100.0], 10000.0, ""<=""),  # C1
        ([0.0, 1.0, 0.0], 15.0, ""<=""),           # C2
        ([-1.0, -1.0, 2.0], 0.0, ""<=""),          # C3: -x - y + 2z <= 0
        ([19.0, -1.0, -1.0], 0.0, "">=""),         # C4
        ([1.0, 0.0, 0.0], 0.0, "">=""),            # C5: x >= 0
        ([0.0, 1.0, 0.0], 0.0, "">=""),            # C6: y >= 0
        ([0.0, 0.0, 1.0], 0.0, "">=""),            # C7: z >= 0
    ]

    # Corresponding equalities when active
    equalities = [
        ([1000.0, 200.0, 100.0], 10000.0),  # E1
        ([0.0, 1.0, 0.0], 15.0),           # E2
        ([-1.0, -1.0, 2.0], 0.0),          # E3
        ([19.0, -1.0, -1.0], 0.0),         # E4
        ([1.0, 0.0, 0.0], 0.0),            # E5
        ([0.0, 1.0, 0.0], 0.0),            # E6
        ([0.0, 0.0, 1.0], 0.0),            # E7
    ]

    def solve_3x3(A, b):
        # Solve A x = b for 3x3 using Cramer's rule or Gaussian elimination.
        # A is 3x3 list of lists, b is length-3 list.
        # Return (x0, x1, x2) or None if singular.
        # We'll use a simple Gaussian elimination with partial pivoting.
        M = [A[0][:] + [b[0]], A[1][:] + [b[1]], A[2][:] + [b[2]]]

        # Forward elimination
        for col in range(3):
            # Pivot
            pivot_row = max(range(col, 3), key=lambda r: abs(M[r][col]))
            if abs(M[pivot_row][col]) < 1e-9:
                return None
            if pivot_row != col:
                M[col], M[pivot_row] = M[pivot_row], M[col]
            # Eliminate
            for r in range(col + 1, 3):
                factor = M[r][col] / M[col][col]
                for c in range(col, 4):
                    M[r][c] -= factor * M[col][c]

        # Back substitution
        x = [0.0, 0.0, 0.0]
        for i in reversed(range(3)):
            if abs(M[i][i]) < 1e-9:
                return None
            s = M[i][3]
            for j in range(i + 1, 3):
                s -= M[i][j] * x[j]
            x[i] = s / M[i][i]
        return x

    def is_feasible(x, y, z):
        # Check all constraints
        vals = [x, y, z]
        for (A, b, sense) in constraints:
            lhs = A[0] * vals[0] + A[1] * vals[1] + A[2] * vals[2]
            if sense == ""<="":
                if lhs - b > 1e-6:
                    return False
            else:  # "">=""
                if b - lhs > 1e-6:
                    return False
        return True

    best_val = float(""-inf"")

    # Enumerate all combinations of 3 active constraints (indices 0..6)
    for combo in itertools.combinations(range(7), 3):
        A = []
        b = []
        for idx in combo:
            row, rhs = equalities[idx]
            A.append(row)
            b.append(rhs)
        sol = solve_3x3(A, b)
        if sol is None:
            continue
        x, y, z = sol
        if not is_feasible(x, y, z):
            continue
        # Objective: 400000 x + 5000 y + 3000 z
        val = 400000.0 * x + 5000.0 * y + 3000.0 * z
        if val > best_val:
            best_val = val

    return float(best_val)
```",4000000.0,True,0.0,0.0,10.343703985214233,
87,1080.0,"```python
def solve():
    # Let x = number of circular tables
    #     y = number of rectangular tables
    #
    # Maximize guests: 8x + 12y
    #
    # Subject to:
    # Participants: 5x + 4y >= 500
    # Poster boards: 4x + 4y >= 300  -> x + y >= 75
    # Space: 15x + 20y <= 1900
    # x, y >= 0 and (implicitly) integers (tables)
    #
    # We'll brute-force over integer x, y in a reasonable range.

    best_value = float('-inf')

    # Upper bounds: from space constraint
    # 15x <= 1900 -> x <= 126.66..., so x up to 126
    # 20y <= 1900 -> y <= 95
    for x in range(0, 127):
        for y in range(0, 96):
            # Check constraints
            if 5 * x + 4 * y < 500:
                continue
            if x + y < 75:
                continue
            if 15 * x + 20 * y > 1900:
                continue

            value = 8 * x + 12 * y
            if value > best_value:
                best_value = value

    return float(best_value)
```",1080.0,True,0.0,0.0,2.5230965614318848,
88,32.0,"```python
def solve():
    # We need to minimize total trips T = f + r
    # Subject to:
    # 1) Capacity: 20f + 15r >= 500
    # 2) Light rail constraint: r >= 4f
    # 3) f, r >= 0 and integer (trips)
    #
    # We'll brute force over a reasonable range of ferry trips f.
    # Since each ferry carries 20 boxes, even if all were ferries:
    # 20f >= 500 -> f >= 25. So f in [0, 25] is enough to cover all possibilities.
    
    best_trips = None
    
    for f in range(0, 26):
        # r must be at least 4f
        r_min = 4 * f
        
        # Also must satisfy capacity: 20f + 15r >= 500
        # => 15r >= 500 - 20f
        # => r >= (500 - 20f) / 15
        if 20 * f < 500:
            # Need some r to meet capacity
            required_r = (500 - 20 * f + 14) // 15  # ceiling division
            # r must satisfy both constraints
            r = max(r_min, required_r)
        else:
            # Capacity already satisfied by ferries alone
            r = r_min
        
        # Compute total trips
        total_trips = f + r
        
        # Update best solution
        if best_trips is None or total_trips < best_trips:
            best_trips = total_trips
    
    # Return the optimal objective value as float
    return float(best_trips)
```",32.0,True,0.0,0.0,3.227043390274048,
89,810.0,"```python
def solve():
    # Let x = number of small bones, y = number of large bones.
    # Constraints:
    # 1) Tooth medication: 10x + 15y <= 2000
    # 2) At least 50% small: x >= y
    # 3) At least 30 large: y >= 30
    # Objective: minimize meat = 12x + 15y
    
    # This is a small 2-variable LP; we can solve analytically by checking corner points.
    
    best_value = None
    
    # The feasible region is defined by:
    # y in [30, 2000/15], and for each y:
    #   x in [y, (2000 - 15y)/10]
    # We search over integer y and x (bones must be integer).
    
    # Upper bound for y from tooth constraint: 15y <= 2000 -> y <= 133.33...
    max_y = int(2000 // 15)
    
    for y in range(30, max_y + 1):
        # Max x from tooth constraint
        max_x = (2000 - 15 * y) // 10
        min_x = y  # from x >= y
        
        if min_x > max_x:
            continue  # no feasible x for this y
        
        # Since objective is increasing in both x and y (positive coefficients),
        # for fixed y, we want the smallest feasible x, i.e., x = min_x.
        x = min_x
        
        meat = 12 * x + 15 * y
        
        if best_value is None or meat < best_value:
            best_value = meat
    
    # Return the optimal objective value as float
    return float(best_value)
```",810.0,True,0.0,0.0,4.901472091674805,
90,160.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 12x + 10y
    # Subject to:
    # 10x +  8y >= 130   (fat)
    # 300x + 250y >= 3000 (calories)
    # y >= 2x            (at least twice as many slices of pizza as burgers)
    # x >= 0, y >= 0
    
    # We'll solve analytically by checking all candidate corner points of the feasible region.
    # Constraints in standard form:
    # (1) 10x + 8y >= 130
    # (2) 300x + 250y >= 3000
    # (3) y - 2x >= 0
    # (4) x >= 0
    # (5) y >= 0
    
    # Candidate corners come from intersections of pairs of constraint boundaries.
    # We'll compute intersections and then keep only feasible ones, then evaluate objective.
    
    candidates = []
    
    def add_if_feasible(x, y):
        eps = 1e-9
        if x >= -eps and y >= -eps \
           and 10*x + 8*y >= 130 - eps \
           and 300*x + 250*y >= 3000 - eps \
           and y - 2*x >= -eps:
            candidates.append((max(x, 0.0), max(y, 0.0)))
    
    # 1) Intersection of fat and calories:
    # 10x + 8y = 130
    # 300x + 250y = 3000
    # Solve:
    # From first: x = (130 - 8y)/10
    # Plug into second:
    # 300*(130 - 8y)/10 + 250y = 3000
    # 30*(130 - 8y) + 250y = 3000
    # 3900 - 240y + 250y = 3000
    # 3900 + 10y = 3000 -> 10y = -900 -> y = -90 (infeasible, but we still compute)
    y = -90.0
    x = (130 - 8*y) / 10.0
    add_if_feasible(x, y)
    
    # 2) Intersection of fat and y = 2x:
    # 10x + 8y = 130
    # y = 2x
    # 10x + 8*(2x) = 130 -> 10x + 16x = 130 -> 26x = 130 -> x = 5, y = 10
    x = 5.0
    y = 10.0
    add_if_feasible(x, y)
    
    # 3) Intersection of calories and y = 2x:
    # 300x + 250y = 3000
    # y = 2x
    # 300x + 250*(2x) = 3000 -> 300x + 500x = 3000 -> 800x = 3000 -> x = 3.75, y = 7.5
    x = 3000.0 / 800.0
    y = 2.0 * x
    add_if_feasible(x, y)
    
    # 4) Intersection of fat and x = 0:
    # 10*0 + 8y = 130 -> y = 16.25
    x = 0.0
    y = 130.0 / 8.0
    add_if_feasible(x, y)
    
    # 5) Intersection of calories and x = 0:
    # 300*0 + 250y = 3000 -> y = 12
    x = 0.0
    y = 3000.0 / 250.0
    add_if_feasible(x, y)
    
    # 6) Intersection of fat and y = 0:
    # 10x + 8*0 = 130 -> x = 13
    x = 130.0 / 10.0
    y = 0.0
    add_if_feasible(x, y)
    
    # 7) Intersection of calories and y = 0:
    # 300x + 250*0 = 3000 -> x = 10
    x = 3000.0 / 300.0
    y = 0.0
    add_if_feasible(x, y)
    
    # 8) Intersection of y = 2x and x = 0 -> (0,0)
    x = 0.0
    y = 0.0
    add_if_feasible(x, y)
    
    # Now evaluate objective 12x + 10y at all feasible candidates
    best_val = float('inf')
    for x, y in candidates:
        val = 12.0 * x + 10.0 * y
        if val < best_val:
            best_val = val
    
    # best_val is the minimal cholesterol intake
    return float(best_val)
```",160.0,True,0.0,0.0,5.32699179649353,
91,230.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 20T + 15C
    # Subject to:
    # 1) 50T + 30C >= 500        (packages)
    # 2) T <= 5                  (max truck trips)
    # 3) C >= (3/7) * T          (at least 30% of trips are by car: C >= 0.3(T + C))
    # 4) T >= 0, C >= 0

    best_val = float('inf')

    # We'll search over T in a fine grid between 0 and 5 (inclusive),
    # and for each T compute the minimal feasible C, then evaluate the objective.
    # This is sufficient for this small problem and avoids external solvers.

    steps = 10000  # fine grid for T in [0,5]
    for i in range(steps + 1):
        T = 5.0 * i / steps

        # From package constraint: 50T + 30C >= 500 -> C >= (500 - 50T)/30
        C_min_pkg = max(0.0, (500.0 - 50.0 * T) / 30.0)

        # From car-trip fraction: C >= (3/7) T
        C_min_frac = (3.0 / 7.0) * T

        C = max(C_min_pkg, C_min_frac)

        # Check feasibility: T <= 5 is already enforced by grid, C >= 0 by construction
        # Also need to ensure package constraint is satisfied numerically:
        if 50.0 * T + 30.0 * C + 1e-9 < 500.0:
            continue

        val = 20.0 * T + 15.0 * C
        if val < best_val:
            best_val = val

    return best_val
```",225.0,False,5.0,0.021739130434688093,3.1933577060699463,
92,24.0,"```python
def solve():
    # We model:
    # x = number of helicopter trips (integer, >= 0)
    # y = number of bus trips (integer, >= 0)
    #
    # Constraints:
    # 1) Patient requirement: 5x + 8y >= 120
    # 2) At least 30% of trips by helicopter: x >= 0.3(x + y)
    #    => 0.7x >= 0.3y => 7x >= 3y
    # 3) At most 10 bus trips: y <= 10
    #
    # Objective: minimize total time T = 1*x + 3*y
    
    best_time = None
    
    # Since y <= 10 and x must be enough to carry patients, we can brute force
    for y in range(0, 11):  # y from 0 to 10 inclusive
        # From 7x >= 3y => x >= 3y/7
        min_x_from_ratio = (3 * y + 6) // 7  # ceil(3y/7)
        
        # From 5x + 8y >= 120 => x >= (120 - 8y)/5
        if 5 * 0 + 8 * y >= 120:
            min_x_from_patients = 0
        else:
            # ceil((120 - 8y)/5)
            num = 120 - 8 * y
            min_x_from_patients = (num + 4) // 5
        
        x = max(min_x_from_ratio, min_x_from_patients)
        
        # Ensure nonnegative
        if x < 0:
            continue
        
        # Check constraints explicitly
        if 5 * x + 8 * y < 120:
            continue
        if 7 * x < 3 * y:
            continue
        if y > 10:
            continue
        
        time = x + 3 * y
        if best_time is None or time < best_time:
            best_time = time
    
    # Return the optimal objective value as float
    return float(best_time)
```",24.0,True,0.0,0.0,3.2611734867095947,
93,2480.0,"```python
def solve():
    # We maximize 50x + 80y
    # Subject to:
    # 3x + 5y <= 150
    # x >= 3y
    # y >= 6
    # x >= 10
    # x, y >= 0 (implicitly)
    #
    # We'll search over integer y and compute feasible x from constraints.

    best_value = float('-inf')

    # Upper bound for y from employee constraint: 5y <= 150 -> y <= 30
    for y in range(6, 31):  # y >= 6
        # From 3x + 5y <= 150 -> x <= (150 - 5y)/3
        max_x_emp = (150 - 5 * y) // 3
        if max_x_emp < 0:
            continue

        # From x >= 3y and x >= 10
        min_x = max(3 * y, 10)

        if min_x > max_x_emp:
            continue

        # Objective increases with x (50 per small team), so take largest feasible x
        x = max_x_emp

        value = 50 * x + 80 * y
        if value > best_value:
            best_value = value

    return float(best_value)
```",2480.0,True,0.0,0.0,2.4404029846191406,
94,310.0,"```python
def solve():
    # We solve the LP:
    # Maximize 8x + 10y
    # subject to:
    # 3x + 4y <= 120  (wood)
    # 3x + 2y <= 90   (paint)
    # x, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) Intersection with axes:
    #    a) x-axis (y=0):
    #       3x <= 120 -> x <= 40
    #       3x <= 90  -> x <= 30
    #       So (30, 0)
    #    b) y-axis (x=0):
    #       4y <= 120 -> y <= 30
    #       2y <= 90  -> y <= 45
    #       So (0, 30)
    #
    # 2) Intersection of the two constraints:
    #    3x + 4y = 120
    #    3x + 2y = 90
    # Subtract second from first:
    #    2y = 30 -> y = 15
    # Plug into 3x + 2y = 90:
    #    3x + 30 = 90 -> 3x = 60 -> x = 20
    # So (20, 15)
    
    candidates = [(30.0, 0.0), (0.0, 30.0), (20.0, 15.0)]
    
    best_value = float('-inf')
    for x, y in candidates:
        value = 8.0 * x + 10.0 * y
        if value > best_value:
            best_value = value
    
    return best_value
```",310.0,True,0.0,0.0,2.843336820602417,
95,300.0,"```python
def solve():
    # Let x = number of subsoil bags
    #     y = number of topsoil bags
    #
    # Minimize water: 10x + 6y
    #
    # Constraints:
    # 1) x + y <= 150          (truck capacity)
    # 2) y >= 10               (at least 10 topsoil)
    # 3) y <= 0.3(x + y)       (at most 30% topsoil)
    #    => y <= 0.3x + 0.3y
    #    => 0.7y <= 0.3x
    #    => y <= (3/7)x
    # 4) x >= 0, y >= 0
    #
    # Since subsoil uses more water per bag (10) than topsoil (6),
    # to minimize water we want as many topsoil bags as allowed by constraints.
    #
    # From y <= (3/7)x and x + y <= 150, and y >= 10:
    # We search feasible corner points:
    # A: y = 10, x + y = 150 -> x = 140
    #    Check y <= (3/7)x: 10 <= (3/7)*140 = 60  -> OK
    #
    # B: y = (3/7)x and x + y = 150:
    #    x + (3/7)x = 150 -> (10/7)x = 150 -> x = 105, y = 45
    #    Check y >= 10 -> OK
    #
    # C: y = 10 and y = (3/7)x:
    #    10 = (3/7)x -> x = 70/3, then x + y = 70/3 + 10 = 100/3 < 150
    #    So capacity not binding; this point is feasible.
    #
    # Evaluate objective at these candidates:
    # A: 10*140 + 6*10 = 1400 + 60 = 1460
    # B: 10*105 + 6*45 = 1050 + 270 = 1320
    # C: 10*(70/3) + 6*10 = 700/3 + 60 = 880/3 â‰ˆ 293.33
    #
    # C has the smallest value and is feasible, so it's optimal.
    #
    # Return the optimal objective value as float:
    return 880.0 / 3.0
```",293.3333333333333,False,6.666666666666686,0.022222222222148213,4.039320945739746,
96,22.0,"```python
def solve():
    # We solve the LP:
    # Minimize:  3x + 2y
    # Subject to:
    #   300x + 200y >= 2200   (calories)
    #   4.5x + 4y   >= 30     (protein)
    #   x, y >= 0
    #
    # The optimum for a 2-variable LP with >= constraints and positive costs
    # will occur at a corner point of the feasible region.
    #
    # Candidate corner points come from:
    # 1) Intersection of the two constraint lines
    # 2) Intersection of each constraint with axes (x=0 or y=0), if feasible.
    
    # 1) Intersection of:
    #   300x + 200y = 2200
    #   4.5x + 4y   = 30
    #
    # Solve analytically:
    # From second: 4.5x + 4y = 30
    # Express y = (30 - 4.5x)/4
    # Substitute into first:
    #   300x + 200 * ((30 - 4.5x)/4) = 2200
    #   300x + 50 * (30 - 4.5x) = 2200
    #   300x + 1500 - 225x = 2200
    #   75x = 700
    #   x = 700/75
    x_inter = 700.0 / 75.0
    # y from protein constraint:
    y_inter = (30.0 - 4.5 * x_inter) / 4.0

    # 2) Intersections with axes:
    # x = 0:
    #   300*0 + 200y >= 2200 -> y >= 11
    #   4.5*0 + 4y   >= 30   -> y >= 7.5
    # So y >= 11, candidate point (0, 11)
    x_axis1, y_axis1 = 0.0, 11.0

    # y = 0:
    #   300x >= 2200 -> x >= 2200/300
    #   4.5x >= 30   -> x >= 30/4.5
    # So x >= max(2200/300, 30/4.5)
    x_req_cal = 2200.0 / 300.0
    x_req_pro = 30.0 / 4.5
    x_axis2 = max(x_req_cal, x_req_pro)
    y_axis2 = 0.0

    # Collect candidate points that satisfy all constraints
    candidates = []

    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 300.0 * x + 200.0 * y < 2200.0 - 1e-9:
            return False
        if 4.5 * x + 4.0 * y < 30.0 - 1e-9:
            return False
        return True

    # Add intersection point if feasible
    if feasible(x_inter, y_inter):
        candidates.append((x_inter, y_inter))

    # Add axis intersection points if feasible
    if feasible(x_axis1, y_axis1):
        candidates.append((x_axis1, y_axis1))
    if feasible(x_axis2, y_axis2):
        candidates.append((x_axis2, y_axis2))

    # Compute objective 3x + 2y for all candidates and take minimum
    best_val = float(""inf"")
    for x, y in candidates:
        cost = 3.0 * x + 2.0 * y
        if cost < best_val:
            best_val = cost

    return best_val
```",22.0,True,0.0,0.0,5.020780801773071,
97,175.0,"```python
def solve():
    # We want to minimize pollution:
    # Let x = number of hot-air balloon rides (integer, 0 <= x <= 10)
    # Let y = number of gondola lift rides (integer, y >= 0)
    #
    # Constraints:
    # 4x + 6y >= 70  (visitor capacity)
    # Objective: minimize 10x + 15y
    
    best_value = None
    
    for x in range(0, 11):  # x can be 0 to 10
        # Need 4x + 6y >= 70  =>  6y >= 70 - 4x  =>  y >= (70 - 4x)/6
        required_y = (70 - 4 * x) / 6.0
        if required_y <= 0:
            y = 0
        else:
            # y must be integer, so take ceiling
            y = int(required_y)
            if y < required_y:
                y += 1
        
        # Check feasibility
        if 4 * x + 6 * y >= 70 and x <= 10 and x >= 0 and y >= 0:
            pollution = 10 * x + 15 * y
            if best_value is None or pollution < best_value:
                best_value = pollution
    
    return float(best_value)
```",175.0,True,0.0,0.0,1.9499552249908447,
98,30.0,"```python
def solve():
    # We want to minimize total vehicles: x + y
    # Subject to:
    # 1) 12x + 18y >= 400
    # 2) x >= 0.7(x + y)  ->  0.3x >= 0.7y  ->  3x >= 7y  ->  x >= (7/3)*y
    # 3) x, y >= 0 and integers (implicitly, since vehicles are discrete)
    #
    # We'll brute force over a reasonable range of y (buses), compute the minimum
    # feasible x for each y, and track the combination with minimal x + y.
    
    best_value = None  # minimal total vehicles
    best_x = None
    best_y = None
    
    # Upper bound for y: if all were buses, 400/18 â‰ˆ 22.23, so y <= 23 is enough
    for y in range(0, 50):  # 50 is a safe upper bound
        # From x >= (7/3)*y
        x_min_ratio = (7 * y + 2) // 3  # ceil(7y/3) = (7y + 2)//3 for integers
        
        # From 12x + 18y >= 400  ->  x >= (400 - 18y)/12
        rhs = 400 - 18 * y
        if rhs <= 0:
            x_min_capacity = 0
        else:
            # ceil(rhs/12)
            x_min_capacity = (rhs + 11) // 12
        
        x = max(x_min_ratio, x_min_capacity)
        
        # Check feasibility (nonnegative x)
        if x < 0:
            continue
        
        total = x + y
        if best_value is None or total < best_value:
            best_value = total
            best_x = x
            best_y = y
    
    # The problem asks for the optimal objective value (minimal total vehicles).
    # Return it as a float.
    return float(best_value)
```",30.0,True,0.0,0.0,3.1728687286376953,
99,342750.0,"```python
def solve():
    # We solve the LP:
    # Maximize 150x + 300y
    # subject to:
    # 4x + 2y <= 4000   (slicer)
    # 2.5x + 3.5y <= 4000 (packer)
    # x, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) Axes:
    #    x = 0:
    #       2y <= 4000  -> y <= 2000
    #       3.5y <= 4000 -> y <= 4000/3.5
    #       So y = min(2000, 4000/3.5)
    y_x0 = min(4000/2.0, 4000/3.5)
    x0_y = 0.0
    
    #    y = 0:
    #       4x <= 4000   -> x <= 1000
    #       2.5x <= 4000 -> x <= 1600
    #       So x = min(1000, 1600)
    x_y0 = min(4000/4.0, 4000/2.5)
    y0_x = 0.0
    
    # 2) Intersection of the two constraints:
    #    4x + 2y = 4000
    #    2.5x + 3.5y = 4000
    #
    # Solve the system:
    # From first: 2y = 4000 - 4x -> y = 2000 - 2x
    # Plug into second:
    # 2.5x + 3.5(2000 - 2x) = 4000
    # 2.5x + 7000 - 7x = 4000
    # -4.5x = -3000
    # x = 3000 / 4.5
    x_int = 3000.0 / 4.5
    y_int = 2000.0 - 2.0 * x_int
    
    # Collect feasible corner points
    points = [
        (0.0, y_x0),
        (x_y0, 0.0),
        (x_int, y_int)
    ]
    
    # Filter only feasible points (satisfying constraints and nonnegative)
    feasible_points = []
    for x, y in points:
        if x >= 0 and y >= 0:
            if 4*x + 2*y <= 4000 + 1e-9 and 2.5*x + 3.5*y <= 4000 + 1e-9:
                feasible_points.append((x, y))
    
    # Evaluate objective at feasible points
    best_value = float('-inf')
    for x, y in feasible_points:
        value = 150*x + 300*y
        if value > best_value:
            best_value = value
    
    return best_value
```",342857.14285714284,False,107.14285714284051,0.00031259768677706844,3.077794075012207,
100,30000.0,"```python
def solve():
    # We solve the LP:
    # Maximize 500x + 650y
    # Subject to:
    # 1) x + y <= 50
    # 2) x >= 12
    # 3) y >= 15
    # 4) y >= x        (more cucumbers than potatoes)
    # 5) y <= 2x       (at most twice cucumbers as potatoes)
    #
    # We'll find all candidate vertices by intersecting constraint boundaries
    # and then check feasibility and objective value.

    import math

    # Represent constraints as functions to check feasibility
    def feasible(x, y):
        eps = 1e-9
        if x + y > 50 + eps:
            return False
        if x < 12 - eps:
            return False
        if y < 15 - eps:
            return False
        if y < x - eps:
            return False
        if y > 2 * x + eps:
            return False
        return True

    # List of boundary lines as (type, params)
    # We'll intersect each pair of boundaries.
    # Boundaries:
    # B1: x + y = 50
    # B2: x = 12
    # B3: y = 15
    # B4: y = x
    # B5: y = 2x
    #
    # We'll encode them and write a small solver for pairwise intersections.

    def intersect(b1, b2):
        # Each boundary is a string label; we solve analytically.
        # Return (x, y) or None if parallel/inconsistent.
        if b1 == ""x+y=50"" and b2 == ""x=12"" or b2 == ""x+y=50"" and b1 == ""x=12"":
            x = 12.0
            y = 50.0 - x
            return (x, y)
        if b1 == ""x+y=50"" and b2 == ""y=15"" or b2 == ""x+y=50"" and b1 == ""y=15"":
            y = 15.0
            x = 50.0 - y
            return (x, y)
        if b1 == ""x+y=50"" and b2 == ""y=x"" or b2 == ""x+y=50"" and b1 == ""y=x"":
            # x + x = 50
            x = 25.0
            y = 25.0
            return (x, y)
        if b1 == ""x+y=50"" and b2 == ""y=2x"" or b2 == ""x+y=50"" and b1 == ""y=2x"":
            # x + 2x = 50
            x = 50.0 / 3.0
            y = 2.0 * x
            return (x, y)
        if b1 == ""x=12"" and b2 == ""y=15"" or b2 == ""x=12"" and b1 == ""y=15"":
            return (12.0, 15.0)
        if b1 == ""x=12"" and b2 == ""y=x"" or b2 == ""x=12"" and b1 == ""y=x"":
            return (12.0, 12.0)
        if b1 == ""x=12"" and b2 == ""y=2x"" or b2 == ""x=12"" and b1 == ""y=2x"":
            return (12.0, 24.0)
        if b1 == ""y=15"" and b2 == ""y=x"" or b2 == ""y=15"" and b1 == ""y=x"":
            return (15.0, 15.0)
        if b1 == ""y=15"" and b2 == ""y=2x"" or b2 == ""y=15"" and b1 == ""y=2x"":
            # 15 = 2x
            x = 7.5
            y = 15.0
            return (x, y)
        if b1 == ""y=x"" and b2 == ""y=2x"" or b2 == ""y=x"" and b1 == ""y=2x"":
            # x = 2x -> x=0
            x = 0.0
            y = 0.0
            return (x, y)
        return None

    boundaries = [""x+y=50"", ""x=12"", ""y=15"", ""y=x"", ""y=2x""]

    candidates = []

    # Pairwise intersections
    for i in range(len(boundaries)):
        for j in range(i + 1, len(boundaries)):
            pt = intersect(boundaries[i], boundaries[j])
            if pt is not None:
                candidates.append(pt)

    # Also consider points where a single boundary meets implicit bounds,
    # but here all relevant vertices come from pairwise intersections.

    best_val = -math.inf
    for (x, y) in candidates:
        if feasible(x, y):
            val = 500.0 * x + 650.0 * y
            if val > best_val:
                best_val = val

    return best_val
```",30000.0,True,0.0,0.0,6.348497152328491,
101,1366.6666666666667,"```python
def solve():
    # We solve the LP:
    # Minimize 300*x + 200*y
    # subject to:
    # 2x + 4y >= 10   (raspberries)
    # 2x + 1y >= 9    (blueberries)
    # 4x + 2y >= 15   (strawberries)
    # x, y >= 0
    #
    # We'll find the optimal solution by checking all corner points of the feasible region.
    # Corner points come from intersections of pairs of constraint lines and axes.

    import math

    def is_feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 2*x + 4*y < 10 - 1e-9:
            return False
        if 2*x + y < 9 - 1e-9:
            return False
        if 4*x + 2*y < 15 - 1e-9:
            return False
        return True

    def cost(x, y):
        return 300*x + 200*y

    candidates = []

    # Intersections of pairs of constraints:
    # 1) 2x + 4y = 10  and  2x + y = 9
    # From second: y = 9 - 2x
    # Substitute into first: 2x + 4(9 - 2x) = 10 -> 2x + 36 - 8x = 10 -> -6x = -26 -> x = 26/6
    x = 26.0 / 6.0
    y = 9.0 - 2.0 * x
    candidates.append((x, y))

    # 2) 2x + 4y = 10  and  4x + 2y = 15
    # Solve the system:
    # 2x + 4y = 10
    # 4x + 2y = 15
    # Multiply first by 2: 4x + 8y = 20
    # Subtract second: (4x+8y) - (4x+2y) = 20 - 15 -> 6y = 5 -> y = 5/6
    # Then 2x + 4*(5/6) = 10 -> 2x + 20/6 = 10 -> 2x = 10 - 20/6 = 40/6 -> x = 20/6
    x = 20.0 / 6.0
    y = 5.0 / 6.0
    candidates.append((x, y))

    # 3) 2x + y = 9  and  4x + 2y = 15
    # From second: 2x + y = 7.5
    # Compare with first: 2x + y = 9 -> inconsistent, no intersection.

    # Intersections with axes:
    # x = 0:
    #   2*0 + 4y >= 10 -> y >= 2.5
    #   2*0 + y >= 9   -> y >= 9
    #   4*0 + 2y >= 15 -> y >= 7.5
    # So y >= 9, minimal y is 9
    candidates.append((0.0, 9.0))

    # y = 0:
    #   2x >= 10 -> x >= 5
    #   2x >= 9  -> x >= 4.5
    #   4x >= 15 -> x >= 3.75
    # So x >= 5, minimal x is 5
    candidates.append((5.0, 0.0))

    best_val = math.inf
    for x, y in candidates:
        if is_feasible(x, y):
            c = cost(x, y)
            if c < best_val:
                best_val = c

    return float(best_val)
```",1366.6666666666667,True,0.0,0.0,4.143132448196411,
102,-99999.0,"```python
def solve():
    # We model:
    # x = number of manual slicers
    # y = number of automatic slicers
    #
    # Constraints:
    # 1) 5x + 8y >= 50   (slices per minute)
    # 2) 3x + 6y <= 35   (grease units per minute)
    # 3) x < y
    # 4) x, y >= 0 and integers
    #
    # Objective: minimize x + y
    
    best_value = None
    
    # Since 3x + 6y <= 35, we can bound x and y.
    # Max y occurs when x=0: 6y <= 35 -> y <= 5 (integer)
    # Max x occurs when y=0: 3x <= 35 -> x <= 11 (integer)
    # We'll brute force over this small range.
    
    for x in range(0, 12):      # 0 to 11
        for y in range(0, 6):   # 0 to 5
            # Check constraints
            if 5 * x + 8 * y < 50:
                continue
            if 3 * x + 6 * y > 35:
                continue
            if not (x < y):
                continue
            
            total = x + y
            if best_value is None or total < best_value:
                best_value = total
    
    # Return the minimal total number of slicers (objective value)
    return float(best_value if best_value is not None else 0.0)
```",0.0,False,99999.0,0.99999999999999,2.2088401317596436,
103,26.0,"```python
def solve():
    # We want to minimize total boxes: x + y
    # x = number of small boxes, y = number of large boxes
    # Constraints:
    # 1) 25x + 45y >= 750  (masks requirement)
    # 2) x >= 3y           (at least three times as many small as large)
    # 3) y >= 5            (at least 5 large boxes)
    # 4) x, y are nonnegative integers
    
    best_value = None
    
    # Since 45y <= 750 for feasible y (otherwise even with x=0 we'd exceed masks),
    # y is at most 750 // 45. We'll search over this small range.
    for y in range(5, 751 // 45 + 2):  # small safe upper bound
        # From x >= 3y and 25x + 45y >= 750:
        # x must satisfy both:
        #   x >= 3y
        #   25x >= 750 - 45y  -> x >= (750 - 45y)/25
        rhs = 750 - 45 * y
        if rhs <= 0:
            x_min_masks = 0
        else:
            # ceiling division for (750 - 45y)/25
            x_min_masks = (rhs + 25 - 1) // 25
        
        x_min = max(3 * y, x_min_masks)
        
        # Check feasibility
        if x_min < 0:
            continue
        
        # Compute objective
        total_boxes = x_min + y
        
        if best_value is None or total_boxes < best_value:
            best_value = total_boxes
    
    # Return the minimal total number of boxes as a float
    return float(best_value)
```",26.0,True,0.0,0.0,3.587074041366577,
104,571.0,"```python
def solve():
    # Let x = number of pill vaccines
    #     y = number of shot vaccines
    #
    # Maximize:  x + y
    # Subject to:
    #   10x + 20y <= 10000        (time constraint)
    #   y >= 3x                   (at least 3 times as many shots as pills)
    #   x >= 30                   (at least 30 pills)
    #   x, y >= 0
    #
    # From y >= 3x, to maximize x + y under the time constraint,
    # we should take y as small as allowed, i.e., y = 3x.
    #
    # Substitute into time constraint:
    #   10x + 20(3x) <= 10000
    #   10x + 60x <= 10000
    #   70x <= 10000
    #   x <= 10000 / 70
    #
    # Also x >= 30, so feasible x are in [30, 10000/70].
    # The objective with y = 3x is:
    #   x + y = x + 3x = 4x
    # which is increasing in x, so we take the largest feasible x:
    #
    #   x* = 10000 / 70
    #   y* = 3x*
    #   Objective = 4x* = 4 * (10000 / 70) = 40000 / 70 = 4000 / 7

    return 4000.0 / 7.0
```",571.4285714285714,False,0.4285714285714448,0.0007505629221903577,3.3795769214630127,
105,61875.0,"```python
def solve():
    # Let x = units of chemical A, y = units of chemical B
    # Objective: minimize total time = 30x + 45y
    # Constraints:
    # 1) x >= 300
    # 2) x + y >= 1500
    # 3) x <= (1/3) * y  ->  3x <= y
    # 4) x, y >= 0 (implied)
    #
    # The feasible region is a polygon; the optimum of a linear program
    # occurs at a vertex (intersection of constraint boundaries).
    #
    # Candidate vertices come from intersecting:
    #   a) x = 300 and x + y = 1500
    #   b) x = 300 and y = 3x
    #   c) x + y = 1500 and y = 3x
    #
    # We then check feasibility and compute the objective at each.

    candidates = []

    # a) x = 300, x + y = 1500 -> y = 1200
    x = 300.0
    y = 1500.0 - x
    if x >= 300 and x + y >= 1500 and 3 * x <= y and x >= 0 and y >= 0:
        candidates.append((x, y))

    # b) x = 300, y = 3x -> y = 900
    x = 300.0
    y = 3.0 * x
    if x >= 300 and x + y >= 1500 and 3 * x <= y and x >= 0 and y >= 0:
        candidates.append((x, y))

    # c) x + y = 1500, y = 3x -> x + 3x = 1500 -> x = 375, y = 1125
    x = 375.0
    y = 3.0 * x
    if x >= 300 and x + y >= 1500 and 3 * x <= y and x >= 0 and y >= 0:
        candidates.append((x, y))

    # Compute objective 30x + 45y for all feasible candidates
    best_value = None
    for x, y in candidates:
        value = 30.0 * x + 45.0 * y
        if best_value is None or value < best_value:
            best_value = value

    return best_value
```",61875.0,True,0.0,0.0,4.099398851394653,
106,166.66666666666669,"```python
def solve():
    # Let x = acres of apples, y = acres of pears
    # Constraints:
    # 1) x + y = 50 (all acres used; at optimum this will be tight)
    # 2) x >= 5
    # 3) y >= 10
    # 4) y > x (prefers more pears than apples; treat as y >= x for LP boundary)
    # 5) y <= 2x (at most twice as many pears as apples)
    #
    # Objective: maximize 2x + 4y
    
    # We solve analytically by checking corner points of the feasible region.
    # From x + y = 50, y = 50 - x.
    # Substitute into constraints:
    # x >= 5
    # 50 - x >= 10  -> x <= 40
    # 50 - x >= x   -> 50 >= 2x -> x <= 25
    # 50 - x <= 2x  -> 50 <= 3x -> x >= 50/3
    #
    # So x is in [max(5, 50/3), min(40, 25)] = [50/3, 25]
    # Objective: 2x + 4(50 - x) = 2x + 200 - 4x = 200 - 2x
    # This is decreasing in x, so maximize profit by minimizing x in the interval.
    # Minimum x = 50/3, then y = 50 - 50/3 = 100/3.
    #
    # Profit = 2x + 4y = 2*(50/3) + 4*(100/3) = 100/3 + 400/3 = 500/3.
    
    return 500.0 / 3.0
```",166.66666666666666,True,2.842170943040401e-14,1.7053025658140085e-16,3.3777356147766113,
107,4347.0,"```python
def solve():
    # Let T = number of throat swabs, N = number of nasal swabs
    # Objective: maximize number of patients = T + N
    # Constraints:
    # 1) Time: 5T + 3N <= 20000
    # 2) At least 30 nasal swabs: N >= 30
    # 3) At least 4 times as many throat as nasal: T >= 4N
    #
    # This is a linear program in two variables; we can solve it analytically.
    #
    # From T >= 4N, to maximize T + N under the time constraint, we will use
    # the minimum T allowed by that constraint for any fixed N, i.e. T = 4N.
    # Substitute into time constraint:
    #   5(4N) + 3N <= 20000
    #   20N + 3N <= 20000
    #   23N <= 20000
    #   N <= 20000 / 23
    #
    # Also N >= 30, so feasible N are in [30, 20000/23].
    # The objective with T = 4N is:
    #   T + N = 4N + N = 5N
    # which is increasing in N, so we take the largest feasible N:
    N = 20000.0 / 23.0
    T = 4.0 * N

    # The problem asks: ""how many of each swab should be done to maximize
    # the number of patients seen?"" but the instructions for this task say
    # the function should return the optimal objective value (number of patients).
    patients = T + N
    return float(patients)
```",4347.826086956522,False,0.8260869565219764,0.0001900361068603143,3.4840011596679688,
108,1500.0,"```python
def solve():
    # We solve the LP:
    # Minimize 300*x1 + 600*x2
    # s.t.
    #   5*x1 + 10*x2 >= 20   (black)
    #   6*x1 + 10*x2 >= 5    (white)
    #   3*x1 >= 15           (brown)
    #   x1, x2 >= 0
    #
    # This is a 2-variable LP; we can solve it analytically by checking
    # corner points of the feasible region.

    best = float('inf')

    # Helper to check feasibility and update best cost
    def check_point(x1, x2):
        nonlocal best
        if x1 < 0 or x2 < 0:
            return
        if 5*x1 + 10*x2 < 20:
            return
        if 6*x1 + 10*x2 < 5:
            return
        if 3*x1 < 15:
            return
        cost = 300*x1 + 600*x2
        if cost < best:
            best = cost

    # Candidate 1: intersection of brown and black constraints
    # 3*x1 = 15 -> x1 = 5
    # 5*x1 + 10*x2 = 20 -> 25 + 10*x2 = 20 -> x2 = -0.5 (infeasible due to x2>=0)
    # So we skip this as it will be caught by feasibility check:
    x1 = 5.0
    x2 = -0.5
    check_point(x1, x2)

    # Candidate 2: intersection of brown and white constraints
    # 3*x1 = 15 -> x1 = 5
    # 6*x1 + 10*x2 = 5 -> 30 + 10*x2 = 5 -> x2 = -2.5 (infeasible)
    x1 = 5.0
    x2 = -2.5
    check_point(x1, x2)

    # Candidate 3: intersection of black and white constraints
    # 5*x1 + 10*x2 = 20
    # 6*x1 + 10*x2 = 5
    # Subtract: (6x1+10x2) - (5x1+10x2) = 5 - 20 -> x1 = -15 (infeasible)
    x1 = -15.0
    # Solve for x2 from 5*x1 + 10*x2 = 20
    x2 = (20 - 5*x1) / 10.0
    check_point(x1, x2)

    # Candidate 4: intersection of brown constraint with x2 = 0
    # 3*x1 = 15 -> x1 = 5
    x1 = 5.0
    x2 = 0.0
    check_point(x1, x2)

    # Candidate 5: intersection of black constraint with x2 = 0
    # 5*x1 = 20 -> x1 = 4
    x1 = 4.0
    x2 = 0.0
    check_point(x1, x2)

    # Candidate 6: intersection of white constraint with x2 = 0
    # 6*x1 = 5 -> x1 = 5/6
    x1 = 5.0 / 6.0
    x2 = 0.0
    check_point(x1, x2)

    # Candidate 7: intersection of black constraint with x1 = 0
    # 10*x2 = 20 -> x2 = 2
    x1 = 0.0
    x2 = 2.0
    check_point(x1, x2)

    # Candidate 8: intersection of white constraint with x1 = 0
    # 10*x2 = 5 -> x2 = 0.5
    x1 = 0.0
    x2 = 0.5
    check_point(x1, x2)

    # Also check the point that obviously satisfies brown and might be optimal:
    # From brown: x1 >= 5. The cheapest is to set x1 = 5, x2 = 0 (already checked).
    # No other obvious corners remain.

    # best now holds the minimal cost
    return float(best)
```",1500.0,True,0.0,0.0,4.714378595352173,
109,45.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 5x + 3y
    # Subject to:
    # 4x + 6y <= 150   (flour)
    # 6x + 3y <= 100   (liquid)
    # 4x + 2y <= 30    (waste)
    # x >= 0, y >= 0
    
    # Since it's a 2-variable LP, we can solve by enumerating corner points
    # formed by intersections of constraint lines and axes.
    
    import math

    # Helper to solve a1*x + b1*y = c1 and a2*x + b2*y = c2
    def intersect(a1, b1, c1, a2, b2, c2):
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-9:
            return None
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)

    # Constraints in the form (a, b, c) for a*x + b*y <= c
    constraints = [
        (4.0, 6.0, 150.0),  # flour
        (6.0, 3.0, 100.0),  # liquid
        (4.0, 2.0, 30.0)    # waste
    ]

    # Candidate points: intersections of each pair of constraints and with axes
    candidates = []

    # Intersections of constraint pairs
    for i in range(len(constraints)):
        for j in range(i + 1, len(constraints)):
            a1, b1, c1 = constraints[i]
            a2, b2, c2 = constraints[j]
            pt = intersect(a1, b1, c1, a2, b2, c2)
            if pt is not None:
                candidates.append(pt)

    # Intersections with axes: set x=0 or y=0 for each constraint
    for (a, b, c) in constraints:
        # x = 0 => b*y <= c
        if abs(b) > 1e-9:
            y = c / b
            candidates.append((0.0, y))
        # y = 0 => a*x <= c
        if abs(a) > 1e-9:
            x = c / a
            candidates.append((x, 0.0))

    # Always include origin
    candidates.append((0.0, 0.0))

    def feasible(x, y):
        if x < -1e-9 or y < -1e-9:
            return False
        for (a, b, c) in constraints:
            if a * x + b * y - c > 1e-9:
                return False
        return True

    best_val = -math.inf
    for (x, y) in candidates:
        if feasible(x, y):
            val = 5.0 * x + 3.0 * y
            if val > best_val:
                best_val = val

    return float(best_val)
```",45.0,True,0.0,0.0,3.2748987674713135,
110,430.0,"```python
def solve():
    # We model:
    # x = number of helicopter trips
    # y = number of car trips
    #
    # Constraints:
    # 1) Fish capacity: 30x + 20y >= 300
    # 2) At most 5 helicopter trips: x <= 5
    # 3) At least 60% of trips by car: y >= 1.5x
    # 4) x, y >= 0
    #
    # Objective: minimize total time T = 40x + 30y
    #
    # This is a small LP; we can brute-force over a reasonable grid
    # because the feasible region is bounded by the constraints.
    #
    # From constraints:
    # - x is between 0 and 5
    # - For each x, y must satisfy:
    #   y >= 1.5x
    #   30x + 20y >= 300  -> y >= (300 - 30x)/20
    #
    # We search over x, y in a fine grid and keep the best feasible solution.
    # Since the problem is continuous, we use a small step size to approximate.
    
    best_val = None
    step = 0.001  # fine enough for this small problem
    
    x = 0.0
    while x <= 5.0 + 1e-9:
        # Lower bounds on y from constraints
        y_min1 = 1.5 * x
        y_min2 = (300.0 - 30.0 * x) / 20.0
        y_min = max(y_min1, y_min2, 0.0)
        
        # If y_min is already very large, skip
        if y_min > 1000:
            x += step
            continue
        
        # For fixed x, objective increases with y (since 30 > 0),
        # so the best y is the minimal feasible y, i.e., y_min.
        y = y_min
        
        # Check feasibility (with small tolerance)
        if (30.0 * x + 20.0 * y >= 300.0 - 1e-6 and
            x <= 5.0 + 1e-6 and
            y >= 1.5 * x - 1e-6 and
            x >= -1e-6 and y >= -1e-6):
            
            val = 40.0 * x + 30.0 * y
            if best_val is None or val < best_val:
                best_val = val
        
        x += step
    
    # Return the optimal objective value as a float
    return float(best_val if best_val is not None else 0.0)
```",425.0000000000004,False,4.999999999999602,0.011627906976716219,3.0777599811553955,
111,600.0,"```python
def solve():
    # Let x = number of regular boat trips
    # Let y = number of speed boat trips
    #
    # Constraints:
    # 1) Mail capacity: 20x + 30y >= 1000
    # 2) Regular trip limit: x <= 20
    # 3) At least 50% speed trips: y >= x
    # 4) x, y >= 0
    #
    # Objective: minimize gas = 10x + 20y
    #
    # We will brute-force over integer x, y in a reasonable range.
    # Upper bound for y: if all trips are speed boats, 30y >= 1000 => y >= 34 (since 33*30=990)
    # So y up to, say, 100 is more than enough.

    best_value = None

    for x in range(0, 21):  # x <= 20
        for y in range(0, 101):
            # Check constraints
            if 20 * x + 30 * y < 1000:
                continue
            if y < x:
                continue

            gas = 10 * x + 20 * y
            if best_value is None or gas < best_value:
                best_value = gas

    # Return the optimal objective value (minimal gas consumption)
    return float(best_value)
```",600.0,True,0.0,0.0,2.042426586151123,
112,125.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 25 x1 + 18 x2
    # Subject to:
    # 10 x1 + 12 x2 <= 120   (mint)
    # 20 x1 + 15 x2 <= 100   (active ingredient)
    # 5 x1 + 3 x2 <= 50      (black tar)
    # x1, x2 >= 0
    
    # We'll solve by enumerating all corner points formed by intersections
    # of constraint lines and axes, then checking feasibility and objective.
    
    import math
    
    # Helper to solve a 2x2 linear system:
    # a1*x + b1*y = c1
    # a2*x + b2*y = c2
    def solve_2x2(a1, b1, c1, a2, b2, c2):
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-9:
            return None  # parallel or nearly parallel
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)
    
    # Constraints in the form a*x1 + b*x2 <= c
    constraints = [
        (10.0, 12.0, 120.0),  # mint
        (20.0, 15.0, 100.0),  # active ingredient
        (5.0, 3.0, 50.0)      # black tar
    ]
    
    # Candidate points: intersections of each pair of constraint lines,
    # plus intersections with axes (x1=0 or x2=0).
    candidates = []
    
    # Intersections of constraint lines
    for i in range(len(constraints)):
        for j in range(i + 1, len(constraints)):
            a1, b1, c1 = constraints[i]
            a2, b2, c2 = constraints[j]
            sol = solve_2x2(a1, b1, c1, a2, b2, c2)
            if sol is not None:
                candidates.append(sol)
    
    # Intersections with axes:
    # For each constraint a*x1 + b*x2 <= c:
    # with x1 = 0 -> x2 = c/b (if b != 0)
    # with x2 = 0 -> x1 = c/a (if a != 0)
    for (a, b, c) in constraints:
        if abs(b) > 1e-9:
            candidates.append((0.0, c / b))
        if abs(a) > 1e-9:
            candidates.append((c / a, 0.0))
    
    # Also include the origin
    candidates.append((0.0, 0.0))
    
    # Check feasibility and compute objective
    best_value = -math.inf
    
    for x1, x2 in candidates:
        # Nonnegativity
        if x1 < -1e-9 or x2 < -1e-9:
            continue
        
        # Check all constraints
        feasible = True
        for (a, b, c) in constraints:
            if a * x1 + b * x2 - c > 1e-9:
                feasible = False
                break
        
        if not feasible:
            continue
        
        # Objective: 25 x1 + 18 x2
        value = 25.0 * x1 + 18.0 * x2
        if value > best_value:
            best_value = value
    
    return float(best_value)
```",125.0,True,0.0,0.0,3.8221471309661865,
113,507.8,"```python
def solve():
    # We solve the LP by enumerating feasible corner points.
    # Variables:
    #   x = number of carrots
    #   y = number of cucumbers
    #
    # Constraints:
    #   0.30x + 0.50y <= 500        (budget)
    #   y <= x / 3                  (cucumber-carrot ratio)
    #   300 <= x <= 500             (carrot bounds)
    #   y >= 0
    #
    # Objective:
    #   Maximize profit = 0.75x + 0.80y

    best_profit = float(""-inf"")

    # Helper to check feasibility and update best profit
    def consider_point(x, y):
        nonlocal best_profit
        # Check feasibility
        if x < 300 or x > 500:
            return
        if y < 0:
            return
        if 0.30 * x + 0.50 * y > 500 + 1e-9:
            return
        if y - x / 3 > 1e-9:
            return
        # Compute profit
        profit = 0.75 * x + 0.80 * y
        if profit > best_profit:
            best_profit = profit

    # Candidate corner points come from intersections of constraints:
    # 1) x = 300, x = 500
    # 2) y = 0
    # 3) y = x/3
    # 4) 0.30x + 0.50y = 500

    # Intersections with y = 0
    for x in [300.0, 500.0]:
        consider_point(x, 0.0)

    # Intersections with y = x/3
    for x in [300.0, 500.0]:
        y = x / 3.0
        consider_point(x, y)

    # Intersections of budget with y = 0
    # 0.30x = 500 -> x = 500 / 0.30
    x_budget_y0 = 500.0 / 0.30
    consider_point(x_budget_y0, 0.0)

    # Intersections of budget with y = x/3:
    # 0.30x + 0.50*(x/3) = 500
    # 0.30x + (0.50/3)x = 500
    # (0.30 + 0.50/3)x = 500
    coef = 0.30 + (0.50 / 3.0)
    x_budget_ratio = 500.0 / coef
    y_budget_ratio = x_budget_ratio / 3.0
    consider_point(x_budget_ratio, y_budget_ratio)

    # Also check the endpoints of x-range with budget constraint active:
    # For x = 300, solve 0.30*300 + 0.50*y = 500
    # For x = 500, solve 0.30*500 + 0.50*y = 500
    for x in [300.0, 500.0]:
        remaining = 500.0 - 0.30 * x
        if remaining >= 0:
            y = remaining / 0.50
            consider_point(x, y)

    return float(best_profit)
```",508.33333333333337,False,0.5333333333333599,0.0010502822633562615,3.8661224842071533,
114,684000.0,"```python
def solve():
    # Let x = dollars invested in condos
    #     y = dollars invested in detached houses
    #
    # Maximize profit: 0.5x + 1y
    #
    # Subject to:
    # 1) Budget: x + y <= 760000
    # 2) At least 20% in condos: x >= 0.2(x + y)
    #    => x >= 0.2x + 0.2y
    #    => 0.8x >= 0.2y
    #    => 4x >= y
    # 3) At least 20000 in houses: y >= 20000
    # 4) x, y >= 0
    #
    # This is a 2-variable LP; we can solve analytically.
    #
    # From y >= 20000 and y <= 4x (from 4x >= y), we get x >= 5000.
    # Also x + y <= 760000 and y >= 20000 => x <= 740000.
    #
    # Profit increases with both x and y (positive coefficients),
    # so the optimum will be on the boundary x + y = 760000.
    #
    # On that boundary, y = 760000 - x.
    # The constraint 4x >= y becomes:
    #   4x >= 760000 - x  => 5x >= 760000  => x >= 152000.
    # Also y >= 20000 => 760000 - x >= 20000 => x <= 740000.
    #
    # So on the boundary, feasible x is in [152000, 740000].
    # Profit as a function of x:
    #   P(x) = 0.5x + (760000 - x) = 760000 - 0.5x
    # This is decreasing in x, so maximize profit at smallest feasible x: x = 152000.
    #
    # Then y = 760000 - 152000 = 608000.
    #
    # Optimal profit:
    profit = 0.5 * 152000 + 608000
    return float(profit)
```",684000.0,True,0.0,0.0,3.2762556076049805,
115,2500.0,"```python
def solve():
    # Let x = number of children's vaccines
    #     y = number of adult vaccines
    #
    # Each child: 50 mg mRNA, 50 mg suppressant
    # Each adult: 75 mg mRNA, 75 mg suppressant
    #
    # Total mRNA available: 20000 mg
    # Constraint: 50x + 75y <= 20000
    #
    # Adult proportion: y >= 0.7(x + y)  ->  0.3y >= 0.7x  ->  y >= (7/3)x
    # At least 50 children's vaccines: x >= 50
    # Nonnegativity: x >= 0, y >= 0 (x >= 50 already implies x >= 0)
    #
    # Objective: minimize total suppressant = 50x + 75y
    #
    # Note: 50x + 75y is proportional to total mRNA used (same coefficients),
    # so minimizing suppressant is equivalent to minimizing mRNA used.
    #
    # We solve this small LP analytically.

    # From y >= (7/3)x and mRNA constraint 50x + 75y <= 20000:
    # Substitute y = (7/3)x into 50x + 75y <= 20000 to find upper bound on x.
    # 50x + 75*(7/3)x = 50x + 175x = 225x <= 20000 -> x <= 20000/225
    x_max = 20000.0 / 225.0

    # x must be at least 50 and at most x_max to keep feasibility with y = (7/3)x.
    # The objective with y = (7/3)x:
    #   Z(x) = 50x + 75*(7/3)x = 50x + 175x = 225x
    # This is increasing in x, so we choose the smallest feasible x, i.e., x = 50.
    x = 50.0
    y = (7.0 / 3.0) * x

    # Check mRNA constraint is satisfied:
    # 50x + 75y <= 20000
    # (This will be true by construction, but we compute objective directly.)
    objective_value = 50.0 * x + 75.0 * y

    return float(objective_value)
```",11250.0,False,8750.0,3.4999999999986002,3.3707916736602783,
116,22.0,"```python
def solve():
    # We model the problem as a linear program:
    # Let x = number of high intensity drills
    #     y = number of low intensity drills
    #
    # Constraints:
    # 1) Gem processing: 50x + 30y >= 800
    # 2) Water:          50x + 20y <= 700
    # 3) Noise:          x <= 0.4(x + y)  ->  0.6x <= 0.4y  ->  3x <= 2y  ->  y >= 1.5x
    # 4) At least 10 low intensity: y >= 10
    # 5) x, y >= 0
    #
    # Objective: minimize total drills: z = x + y
    #
    # This is a 2-variable LP, so we can solve it by enumerating intersection points
    # of the constraint boundaries and checking feasibility and objective value.
    
    import math

    # Helper to check feasibility of a point (x, y)
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 50 * x + 30 * y < 800 - 1e-9:  # gem constraint
            return False
        if 50 * x + 20 * y > 700 + 1e-9:  # water constraint
            return False
        if y < 1.5 * x - 1e-9:            # noise constraint
            return False
        if y < 10 - 1e-9:                 # at least 10 low intensity
            return False
        return True

    candidates = []

    # 1) Intersection of gem and water:
    #    50x + 30y = 800
    #    50x + 20y = 700
    # Subtract second from first: 10y = 100 -> y = 10, then 50x + 20*10 = 700 -> x = 9
    x1, y1 = 9.0, 10.0
    candidates.append((x1, y1))

    # 2) Intersection of gem and noise: 50x + 30y = 800, y = 1.5x
    #    50x + 30(1.5x) = 800 -> 50x + 45x = 800 -> 95x = 800
    x2 = 800.0 / 95.0
    y2 = 1.5 * x2
    candidates.append((x2, y2))

    # 3) Intersection of water and noise: 50x + 20y = 700, y = 1.5x
    #    50x + 20(1.5x) = 700 -> 50x + 30x = 700 -> 80x = 700
    x3 = 700.0 / 80.0
    y3 = 1.5 * x3
    candidates.append((x3, y3))

    # 4) Intersection of gem and y = 10: 50x + 30*10 = 800 -> 50x = 500 -> x = 10
    x4, y4 = 10.0, 10.0
    candidates.append((x4, y4))

    # 5) Intersection of water and y = 10: 50x + 20*10 = 700 -> 50x = 500 -> x = 10
    x5, y5 = 10.0, 10.0
    candidates.append((x5, y5))

    # 6) Intersection of noise and y = 10: y = 1.5x and y = 10 -> x = 10/1.5
    x6, y6 = 10.0 / 1.5, 10.0
    candidates.append((x6, y6))

    best_val = math.inf

    for x, y in candidates:
        if feasible(x, y):
            val = x + y
            if val < best_val:
                best_val = val

    # Return the optimal objective value (minimal total number of drills)
    return float(best_val)
```",21.05263157894737,False,0.9473684210526301,0.04306220095498036,5.236504077911377,
117,430.7692307692308,"```python
def solve():
    # We minimize sugar: S = 10B + 8M
    # Subject to:
    # 1) Calories: 80B + 100M >= 4000
    # 2) Potassium: 20B + 15M >= 150
    # 3) Mango fraction: M <= (1/2) * B  (from M <= (1/3)(B+M))
    # 4) B, M >= 0

    # The feasible region is a polygon; the optimum of a linear program
    # occurs at a vertex (intersection of constraint boundaries).
    # We'll compute all candidate vertices formed by intersecting pairs
    # of constraints and then pick the feasible one with minimum sugar.

    import math

    def intersect_two(a1, b1, c1, a2, b2, c2):
        # Solve:
        # a1*B + b1*M = c1
        # a2*B + b2*M = c2
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-12:
            return None
        B = (c1 * b2 - c2 * b1) / det
        M = (a1 * c2 - a2 * c1) / det
        return (B, M)

    # Constraints in equality form:
    # C1: 80B + 100M = 4000
    # C2: 20B + 15M = 150
    # C3: M = 0.5B  ->  -0.5B + 1M = 0
    # C4: B = 0
    # C5: M = 0

    candidates = []

    # Intersections of pairs of constraints:
    # C1 & C2
    pt = intersect_two(80, 100, 4000, 20, 15, 150)
    if pt: candidates.append(pt)

    # C1 & C3
    # 80B + 100M = 4000
    # -0.5B + 1M = 0
    pt = intersect_two(80, 100, 4000, -0.5, 1, 0)
    if pt: candidates.append(pt)

    # C2 & C3
    # 20B + 15M = 150
    # -0.5B + 1M = 0
    pt = intersect_two(20, 15, 150, -0.5, 1, 0)
    if pt: candidates.append(pt)

    # C1 & C4: B = 0
    # 80*0 + 100M = 4000 -> M = 40
    candidates.append((0.0, 4000.0 / 100.0))

    # C2 & C4: B = 0
    # 20*0 + 15M = 150 -> M = 10
    candidates.append((0.0, 150.0 / 15.0))

    # C1 & C5: M = 0
    # 80B = 4000 -> B = 50
    candidates.append((4000.0 / 80.0, 0.0))

    # C2 & C5: M = 0
    # 20B = 150 -> B = 7.5
    candidates.append((150.0 / 20.0, 0.0))

    # C3 & C4: B = 0, M = 0
    candidates.append((0.0, 0.0))

    # C3 & C5: M = 0, so 0 = 0.5B -> B = 0
    candidates.append((0.0, 0.0))

    def feasible(B, M):
        if B < -1e-9 or M < -1e-9:
            return False
        # Calories
        if 80 * B + 100 * M < 4000 - 1e-9:
            return False
        # Potassium
        if 20 * B + 15 * M < 150 - 1e-9:
            return False
        # Mango fraction: M <= 0.5B
        if M - 0.5 * B > 1e-9:
            return False
        return True

    best_val = math.inf
    for B, M in candidates:
        if feasible(B, M):
            sugar = 10 * B + 8 * M
            if sugar < best_val:
                best_val = sugar

    # Return the optimal objective value (minimal sugar)
    return float(best_val)
```",430.7692307692308,True,0.0,0.0,8.397486925125122,
118,465.0,"```python
def solve():
    # We maximize total flowers: 5s + 10l
    # Constraints:
    # 1) s <= 80
    # 2) l <= 50
    # 3) s + l <= 70
    # 4) l >= 20
    # 5) s >= 2l
    #
    # We'll search over feasible integer (s, l) pairs and find the best.

    best_value = float('-inf')

    for l in range(20, 51):  # l >= 20 and l <= 50
        # s must satisfy:
        # s >= 2l
        # s <= 80
        # s + l <= 70  -> s <= 70 - l
        s_min = 2 * l
        s_max = min(80, 70 - l)

        if s_min <= s_max:
            # Since objective is linear and increasing in s (coefficient 5 > 0),
            # best s is the largest feasible s, i.e., s_max.
            s = s_max
            value = 5 * s + 10 * l
            if value > best_value:
                best_value = value

    return float(best_value)
```",465.0,True,0.0,0.0,2.867755174636841,
119,291.4,"```python
def solve():
    # Let x = number of molars, y = number of canines
    # Minimize pain killer: 3x + 2.3y
    # Subject to:
    # 1) Resin: 20x + 15y <= 3000
    # 2) At least 60% canines: y >= 1.5x
    # 3) Reserve materials for at least 45 molars:
    #    Means after scheduling x molars and y canines, we must still be able
    #    to fill 45 molars with remaining resin and pain killer.
    #
    # Remaining resin: 3000 - (20x + 15y)
    # Remaining pain killer: total_pain - (3x + 2.3y)
    # But total pain killer is not explicitly limited in the problem statement.
    # The only explicit resource limit is resin (3000 units).
    #
    # The phrase ""reserve materials to fill at least 45 molars"" therefore
    # must refer to resin only (since that's the only constrained material).
    #
    # So we require:
    #   3000 - (20x + 15y) >= 45 * 20
    #   3000 - 20x - 15y >= 900
    #   20x + 15y <= 2100
    #
    # This is stricter than the original resin constraint 20x + 15y <= 3000,
    # so the effective resin constraint is:
    #   20x + 15y <= 2100
    #
    # Final LP:
    # Minimize 3x + 2.3y
    # s.t.
    #   20x + 15y <= 2100
    #   y >= 1.5x
    #   x >= 0, y >= 0
    #
    # Because the objective coefficients are positive, the optimum will lie
    # on the boundary of the feasible region. We can analyze it analytically.
    #
    # From y >= 1.5x, to minimize objective we will take y = 1.5x (smallest y).
    # Substitute into 20x + 15y <= 2100:
    #   20x + 15*(1.5x) = 20x + 22.5x = 42.5x <= 2100
    #   x <= 2100 / 42.5
    x_opt = 2100.0 / 42.5
    y_opt = 1.5 * x_opt

    # Objective value:
    obj = 3.0 * x_opt + 2.3 * y_opt
    return obj
```",318.7058823529412,False,27.30588235294124,0.09370584197957288,3.7927305698394775,
120,363.0,"```python
def solve():
    # We want to maximize total number of bottles:
    # Let g = number of glass bottles
    #     p = number of plastic bottles
    #
    # Maximize: g + p
    # Subject to:
    #   500g + 750p <= 250000   (water constraint)
    #   p >= 3g                 (plastic at least 3 times glass)
    #   g >= 20                 (at least 20 glass bottles)
    #   g, p >= 0 and integers
    #
    # We'll brute-force over feasible integer g and compute best p.
    
    best_value = -1.0
    
    # Upper bound on g from water constraint alone: 500g <= 250000 -> g <= 500
    for g in range(20, 501):
        # From p >= 3g
        p_min = 3 * g
        
        # From water constraint: 500g + 750p <= 250000
        # => 750p <= 250000 - 500g
        remaining = 250000 - 500 * g
        if remaining < 0:
            continue
        p_max = remaining // 750  # integer max
        
        if p_max < p_min:
            continue
        
        # To maximize g + p, choose largest feasible p
        p = p_max
        total = g + p
        if total > best_value:
            best_value = float(total)
    
    return best_value
```",363.0,True,0.0,0.0,2.4574146270751953,
121,22.0,"```python
def solve():
    # We need to solve the LP:
    # Minimize: x + y
    # Subject to:
    #   60x + 40y >= 1000   (luggage constraint)
    #   30x + 15y <= 430   (pollution constraint)
    #   x >= 0, y >= 0
    #
    # We'll solve this by enumerating candidate corner points of the feasible region.
    # The constraints are linear, so the optimum lies at a corner (or along an edge).
    
    best_value = None

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 60 * x + 40 * y < 1000:
            return False
        if 30 * x + 15 * y > 430:
            return False
        return True

    # 1) Intersection of the two main constraints:
    #    60x + 40y = 1000
    #    30x + 15y = 430
    # Solve analytically:
    # From second: 30x + 15y = 430 -> divide by 15: 2x + y = 430/15
    # y = 430/15 - 2x
    # Substitute into first:
    # 60x + 40(430/15 - 2x) = 1000
    # 60x + (40*430)/15 - 80x = 1000
    # -20x + (40*430)/15 = 1000
    # -20x = 1000 - (40*430)/15
    # x = [ (40*430)/15 - 1000 ] / 20
    num = (40 * 430) / 15 - 1000
    x_inter = num / 20.0
    y_inter = 430 / 15.0 - 2 * x_inter

    candidates = []

    # Add intersection point if feasible
    if feasible(x_inter, y_inter):
        candidates.append((x_inter, y_inter))

    # 2) Intersections with axes:
    # x = 0:
    #   60*0 + 40y >= 1000 -> y >= 25
    #   30*0 + 15y <= 430 -> y <= 430/15
    # So y in [25, 430/15]. If this interval is non-empty, the best on this edge is y = 25.
    y_min = 25.0
    y_max = 430.0 / 15.0
    if y_min <= y_max and feasible(0.0, y_min):
        candidates.append((0.0, y_min))

    # y = 0:
    #   60x >= 1000 -> x >= 1000/60
    #   30x <= 430 -> x <= 430/30
    # So x in [1000/60, 430/30]. If non-empty, best is x = 1000/60.
    x_min = 1000.0 / 60.0
    x_max = 430.0 / 30.0
    if x_min <= x_max and feasible(x_min, 0.0):
        candidates.append((x_min, 0.0))

    # Evaluate objective at all candidate points
    for x, y in candidates:
        value = x + y
        if best_value is None or value < best_value:
            best_value = value

    # Return the optimal objective value as float
    return float(best_value)
```",21.33333333333333,False,0.6666666666666714,0.030303030301653107,4.611147403717041,
122,28.0,"```python
def solve():
    # We solve the LP:
    # Minimize: x + y
    # Subject to:
    # 1) 30x + 50y >= 1000   (production)
    # 2) 100x + 120y <= 3000 (electricity)
    # 3) y <= 0.3(x + y)     (at most 30% are B) -> 7y <= 3x
    # 4) x >= 5
    # 5) x, y >= 0
    #
    # This is a 2-variable LP; we can solve it by checking all corner points
    # formed by intersections of constraint boundaries and feasibility region.
    #
    # We'll treat x, y as continuous (not necessarily integers).

    import math

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if x < 5 - 1e-9:  # x >= 5
            return False
        if 30 * x + 50 * y < 1000 - 1e-9:
            return False
        if 100 * x + 120 * y > 3000 + 1e-9:
            return False
        if 7 * y > 3 * x + 1e-9:
            return False
        return True

    candidates = []

    # 1) Intersection of production and electricity:
    # 30x + 50y = 1000
    # 100x + 120y = 3000
    # Solve:
    # From first: x = (1000 - 50y)/30
    # Substitute into second:
    # 100*(1000 - 50y)/30 + 120y = 3000
    # (100000 - 5000y)/30 + 120y = 3000
    # Multiply by 30:
    # 100000 - 5000y + 3600y = 90000
    # 100000 - 1400y = 90000
    # 1400y = 10000
    # y = 10000/1400 = 50/7
    y = 50.0 / 7.0
    x = (1000.0 - 50.0 * y) / 30.0
    candidates.append((x, y))

    # 2) Intersection of production and B-percentage (7y = 3x):
    # 30x + 50y = 1000
    # 7y = 3x -> x = (7/3)y
    # Substitute:
    # 30*(7/3)y + 50y = 1000
    # 70y + 50y = 1000
    # 120y = 1000
    # y = 1000/120 = 25/3
    y = 25.0 / 3.0
    x = (7.0 / 3.0) * y
    candidates.append((x, y))

    # 3) Intersection of electricity and B-percentage:
    # 100x + 120y = 3000
    # 7y = 3x -> x = (7/3)y
    # Substitute:
    # 100*(7/3)y + 120y = 3000
    # (700/3)y + 120y = 3000
    # (700/3 + 360/3)y = 3000
    # (1060/3)y = 3000
    # y = 3000 * 3 / 1060
    y = 3000.0 * 3.0 / 1060.0
    x = (7.0 / 3.0) * y
    candidates.append((x, y))

    # 4) Intersection of production and x = 5:
    x = 5.0
    # 30*5 + 50y = 1000 -> 150 + 50y = 1000 -> 50y = 850 -> y = 17
    y = (1000.0 - 30.0 * x) / 50.0
    candidates.append((x, y))

    # 5) Intersection of electricity and x = 5:
    x = 5.0
    # 100*5 + 120y = 3000 -> 500 + 120y = 3000 -> 120y = 2500 -> y = 2500/120
    y = (3000.0 - 100.0 * x) / 120.0
    candidates.append((x, y))

    # 6) Intersection of B-percentage and x = 5:
    x = 5.0
    # 7y = 3x -> y = 15/7
    y = 3.0 * x / 7.0
    candidates.append((x, y))

    # 7) Also consider boundary where production is just met and y = 0:
    # 30x >= 1000 -> x = 1000/30
    x = 1000.0 / 30.0
    y = 0.0
    candidates.append((x, y))

    # 8) Boundary where electricity is just met and y = 0:
    # 100x <= 3000 -> x = 3000/100
    x = 3000.0 / 100.0
    y = 0.0
    candidates.append((x, y))

    # 9) Boundary where x = 5 and y = 0 (if feasible)
    x = 5.0
    y = 0.0
    candidates.append((x, y))

    best_val = math.inf

    for x, y in candidates:
        if feasible(x, y):
            val = x + y
            if val < best_val:
                best_val = val

    # In case numerical issues miss the true optimum, we can also
    # do a coarse search over x in a reasonable range and compute minimal y.
    # This is just a safety net.
    for x in [5 + i * 0.1 for i in range(0, 501)]:  # x from 5 to 55
        # From constraints, derive minimal y for given x:
        # 30x + 50y >= 1000 -> y >= (1000 - 30x)/50
        y_min_prod = max(0.0, (1000.0 - 30.0 * x) / 50.0)
        # 100x + 120y <= 3000 -> y <= (3000 - 100x)/120
        y_max_elec = (3000.0 - 100.0 * x) / 120.0
        # 7y <= 3x -> y <= 3x/7
        y_max_B = 3.0 * x / 7.0
        y_max = min(y_max_elec, y_max_B)
        if y_min_prod <= y_max + 1e-9:
            y = max(y_min_prod, 0.0)
            if feasible(x, y):
                val = x + y
                if val < best_val:
                    best_val = val

    return float(best_val)
```",27.77777777777778,False,0.22222222222222143,0.007936507936224461,8.191087245941162,
123,4.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 0.5 x1 + 0.3 x2
    # Subject to:
    #   0.5 x1 + 0.2 x2 <= 5      (throat medicine max)
    #   0.4 x1 + 0.5 x2 >= 4      (lungs medicine min)
    #   x1 >= 0, x2 >= 0

    # The feasible region is a polygon; the optimum of a linear program
    # occurs at a vertex (corner point). We enumerate candidate vertices
    # formed by intersections of constraint boundaries and axes, then
    # check feasibility and compute the objective.

    import math

    def is_feasible(x1, x2):
        if x1 < -1e-9 or x2 < -1e-9:
            return False
        # Throat: 0.5 x1 + 0.2 x2 <= 5
        if 0.5 * x1 + 0.2 * x2 - 5 > 1e-9:
            return False
        # Lungs: 0.4 x1 + 0.5 x2 >= 4
        if 4 - (0.4 * x1 + 0.5 * x2) > 1e-9:
            return False
        return True

    def objective(x1, x2):
        return 0.5 * x1 + 0.3 * x2

    candidates = []

    # 1) Intersection of the two constraint boundaries:
    #   0.5 x1 + 0.2 x2 = 5
    #   0.4 x1 + 0.5 x2 = 4
    # Solve the 2x2 system:
    # Use Cramer's rule or direct algebra.
    # Determinant:
    det = 0.5 * 0.5 - 0.2 * 0.4
    if abs(det) > 1e-12:
        x1 = (5 * 0.5 - 0.2 * 4) / det
        x2 = (0.5 * 4 - 0.4 * 5) / det
        candidates.append((x1, x2))

    # 2) Intersections with axes and each constraint boundary:

    # With x1 = 0:
    # Throat: 0.2 x2 <= 5 -> x2 <= 25
    # Lungs: 0.5 x2 >= 4 -> x2 >= 8
    # So candidate points on x1=0 are (0,8) and (0,25) (but 25 is loose for lungs).
    # Only need to check feasibility; (0,25) is feasible but will have higher sugar.
    candidates.append((0.0, 8.0))
    candidates.append((0.0, 25.0))

    # With x2 = 0:
    # Throat: 0.5 x1 <= 5 -> x1 <= 10
    # Lungs: 0.4 x1 >= 4 -> x1 >= 10
    # So only x1 = 10 is possible.
    candidates.append((10.0, 0.0))

    # Also intersections of each constraint with axes explicitly:

    # Throat boundary with x1=0: 0.2 x2 = 5 -> x2 = 25 (already added)
    # Throat boundary with x2=0: 0.5 x1 = 5 -> x1 = 10 (already added)

    # Lungs boundary with x1=0: 0.5 x2 = 4 -> x2 = 8 (already added)
    # Lungs boundary with x2=0: 0.4 x1 = 4 -> x1 = 10 (already added)

    best_val = math.inf
    for x1, x2 in candidates:
        if is_feasible(x1, x2):
            val = objective(x1, x2)
            if val < best_val:
                best_val = val

    return float(best_val)
```",2.4,False,1.6,0.3999999999,10.381152629852295,
124,11980.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 100x + 90y
    # Subject to:
    # 40x + 30y <= 4000  (assembly)
    # 20x + 10y <= 3500  (sanding)
    # x >= 0, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) x = 0:
    #    30y <= 4000 -> y <= 4000/30
    #    10y <= 3500 -> y <= 3500/10 = 350
    #    So y = min(4000/30, 350) = 350
    x1, y1 = 0.0, 350.0
    
    # 2) y = 0:
    #    40x <= 4000 -> x <= 100
    #    20x <= 3500 -> x <= 175
    #    So x = min(100, 175) = 100
    x2, y2 = 100.0, 0.0
    
    # 3) Intersection of:
    #    40x + 30y = 4000
    #    20x + 10y = 3500
    #
    # From second: 20x + 10y = 3500 -> 2x + y = 350 -> y = 350 - 2x
    # Substitute into first:
    # 40x + 30(350 - 2x) = 4000
    # 40x + 10500 - 60x = 4000
    # -20x = -6500 -> x = 325, then y = 350 - 2*325 = -300 (infeasible)
    # So this intersection is outside the feasible region and is discarded.
    
    # Evaluate objective at feasible corner points:
    def profit(x, y):
        return 100.0 * x + 90.0 * y
    
    p1 = profit(x1, y1)
    p2 = profit(x2, y2)
    
    # The optimal value is the maximum of these profits
    optimal_value = max(p1, p2)
    return optimal_value
```",31500.0,False,19520.0,1.629382303839597,2.932934522628784,
125,2250.0,"```python
def solve():
    # We want to maximize metal: 5x + 9y
    # subject to:
    # 8x + 6y <= 1500  (water)
    # 3x + 5y <= 1350  (pollution)
    # x, y >= 0
    
    # This is a 2-variable LP; the optimum lies at a corner (feasible vertex).
    # We'll compute all candidate vertices and pick the best feasible one.
    
    candidates = []
    
    # 1) Intersection of the two constraints:
    # 8x + 6y = 1500
    # 3x + 5y = 1350
    # Solve the system:
    # From first: x = (1500 - 6y)/8
    # Substitute into second:
    # 3*(1500 - 6y)/8 + 5y = 1350
    # (4500 - 18y)/8 + 5y = 1350
    # 4500 - 18y + 40y = 10800
    # 22y = 6300
    # y = 6300 / 22
    y = 6300.0 / 22.0
    x = (1500.0 - 6.0 * y) / 8.0
    if x >= 0 and y >= 0:
        candidates.append((x, y))
    
    # 2) Intersection with x = 0:
    # a) 8*0 + 6y <= 1500 -> y <= 250
    # b) 3*0 + 5y <= 1350 -> y <= 270
    # So the binding one is y = 250
    x = 0.0
    y = 250.0
    if 8*x + 6*y <= 1500 and 3*x + 5*y <= 1350 and x >= 0 and y >= 0:
        candidates.append((x, y))
    
    # 3) Intersection with y = 0:
    # a) 8x <= 1500 -> x <= 187.5
    # b) 3x <= 1350 -> x <= 450
    # So the binding one is x = 187.5
    x = 1500.0 / 8.0
    y = 0.0
    if 8*x + 6*y <= 1500 and 3*x + 5*y <= 1350 and x >= 0 and y >= 0:
        candidates.append((x, y))
    
    # 4) Origin (0,0) is also feasible
    candidates.append((0.0, 0.0))
    
    # Evaluate objective at all candidates and return the maximum value
    best_value = float('-inf')
    for x, y in candidates:
        value = 5.0 * x + 9.0 * y
        if value > best_value:
            best_value = value
    
    return best_value
```",2250.0,True,0.0,0.0,4.017895221710205,
126,19.0,"```python
def solve():
    # We interpret the problem as:
    # Minimize total number of vehicles: x + y
    # subject to:
    # 50x + 250y >= 4600   (seating capacity)
    # 10x + 40y <= 800     (pollution limit)
    # x, y >= 0
    
    # Solve analytically by checking corner points of the feasible region.
    # Constraints in simplified form:
    # Capacity: 50x + 250y >= 4600  -> divide by 50: x + 5y >= 92
    # Pollution: 10x + 40y <= 800   -> divide by 10: x + 4y <= 80
    
    # Corner 1: Intersection of the two constraint lines
    # x + 5y = 92
    # x + 4y = 80
    # Subtract second from first: y = 12, then x = 80 - 4*12 = 32
    x1, y1 = 32.0, 12.0
    # Check feasibility:
    def feasible(x, y):
        return (x >= 0 and y >= 0 and
                50*x + 250*y >= 4600 - 1e-9 and
                10*x + 40*y <= 800 + 1e-9)
    
    candidates = []
    if feasible(x1, y1):
        candidates.append((x1, y1))
    
    # Corner 2: Intersection of capacity with y = 0
    # x + 5*0 >= 92 -> x >= 92
    # Pollution: x + 4*0 <= 80 -> x <= 80
    # No feasible point on y=0.
    
    # Corner 3: Intersection of pollution with y = 0
    # x + 4*0 <= 80 -> x <= 80
    # Capacity: x + 5*0 >= 92 -> x >= 92
    # No feasible point on y=0.
    
    # Corner 4: Intersection of capacity with x = 0
    # 0 + 5y >= 92 -> y >= 18.4
    # Pollution: 0 + 4y <= 80 -> y <= 20
    # The minimal y on this edge that satisfies capacity is y = 18.4
    x2, y2 = 0.0, 18.4
    if feasible(x2, y2):
        candidates.append((x2, y2))
    
    # Corner 5: Intersection of pollution with x = 0
    # 0 + 4y <= 80 -> y <= 20
    # Capacity: 0 + 5y >= 92 -> y >= 18.4
    # The maximal y on this edge that satisfies pollution is y = 20
    x3, y3 = 0.0, 20.0
    if feasible(x3, y3):
        candidates.append((x3, y3))
    
    # Corner 6: Intersection of pollution with y = 0 already checked (no feasible).
    
    # Among feasible candidates, minimize x + y
    best_val = float('inf')
    best_point = None
    for x, y in candidates:
        val = x + y
        if val < best_val:
            best_val = val
            best_point = (x, y)
    
    # The problem text asks: ""Planning to make a profit, how many sedans and how many buses
    # should this tourism company purchase to decrease the total number of vehicles needed?""
    # That corresponds to the minimizing solution (x, y) = best_point.
    # The function must return the optimal objective value (minimum number of vehicles).
    return float(best_val)
```",18.4,False,0.6000000000000014,0.03157894736675908,6.161030292510986,
127,44.0,"```python
def solve():
    # We need to minimize the total number of workers: x + y
    # where:
    # x = number of seasonal workers (6 hours, $120)
    # y = number of permanent workers (10 hours, $250)
    #
    # Constraints:
    # 1) 6x + 10y >= 300  (hours requirement)
    # 2) 120x + 250y <= 6500 (budget)
    # 3) x, y >= 0 and integers
    #
    # We'll brute force over a reasonable range of x and y and find the feasible
    # solution with minimal x + y.

    best_value = None  # minimal number of workers
    # Upper bounds: from hours constraint alone, if all seasonal: 300/6 = 50
    # if all permanent: 300/10 = 30
    # From budget: if all seasonal: 6500/120 ~ 54, if all permanent: 6500/250 = 26
    # So we can safely search x in [0, 60], y in [0, 60]
    for x in range(61):
        for y in range(61):
            hours = 6 * x + 10 * y
            cost = 120 * x + 250 * y
            if hours >= 300 and cost <= 6500:
                total_workers = x + y
                if best_value is None or total_workers < best_value:
                    best_value = total_workers

    # The function should return the optimal objective value (minimal number of workers) as float
    return float(best_value)
```",44.0,True,0.0,0.0,2.355991840362549,
128,342.0,"```python
def solve():
    # We maximize gifts: 5S + 8F
    # Subject to:
    # 1) Points: 2S + 5F <= 200
    # 2) Seasonal fraction: S <= 0.3(S + F)
    # 3) At least 10 full-time: F >= 10
    # 4) S, F >= 0
    #
    # From (2): S <= 0.3S + 0.3F -> 0.7S <= 0.3F -> S <= (3/7)F

    best_value = -1.0
    best_S = 0.0
    best_F = 0.0

    # Since 2S + 5F <= 200 and S,F >= 0, F cannot exceed 200/5 = 40
    # We'll search over a reasonable continuous grid for F and compute S bounds.
    # This is sufficient for this small problem and avoids external solvers.

    steps = 10000  # fine grid for F in [10, 40]
    F_min, F_max = 10.0, 40.0
    for i in range(steps + 1):
        F = F_min + (F_max - F_min) * i / steps

        # Upper bounds on S from constraints:
        # From points: 2S + 5F <= 200 -> S <= (200 - 5F)/2
        S_point_ub = (200.0 - 5.0 * F) / 2.0
        if S_point_ub < 0:
            continue

        # From seasonal fraction: S <= (3/7)F
        S_frac_ub = (3.0 / 7.0) * F

        S_ub = min(S_point_ub, S_frac_ub)
        if S_ub < 0:
            continue

        # To maximize gifts, take S as large as allowed
        S = S_ub

        # Compute objective
        value = 5.0 * S + 8.0 * F
        if value > best_value:
            best_value = value
            best_S = S
            best_F = F

    # The function should return the optimal objective value (max gifts)
    return float(best_value)
```",346.3385,False,4.3385000000000105,0.012685672514582821,4.199045419692993,
129,120.0,"```python
def solve():
    # We need to minimize pollution: 5H + 10T
    # Subject to:
    #   3H + 7T >= 80   (must transport at least 80 cows)
    #   T <= 8          (at most 8 truck trips)
    #   H >= 0, T >= 0
    #
    # We assume H and T can be real (not necessarily integers), since it's a linear program.
    #
    # We'll search over feasible T in [0, 8], compute the minimal H for each T,
    # then compute the pollution and take the minimum.

    best_value = float('inf')

    # Since it's continuous, we can solve analytically:
    # For a given T, minimal H is max(0, (80 - 7T)/3).
    # But to keep the solution general and simple, we can just check the key points:
    #   - T = 0
    #   - T = 8
    #   - The point where 3H + 7T = 80 and T in [0,8]
    #
    # However, let's do it programmatically with a fine grid to avoid algebra in code.

    # Use a fine step to approximate the continuous optimum.
    # Step size small enough to get an accurate float result.
    step = 1e-4
    T = 0.0
    while T <= 8.0 + 1e-9:
        # Minimal H to satisfy 3H + 7T >= 80
        required_cows = 80 - 7 * T
        if required_cows <= 0:
            H = 0.0
        else:
            H = required_cows / 3.0

        # Pollution
        pollution = 5.0 * H + 10.0 * T

        if pollution < best_value:
            best_value = pollution

        T += step

    return best_value
```",120.00000000000884,True,8.839151632855646e-12,7.365959693984989e-14,2.9535071849823,
130,32.0,"```python
def solve():
    # Let s = number of smoothies, b = number of protein bars
    # Constraints:
    # 1) b = 2s
    # 2) 300s + 250b <= 2000
    # Objective: maximize protein = 2s + 7b
    
    # Substitute b = 2s into calorie constraint:
    # 300s + 250*(2s) <= 2000
    # 300s + 500s <= 2000
    # 800s <= 2000
    # s <= 2.5
    #
    # Protein as function of s:
    # P(s) = 2s + 7*(2s) = 2s + 14s = 16s
    # This is increasing in s, so optimal s is the maximum feasible: s = 2.5
    # Then b = 2 * 2.5 = 5
    #
    # Maximum protein:
    max_protein = 16 * 2.5  # 40.0
    return float(max_protein)
```",40.0,False,8.0,0.24999999999218753,1.965104579925537,
131,60.0,"```python
def solve():
    # We want to maximize profit:
    # Maximize 3x + 4y
    # Subject to:
    # 2x + 3y <= 40  (eggs)
    # 3x + 5y <= 70  (bacon)
    # x, y >= 0
    
    # Since this is a 2-variable LP, we can solve by checking corner points.
    
    best_value = 0.0
    
    # Check corner at (0,0)
    def profit(x, y):
        return 3 * x + 4 * y
    
    best_value = max(best_value, profit(0, 0))
    
    # Corner where y = 0:
    # 2x <= 40 -> x <= 20
    # 3x <= 70 -> x <= 70/3
    x_max_y0 = min(20, 70.0 / 3.0)
    best_value = max(best_value, profit(x_max_y0, 0))
    
    # Corner where x = 0:
    # 3y <= 40 -> y <= 40/3
    # 5y <= 70 -> y <= 14
    y_max_x0 = min(40.0 / 3.0, 14)
    best_value = max(best_value, profit(0, y_max_x0))
    
    # Intersection of:
    # 2x + 3y = 40
    # 3x + 5y = 70
    # Solve the system:
    # From first: 2x = 40 - 3y -> x = (40 - 3y)/2
    # Substitute into second:
    # 3*(40 - 3y)/2 + 5y = 70
    # (120 - 9y)/2 + 5y = 70
    # 120 - 9y + 10y = 140
    # 120 + y = 140 -> y = 20
    # Then x = (40 - 3*20)/2 = (40 - 60)/2 = -20/2 = -10 (infeasible)
    # So the intersection is not in the feasible region (x < 0).
    # No need to check it.
    
    return float(best_value)
```",60.0,True,0.0,0.0,2.5620152950286865,
132,511.4285714285713,"```python
def solve():
    # Let x = kg of regular mix, y = kg of sour surprise mix
    # Maximize: 3x + 5y
    # Subject to:
    #   0.8x + 0.1y <= 80   (regular candy)
    #   0.2x + 0.9y <= 60   (sour candy)
    #   x >= 0, y >= 0

    # We solve this small LP analytically by checking corner points.

    best_value = 0.0

    # Corner 1: x = 0
    # Constraints:
    #   0.1y <= 80  -> y <= 800
    #   0.9y <= 60  -> y <= 60 / 0.9
    y1 = min(800.0, 60.0 / 0.9)
    if y1 >= 0:
        val = 3 * 0 + 5 * y1
        if val > best_value:
            best_value = val

    # Corner 2: y = 0
    # Constraints:
    #   0.8x <= 80  -> x <= 100
    #   0.2x <= 60  -> x <= 300
    x2 = min(100.0, 300.0)
    if x2 >= 0:
        val = 3 * x2 + 5 * 0
        if val > best_value:
            best_value = val

    # Corner 3: intersection of
    #   0.8x + 0.1y = 80
    #   0.2x + 0.9y = 60
    # Solve the system:
    # From first: y = (80 - 0.8x) / 0.1 = 800 - 8x
    # Plug into second:
    #   0.2x + 0.9(800 - 8x) = 60
    #   0.2x + 720 - 7.2x = 60
    #   -7.0x = -660
    #   x = 660 / 7
    x3 = 660.0 / 7.0
    y3 = 800.0 - 8.0 * x3

    # Check feasibility (should be feasible by construction, but we ensure non-negativity)
    if x3 >= 0 and y3 >= 0:
        val = 3 * x3 + 5 * y3
        if val > best_value:
            best_value = val

    return float(best_value)
```",511.4285714285712,True,5.684341886080802e-14,1.111463497276196e-16,3.649602174758911,
133,650.0,"```python
def solve():
    # We want to maximize profit:
    # Let x = number of mangos, y = number of guavas
    # Profit P = 3x + 4y
    #
    # Constraints:
    # 1) Budget: 5x + 3y <= 20000
    # 2) 100 <= x <= 150
    # 3) y <= x/3
    # 4) x, y >= 0
    #
    # Since the ranges are small for x (100 to 150), we can brute force over integer x, y.
    
    best_profit = float('-inf')
    best_x = None
    best_y = None
    
    for x in range(100, 151):  # x from 100 to 150 inclusive
        # y must satisfy:
        # y <= x/3
        # 5x + 3y <= 20000  -> y <= (20000 - 5x)/3
        # y >= 0
        max_y_from_ratio = x // 3  # integer y <= x/3
        max_y_from_budget = (20000 - 5 * x) // 3
        max_y = min(max_y_from_ratio, max_y_from_budget)
        
        if max_y < 0:
            continue
        
        # Profit increases with y (coefficient 4 > 0), so best y is the maximum feasible y
        y = max_y
        
        profit = 3 * x + 4 * y
        if profit > best_profit:
            best_profit = profit
            best_x = x
            best_y = y
    
    # The function should return the optimal objective value (maximum profit) as a float.
    return float(best_profit)
```",650.0,True,0.0,0.0,2.1924352645874023,
134,480.0,"```python
def solve():
    # We solve the LP:
    # Maximize 30L + 15S
    # Subject to:
    # 4L + 2S <= 100   (paint)
    # 3L + 1S <= 50    (glitter)
    # 5L + 2S <= 70    (glue)
    # L >= 5, S >= 5

    best_value = float('-inf')

    # Since resources are limited, we can bound L and S.
    # From paint: 4L + 2S <= 100 => L <= 25, S <= 50
    # From glitter: 3L + S <= 50 => L <= 16, S <= 50
    # From glue: 5L + 2S <= 70 => L <= 14, S <= 35
    # So we can safely search L in [5, 50], S in [5, 50] but tighter bounds help.
    max_L = 50
    max_S = 50

    for L in range(5, max_L + 1):
        for S in range(5, max_S + 1):
            # Check constraints
            if 4 * L + 2 * S <= 100 and 3 * L + S <= 50 and 5 * L + 2 * S <= 70:
                value = 30 * L + 15 * S
                if value > best_value:
                    best_value = value

    return float(best_value)
```",480.0,True,0.0,0.0,2.560504198074341,
135,136.0,"```python
def solve():
    # We model:
    # x = number of camel caravans (integer, x >= 0)
    # y = number of desert trucks (integer, y >= 0)
    #
    # Constraints:
    # 1) Delivery requirement: 50x + 150y >= 1500
    # 2) Preference: x >= y
    #
    # Objective: minimize total hours = 12x + 5y
    #
    # Since the numbers are small, we can brute-force over a reasonable range.

    best_value = None

    # Upper bounds: in the worst case, all by camels: 1500/50 = 30
    # all by trucks: 1500/150 = 10
    # With preference x >= y, x won't need to exceed 30 and y won't need to exceed 30.
    for x in range(0, 31):
        for y in range(0, 31):
            if 50 * x + 150 * y >= 1500 and x >= y:
                value = 12 * x + 5 * y
                if best_value is None or value < best_value:
                    best_value = value

    # Return the optimal objective value as a float
    return float(best_value)
```",136.0,True,0.0,0.0,2.253919839859009,
136,30.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 3x + 5y
    # Subject to:
    #   2x + 4y >= 20   (vitamins)
    #   3x +  y >= 30   (minerals)
    #   x >= 0, y >= 0
    
    # The optimal solution for a 2-variable LP with linear constraints
    # lies at a corner (intersection of constraint lines or axes).
    # We'll compute candidate corner points and choose the feasible one
    # with minimum cost.
    
    candidates = []
    
    # 1) Intersection of the two constraint lines:
    #    2x + 4y = 20
    #    3x +  y = 30
    #
    # From second: y = 30 - 3x
    # Substitute into first:
    #   2x + 4(30 - 3x) = 20
    #   2x + 120 - 12x = 20
    #   -10x = -100
    #   x = 10
    #   y = 30 - 3*10 = 0
    x = 10.0
    y = 0.0
    if x >= 0 and y >= 0:
        if 2*x + 4*y >= 20 and 3*x + y >= 30:
            candidates.append((x, y))
    
    # 2) Intersection of vitamin constraint with x-axis (y = 0):
    #    2x + 4*0 >= 20 -> x >= 10
    #    3x + 0 >= 30   -> x >= 10
    # The minimal feasible point on x-axis is x = 10, y = 0 (already included).
    
    # 3) Intersection of vitamin constraint with y-axis (x = 0):
    #    2*0 + 4y >= 20 -> y >= 5
    #    3*0 +  y >= 30 -> y >= 30
    # So minimal feasible is y = 30, x = 0
    x = 0.0
    y = 30.0
    if x >= 0 and y >= 0:
        if 2*x + 4*y >= 20 and 3*x + y >= 30:
            candidates.append((x, y))
    
    # 4) Intersection of mineral constraint with x-axis (y = 0):
    #    3x >= 30 -> x >= 10
    #    2x >= 20 -> x >= 10
    # Minimal feasible is x = 10, y = 0 (already included).
    
    # 5) Intersection of mineral constraint with y-axis (x = 0):
    #    y >= 30 and 4y >= 20 -> y >= 30
    # Minimal feasible is x = 0, y = 30 (already included).
    
    # Now evaluate objective at candidates and pick minimum.
    best_value = float('inf')
    for x, y in candidates:
        cost = 3*x + 5*y
        if cost < best_value:
            best_value = cost
    
    return float(best_value)
```",30.0,True,0.0,0.0,4.301736116409302,
137,64.0,"```python
def solve():
    # We solve the LP:
    # Minimize F = 4x + 6y
    # Subject to:
    # 5x + 8y >= 80   (vitamin A)
    # 7x + 4y >= 100  (vitamin C)
    # y <= (2/3)x     (at most 40% lobster: y <= 0.4(x+y) -> 3y <= 2x)
    # x >= 0, y >= 0
    
    # We'll search over candidate intersection points of constraint boundaries.
    # Constraints in equality form for intersections:
    # 1) 5x + 8y = 80
    # 2) 7x + 4y = 100
    # 3) 3y = 2x
    # 4) x = 0
    # 5) y = 0
    
    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 5*x + 8*y < 80 - 1e-9:
            return False
        if 7*x + 4*y < 100 - 1e-9:
            return False
        if y > (2.0/3.0)*x + 1e-9:
            return False
        return True

    candidates = []

    # Intersection of (1) and (2)
    # 5x + 8y = 80
    # 7x + 4y = 100
    # Solve:
    # From first: x = (80 - 8y)/5
    # Plug into second:
    # 7(80 - 8y)/5 + 4y = 100
    # 560 - 56y + 20y = 500
    # 560 - 36y = 500
    # 36y = 60 -> y = 60/36 = 5/3
    y = 5.0 / 3.0
    x = (80 - 8*y) / 5.0
    candidates.append((x, y))

    # Intersection of (1) and (3): 5x + 8y = 80, 3y = 2x -> y = (2/3)x
    # 5x + 8*(2/3)x = 80 -> 5x + 16/3 x = 80 -> (15/3 + 16/3)x = 80
    # (31/3)x = 80 -> x = 240/31, y = (2/3)x
    x = 240.0 / 31.0
    y = (2.0 / 3.0) * x
    candidates.append((x, y))

    # Intersection of (2) and (3): 7x + 4y = 100, 3y = 2x -> y = (2/3)x
    # 7x + 4*(2/3)x = 100 -> 7x + 8/3 x = 100 -> (21/3 + 8/3)x = 100
    # (29/3)x = 100 -> x = 300/29, y = (2/3)x
    x = 300.0 / 29.0
    y = (2.0 / 3.0) * x
    candidates.append((x, y))

    # Intersections with axes:
    # x = 0 with (1): 8y = 80 -> y = 10
    x, y = 0.0, 10.0
    candidates.append((x, y))

    # x = 0 with (2): 4y = 100 -> y = 25
    x, y = 0.0, 25.0
    candidates.append((x, y))

    # y = 0 with (1): 5x = 80 -> x = 16
    x, y = 16.0, 0.0
    candidates.append((x, y))

    # y = 0 with (2): 7x = 100 -> x = 100/7
    x, y = 100.0 / 7.0, 0.0
    candidates.append((x, y))

    # Now evaluate feasible candidates and pick minimal objective
    best_val = None
    for x, y in candidates:
        if feasible(x, y):
            val = 4.0 * x + 6.0 * y
            if best_val is None or val < best_val:
                best_val = val

    # Return the optimal objective value as float
    return float(best_val)
```",63.333333333333336,False,0.6666666666666643,0.01041666666650387,6.552244424819946,
138,10060.0,"```python
def solve():
    # We minimize total baking time:
    # Let L = number of large pizzas, M = number of medium pizzas
    # Objective: minimize T = 12L + 8M
    #
    # Subject to:
    # 1) Dough: 12L + 8M >= 10000
    # 2) Toppings: 5L + 4M >= 4400
    # 3) Medium minimum: M >= 200
    # 4) Large at least twice medium: L >= 2M
    # 5) L, M >= 0
    #
    # This is a 2-variable LP; we can solve by enumerating candidate corner points
    # formed by intersections of constraint boundaries and checking feasibility.
    
    import math

    # Helper to check feasibility
    def feasible(L, M):
        if L < 0 or M < 0:
            return False
        if 12*L + 8*M < 10000 - 1e-9:
            return False
        if 5*L + 4*M < 4400 - 1e-9:
            return False
        if M < 200 - 1e-9:
            return False
        if L < 2*M - 1e-9:
            return False
        return True

    # Collect candidate points (L, M)
    candidates = []

    # 1) Intersection of dough and toppings:
    #    12L + 8M = 10000
    #    5L + 4M = 4400
    # Solve:
    # From second: 5L + 4M = 4400
    # Multiply by 2: 10L + 8M = 8800
    # Subtract from first: (12L+8M)-(10L+8M)=10000-8800 => 2L=1200 => L=600
    # Then 5*600 + 4M = 4400 => 3000 + 4M = 4400 => 4M=1400 => M=350
    L1, M1 = 600.0, 350.0
    candidates.append((L1, M1))

    # 2) Intersection of dough and L = 2M:
    #    12L + 8M = 10000
    #    L = 2M
    # => 12*(2M) + 8M = 10000 => 24M + 8M = 32M = 10000 => M = 312.5, L = 625
    M2 = 10000.0 / 32.0
    L2 = 2.0 * M2
    candidates.append((L2, M2))

    # 3) Intersection of toppings and L = 2M:
    #    5L + 4M = 4400
    #    L = 2M
    # => 5*(2M) + 4M = 4400 => 10M + 4M = 14M = 4400 => M = 314.2857..., L = 628.5714...
    M3 = 4400.0 / 14.0
    L3 = 2.0 * M3
    candidates.append((L3, M3))

    # 4) Intersection of dough and M = 200:
    #    12L + 8*200 = 10000 => 12L + 1600 = 10000 => 12L = 8400 => L = 700
    M4 = 200.0
    L4 = (10000.0 - 8.0 * M4) / 12.0
    candidates.append((L4, M4))

    # 5) Intersection of toppings and M = 200:
    #    5L + 4*200 = 4400 => 5L + 800 = 4400 => 5L = 3600 => L = 720
    M5 = 200.0
    L5 = (4400.0 - 4.0 * M5) / 5.0
    candidates.append((L5, M5))

    # 6) Intersection of M = 200 and L = 2M:
    #    M = 200 => L = 400
    L6, M6 = 400.0, 200.0
    candidates.append((L6, M6))

    # Evaluate feasible candidates and pick the one with minimal time
    best_val = math.inf
    best_point = None

    for L, M in candidates:
        if feasible(L, M):
            val = 12.0 * L + 8.0 * M
            if val < best_val:
                best_val = val
                best_point = (L, M)

    # If needed, we could also check that the optimum is not at infinity.
    # Here, constraints are "">= "", so the feasible region is unbounded above,
    # but we are minimizing, and we have lower bounds on L and M, so an optimum exists.
    #
    # best_point should be (600, 350) with objective 12*600 + 8*350 = 10000.
    # Return the optimal objective value as float.
    return float(best_val)
```",10057.142857142857,False,2.857142857143117,0.00028401022436807486,7.072073221206665,
139,670.0,"```python
def solve():
    # Let x = number of cars, y = number of buses
    # Constraints:
    # 1) 4x + 20y >= 300  (capacity)
    # 2) y <= 4           (at most 4 buses)
    # 3) x >= 0, y >= 0
    # Objective: minimize P = 10x + 30y
    
    # Since the problem is small, we can brute-force over integer y (0 to 4),
    # and compute the minimal feasible x for each y, then evaluate pollution.
    
    best_value = None
    
    for y in range(0, 5):  # y = 0,1,2,3,4
        # Capacity constraint: 4x + 20y >= 300
        # => 4x >= 300 - 20y
        required = 300 - 20 * y
        if required <= 0:
            # No cars needed to satisfy capacity
            x_min = 0
        else:
            # x must be at least ceil(required / 4)
            x_min = (required + 3) // 4  # integer ceiling
        
        # x must be nonnegative
        if x_min < 0:
            x_min = 0
        
        # Compute pollution for this (x_min, y)
        pollution = 10 * x_min + 30 * y
        
        if best_value is None or pollution < best_value:
            best_value = pollution
    
    return float(best_value)
```",670.0,True,0.0,0.0,2.1504743099212646,
140,1000.0,"```python
def solve():
    # We want to minimize total time: z = x + y
    # Subject to:
    # 1) Anti-itch injections: 800x + 650y >= 800000
    # 2) Topical cream:       700x + 750y >= 700000
    # 3) Plastic:             40x + 35y  <= 60000
    # 4) x >= 0, y >= 0
    
    # This is a 2-variable linear program; the optimum (if feasible and bounded)
    # occurs at a vertex of the feasible region. Vertices come from intersections
    # of pairs of constraint boundaries (including axes).
    
    # We'll compute all candidate intersection points, check feasibility,
    # and take the one with minimal x + y.
    
    import math
    
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 800*x + 650*y < 800000:
            return False
        if 700*x + 750*y < 700000:
            return False
        if 40*x + 35*y > 60000:
            return False
        return True
    
    candidates = []
    
    # Helper to solve a 2x2 linear system:
    # a1*x + b1*y = c1
    # a2*x + b2*y = c2
    def solve_two_eq(a1, b1, c1, a2, b2, c2):
        det = a1*b2 - a2*b1
        if abs(det) < 1e-12:
            return None
        x = (c1*b2 - c2*b1) / det
        y = (a1*c2 - a2*c1) / det
        return (x, y)
    
    # Intersections of constraint boundaries:
    # C1: 800x + 650y = 800000
    # C2: 700x + 750y = 700000
    # C3: 40x + 35y  = 60000
    
    # C1 & C2
    sol = solve_two_eq(800, 650, 800000, 700, 750, 700000)
    if sol is not None:
        candidates.append(sol)
    
    # C1 & C3
    sol = solve_two_eq(800, 650, 800000, 40, 35, 60000)
    if sol is not None:
        candidates.append(sol)
    
    # C2 & C3
    sol = solve_two_eq(700, 750, 700000, 40, 35, 60000)
    if sol is not None:
        candidates.append(sol)
    
    # Intersections with axes:
    # x = 0 with each constraint boundary
    # For C1: 650y = 800000 -> y = 800000/650
    candidates.append((0.0, 800000.0/650.0))
    # For C2: 750y = 700000 -> y = 700000/750
    candidates.append((0.0, 700000.0/750.0))
    # For C3: 35y = 60000 -> y = 60000/35
    candidates.append((0.0, 60000.0/35.0))
    
    # y = 0 with each constraint boundary
    # For C1: 800x = 800000 -> x = 800000/800
    candidates.append((800000.0/800.0, 0.0))
    # For C2: 700x = 700000 -> x = 700000/700
    candidates.append((700000.0/700.0, 0.0))
    # For C3: 40x = 60000 -> x = 60000/40
    candidates.append((60000.0/40.0, 0.0))
    
    best_val = math.inf
    best_point = None
    
    for (x, y) in candidates:
        if feasible(x, y):
            val = x + y
            if val < best_val:
                best_val = val
                best_point = (x, y)
    
    # Return the optimal objective value (minimal total time in hours)
    # If no feasible solution found (should not happen here), return NaN
    if best_point is None:
        return float('nan')
    return float(best_val)
```",1000.0,True,0.0,0.0,4.403912544250488,
141,40.0,"```python
def solve():
    # We want to maximize seating: 6L + 2S
    # Subject to:
    # 1) Cost: 300L + 100S <= 2000
    # 2) Space: 10L + 4S <= 200
    # 3) L, S >= 0 and integers (number of desks)
    
    best_value = -1.0
    
    # Upper bounds from constraints:
    # From cost: 300L <= 2000 -> L <= 6 (since 7*300=2100>2000)
    # From space: 10L <= 200 -> L <= 20
    # So L in [0, 6]
    for L in range(0, 7):
        # For each L, find max feasible S
        # Cost: 300L + 100S <= 2000 -> S <= (2000 - 300L)/100
        # Space: 10L + 4S <= 200 -> S <= (200 - 10L)/4
        max_S_cost = (2000 - 300 * L) // 100
        max_S_space = (200 - 10 * L) // 4
        max_S = int(min(max_S_cost, max_S_space))
        
        if max_S < 0:
            continue
        
        # Since objective is increasing in S (coefficient 2 > 0),
        # best S for given L is this maximum feasible S.
        S = max_S
        
        value = 6 * L + 2 * S
        if value > best_value:
            best_value = value
    
    return float(best_value)
```",40.0,True,0.0,0.0,2.4595510959625244,
142,306.0,"```python
def solve():
    # We model:
    # x = number of gummies
    # y = number of pills
    #
    # Maximize zinc: 4x + 5y
    # Subject to:
    # 1) Magnesium: 3x + 2y <= 200
    # 2) At least 10 pills: y >= 10
    # 3) Gummies at least 3 times pills: x >= 3y
    # 4) x, y >= 0
    #
    # This is a small 2-variable LP; we can solve it analytically by checking
    # the feasible corner points formed by intersecting constraints.
    #
    # Constraints in standard form:
    # (A) 3x + 2y <= 200
    # (B) y >= 10
    # (C) x >= 3y
    #
    # Candidate corner points come from intersections of:
    # - (A) with (B)
    # - (A) with (C)
    # - (B) with (C)
    #
    # 1) (B) and (C): y = 10, x = 3y = 30
    #    Check (A): 3*30 + 2*10 = 90 + 20 = 110 <= 200 -> feasible
    #
    # 2) (A) and (B): y = 10, 3x + 2*10 = 200 -> 3x + 20 = 200 -> x = 60
    #    Check (C): x >= 3y -> 60 >= 30 -> feasible
    #
    # 3) (A) and (C): x = 3y, so 3*(3y) + 2y = 200 -> 9y + 2y = 11y = 200
    #    -> y = 200/11, x = 600/11
    #    Check (B): y >= 10? 200/11 â‰ˆ 18.18 >= 10 -> feasible
    #
    # Evaluate objective 4x + 5y at each feasible corner:
    #
    # P1: (x, y) = (30, 10)
    #     Z1 = 4*30 + 5*10 = 120 + 50 = 170
    #
    # P2: (x, y) = (60, 10)
    #     Z2 = 4*60 + 5*10 = 240 + 50 = 290
    #
    # P3: (x, y) = (600/11, 200/11)
    #     Z3 = 4*(600/11) + 5*(200/11)
    #        = (2400/11) + (1000/11)
    #        = 3400/11
    #
    # Compare:
    # 170, 290, and 3400/11 â‰ˆ 309.09
    # Maximum is 3400/11.
    #
    # The function should return the optimal objective value as a float.
    return 3400.0 / 11.0
```",309.09090909090907,False,3.090909090909065,0.010101010100977007,3.892195224761963,
143,-99999.0,"```python
def solve():
    # We solve the LP:
    # Minimize K = 4x + 12y
    # Subject to:
    # 8x + 15y >= 150   (Vitamin A)
    # 6x +  2y >= 300   (Vitamin D)
    # 10x + 20y <= 400  (Vitamin E)
    # x >= 0, y >= 0
    
    # We'll find all intersection points of the constraint boundaries,
    # then check which are feasible, and pick the one with minimum K.
    
    import math

    def intersect(a1, b1, c1, a2, b2, c2):
        # Solve:
        # a1 x + b1 y = c1
        # a2 x + b2 y = c2
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-9:
            return None
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)

    def feasible(x, y):
        eps = 1e-9
        if x < -eps or y < -eps:
            return False
        # A: 8x + 15y >= 150
        if 8 * x + 15 * y < 150 - eps:
            return False
        # D: 6x + 2y >= 300
        if 6 * x + 2 * y < 300 - eps:
            return False
        # E: 10x + 20y <= 400
        if 10 * x + 20 * y > 400 + eps:
            return False
        return True

    candidates = []

    # Intersections of pairs of constraint boundaries:
    # A: 8x + 15y = 150
    # D: 6x + 2y = 300
    # E: 10x + 20y = 400
    # x = 0, y = 0

    # A & D
    p = intersect(8, 15, 150, 6, 2, 300)
    if p is not None:
        candidates.append(p)

    # A & E
    p = intersect(8, 15, 150, 10, 20, 400)
    if p is not None:
        candidates.append(p)

    # D & E
    p = intersect(6, 2, 300, 10, 20, 400)
    if p is not None:
        candidates.append(p)

    # With x = 0
    # A: 15y = 150 -> y = 10
    candidates.append((0.0, 150.0 / 15.0))
    # D: 2y = 300 -> y = 150
    candidates.append((0.0, 300.0 / 2.0))
    # E: 20y = 400 -> y = 20
    candidates.append((0.0, 400.0 / 20.0))

    # With y = 0
    # A: 8x = 150 -> x = 150/8
    candidates.append((150.0 / 8.0, 0.0))
    # D: 6x = 300 -> x = 50
    candidates.append((300.0 / 6.0, 0.0))
    # E: 10x = 400 -> x = 40
    candidates.append((400.0 / 10.0, 0.0))

    best_val = math.inf

    for (x, y) in candidates:
        if feasible(x, y):
            val = 4 * x + 12 * y
            if val < best_val:
                best_val = val

    # Return the optimal objective value as float
    return float(best_val)
```",inf,False,inf,inf,5.427123546600342,
144,1070.0,"```python
def solve():
    # We want to maximize: 5.5*x1 + 12*x2
    # Subject to:
    # 0 <= x1 <= 100
    # 0 <= x2 <= 80
    # x1 + x2 <= 100

    # This is a 2-variable LP; we can solve by checking all corner points.
    # Feasible region corners:
    # (0,0), (100,0), (0,80), (20,80), (100,0) already listed, and (100,0) vs (100,?) with x1+x2<=100
    # More systematically, we enumerate all intersections of constraints.

    candidates = []

    # Helper to check feasibility
    def feasible(x1, x2):
        return (
            x1 >= 0 and x2 >= 0 and
            x1 <= 100 and x2 <= 80 and
            x1 + x2 <= 100
        )

    # List potential intersection points:
    # 1) (0,0)
    candidates.append((0.0, 0.0))

    # 2) x1 = 100, x2 = 0
    candidates.append((100.0, 0.0))

    # 3) x1 = 0, x2 = 80
    candidates.append((0.0, 80.0))

    # 4) x1 + x2 = 100 with x2 = 80 -> x1 = 20
    candidates.append((20.0, 80.0))

    # 5) x1 + x2 = 100 with x1 = 100 -> x2 = 0 (already included)
    # 6) x1 = 0 with x1 + x2 = 100 -> x2 = 100, but violates x2 <= 80, so ignore

    best_value = float('-inf')
    for x1, x2 in candidates:
        if feasible(x1, x2):
            value = 5.5 * x1 + 12.0 * x2
            if value > best_value:
                best_value = value

    return best_value
```",1070.0,True,0.0,0.0,2.6652369499206543,
145,60.0,"```python
def solve():
    # We want to minimize total vans: x + y
    # Subject to:
    # 500x + 300y >= 20000  (packages)
    # 200x + 100y <= 7000  (pollution)
    # x, y >= 0
    
    # This is a 2-variable LP; we can solve analytically by checking corner points.
    # Convert constraints to equalities to find intersections:
    # (1) 500x + 300y = 20000
    # (2) 200x + 100y = 7000
    
    # Solve (2) for y: y = 70 - 2x
    # Substitute into (1):
    # 500x + 300(70 - 2x) = 20000
    # 500x + 21000 - 600x = 20000
    # -100x = -1000 -> x = 10
    # y = 70 - 2*10 = 50
    x_int = 10.0
    y_int = 50.0
    
    # Check feasibility of intersection:
    # Packages: 500*10 + 300*50 = 20000 (meets)
    # Pollution: 200*10 + 100*50 = 7000 (meets)
    # So (10, 50) is feasible.
    
    # Now check boundary points where one variable is zero.
    # 1) x = 0:
    #    Packages: 300y >= 20000 -> y >= 20000/300
    #    Pollution: 100y <= 7000 -> y <= 70
    #    20000/300 â‰ˆ 66.666..., so feasible y in [66.666..., 70]
    #    Objective x + y minimized at smallest feasible y: y = 20000/300
    y_x0 = 20000.0 / 300.0
    if y_x0 <= 70.0:
        obj_x0 = 0.0 + y_x0
    else:
        obj_x0 = float('inf')  # infeasible
    
    # 2) y = 0:
    #    Packages: 500x >= 20000 -> x >= 40
    #    Pollution: 200x <= 7000 -> x <= 35
    #    No feasible x, so ignore.
    obj_y0 = float('inf')
    
    # 3) Intersection point:
    obj_int = x_int + y_int
    
    # The feasible candidates are (0, 20000/300) and (10, 50).
    # Compare objective values:
    best_obj = min(obj_x0, obj_int, obj_y0)
    
    # Return the optimal objective value as float
    return float(best_obj)
```",60.0,True,0.0,0.0,2.9699103832244873,
146,50.0,"```python
def solve():
    # Let a = servings of apple, c = servings of carrot
    # Constraints:
    # 1) a = 3c
    # 2) c >= 2
    # 3) Folate: 5a + 3c <= 100
    #
    # Substitute a = 3c into folate constraint:
    # 5(3c) + 3c <= 100  ->  15c + 3c <= 100  ->  18c <= 100  ->  c <= 100/18
    #
    # So 2 <= c <= 100/18. Fat to maximize:
    # Fat = 2a + 4c = 2(3c) + 4c = 10c, which is increasing in c.
    # Thus optimal c is the largest feasible: c = 100/18, a = 3c = 300/18.
    #
    # Objective value (max fat) = 10c = 10 * (100/18) = 1000/18.

    c = 100.0 / 18.0
    max_fat = 10.0 * c
    return max_fat
```",55.55555555555556,False,5.555555555555557,0.11111111110888892,2.2144250869750977,
147,16666.666666666664,"```python
def solve():
    # Let x = hours for specialized company
    #     y = hours for common company
    #
    # Objective: minimize cost = 100x + 72y
    #
    # Constraints:
    # 1) Image requirement: 60x + 40y >= 10000
    # 2) At least 1/3 of images by specialized:
    #       60x >= (1/3)*(60x + 40y)
    #    Multiply both sides by 3:
    #       180x >= 60x + 40y
    #       120x >= 40y
    #       3x >= y
    #       y <= 3x
    # 3) x, y >= 0
    #
    # We solve analytically by checking corner points of the feasible region.
    #
    # From 60x + 40y >= 10000 and y <= 3x, the boundary intersection is:
    #   y = 3x
    #   60x + 40(3x) = 60x + 120x = 180x = 10000  =>  x = 10000/180
    #   y = 3 * 10000/180
    #
    # Cost at this point:
    x = 10000.0 / 180.0
    y = 3.0 * x
    cost = 100.0 * x + 72.0 * y
    return cost
```",17555.55555555556,False,888.8888888888941,0.05333333333333046,1.8750529289245605,
148,75.0,"```python
def solve():
    # We need to minimize total trips: T + V
    # Subject to:
    # 1) Capacity: 1000T + 500V >= 50000
    # 2) Budget: 300T + 100V <= 12500
    # 3) Truck-van relation: T <= V
    # 4) T, V are nonnegative integers

    best_trips = None

    # Upper bounds for search:
    # From capacity alone: max trips if all vans: 500V >= 50000 -> V >= 100
    # From budget alone: if all vans: 100V <= 12500 -> V <= 125
    # If all trucks: 300T <= 12500 -> T <= 41 (since 41*300=12300, 42*300=12600>12500)
    # We'll search a reasonable range for T and V.
    for T in range(0, 50):  # small upper bound for trucks
        for V in range(0, 150):  # small upper bound for vans
            # Check constraints
            if 1000 * T + 500 * V < 50000:
                continue
            if 300 * T + 100 * V > 12500:
                continue
            if T > V:
                continue

            trips = T + V
            if best_trips is None or trips < best_trips:
                best_trips = trips

    # Return the optimal objective value as float
    return float(best_trips)
```",75.0,True,0.0,0.0,2.3683996200561523,
149,71.0,"```python
def solve():
    # Let x = number of otters, y = number of dolphins
    # Objective: maximize tricks = 3x + y
    # Constraints:
    # 1) Treats: 3x + 5y <= 200
    # 2) At least 10 dolphins: y >= 10
    # 3) At most 30% performers are otters: x <= (3/7) * y
    # 4) x, y >= 0 and integers (implicitly, since they are counts)
    #
    # We'll brute force over reasonable integer ranges for x and y.

    best_value = float('-inf')

    # Upper bounds:
    # From treats: 3x + 5y <= 200 => x <= (200 - 5y)/3, y <= 40 (since 5*40=200)
    # From ratio: x <= (3/7)*y
    # We'll loop y from 10 to 40 and x from 0 to a safe upper bound.
    for y in range(10, 41):  # y >= 10, and 5*y <= 200 => y <= 40
        # Max x from treats
        max_x_treats = (200 - 5 * y) // 3
        if max_x_treats < 0:
            continue
        # Max x from ratio x <= (3/7)*y
        max_x_ratio = int((3 * y) // 7)
        max_x = min(max_x_treats, max_x_ratio)
        if max_x < 0:
            continue

        for x in range(max_x + 1):
            # Check constraints explicitly (though bounds should ensure feasibility)
            if 3 * x + 5 * y <= 200 and x <= (3 * y) / 7 and y >= 10:
                value = 3 * x + y
                if value > best_value:
                    best_value = value

    return float(best_value)
```",71.0,True,0.0,0.0,3.2759194374084473,
150,6000.0,"```python
def solve():
    # We need to solve the LP:
    # Maximize 50x + 20y
    # subject to:
    #   x <= 100
    #   y <= 170
    #   x + y <= 150
    #   x >= 0, y >= 0
    #
    # We'll enumerate the corner points of the feasible region and
    # compute the objective value at each, then return the maximum.
    
    # List of candidate corner points (x, y):
    # Intersections of constraints and axes:
    candidates = []
    
    # 1) (0, 0)
    candidates.append((0.0, 0.0))
    
    # 2) (100, 0) from x=100, y=0 (check x+y<=150, y<=170)
    if 100 + 0 <= 150 and 0 <= 170:
        candidates.append((100.0, 0.0))
    
    # 3) (0, 150) from y=150, x=0 (check y<=170)
    if 150 <= 170:
        candidates.append((0.0, 150.0))
    
    # 4) (100, 50) from x=100 and x+y=150 => y=50 (check y<=170)
    if 50 <= 170:
        candidates.append((100.0, 50.0))
    
    # 5) ( - ) intersection of y=170 and x+y=150 gives x=-20 (infeasible)
    # so we skip it.
    
    # 6) (0, 170) from y=170, x=0 (check x+y<=150) -> 170>150 infeasible
    # so we skip it.
    
    max_profit = float('-inf')
    for x, y in candidates:
        profit = 50 * x + 20 * y
        if profit > max_profit:
            max_profit = profit
    
    return float(max_profit)
```",6000.0,True,0.0,0.0,2.4609973430633545,
151,5.0,"```python
def solve():
    # We want to minimize x + y
    # Subject to:
    # 50x + 35y >= 250
    # 3x + 2y <= 16
    # x, y >= 0 and integers (number of factories)
    
    best_value = None
    
    # Since 3x + 2y <= 16 and x, y >= 0, x and y are bounded.
    # Max x occurs when y=0: 3x <= 16 -> x <= 5
    # Max y occurs when x=0: 2y <= 16 -> y <= 8
    for x in range(0, 6):      # 0 to 5
        for y in range(0, 9):  # 0 to 8
            if 50 * x + 35 * y >= 250 and 3 * x + 2 * y <= 16:
                value = x + y
                if best_value is None or value < best_value:
                    best_value = value
    
    # Return the minimal number of factories (objective value)
    return float(best_value)
```",5.0,True,0.0,0.0,1.7389943599700928,
152,6.0,"```python
def solve():
    # We model:
    # x = number of gas grills
    # y = number of electric grills
    #
    # Constraints:
    # 1) Capacity: 20x + 30y >= 150
    # 2) Oil:      20x + 25y <= 140
    # 3) Taste:    y < x  -> with integers, y <= x - 1
    # 4) x, y >= 0 and integers
    #
    # Objective: minimize x + y
    #
    # We'll brute-force over a reasonable range of x, y.
    # Upper bound: since 20x + 30y >= 150, even if all are electric:
    #   30y >= 150 -> y >= 5
    # and if all are gas:
    #   20x >= 150 -> x >= 8
    # Oil constraint 20x + 25y <= 140 also limits x, y.
    # We'll just search x, y in [0, 20] which is more than enough.

    best_value = None

    for x in range(0, 21):
        for y in range(0, 21):
            # Taste constraint: y <= x - 1
            if y > x - 1:
                continue

            # Capacity constraint
            if 20 * x + 30 * y < 150:
                continue

            # Oil constraint
            if 20 * x + 25 * y > 140:
                continue

            total_grills = x + y
            if best_value is None or total_grills < best_value:
                best_value = total_grills

    # Return the optimal objective value (minimum total number of grills)
    return float(best_value if best_value is not None else 0.0)
```",0.0,False,6.0,0.9999999998333333,2.2556700706481934,
153,-99999.0,"```python
def solve():
    # Let x = number of ultrasound technician shifts
    # Let y = number of graduate researcher shifts
    #
    # Constraints:
    # 1) Hours requirement: 8x + 5y >= 500
    # 2) Budget: 300x + 100y <= 14000
    # 3) Regulation: x = 2y  (twice as many technician shifts as researcher shifts)
    # Objective: minimize total workers = x + y
    #
    # Substitute x = 2y into constraints:
    # Hours: 8*(2y) + 5y = 16y + 5y = 21y >= 500  => y >= 500/21
    # Budget: 300*(2y) + 100y = 600y + 100y = 700y <= 14000 => y <= 14000/700 = 20
    #
    # We want to minimize x + y = 2y + y = 3y, so choose smallest feasible y.
    # If workers must be in whole shifts, y must be integer and y >= ceil(500/21).
    # 500/21 â‰ˆ 23.81, but that exceeds the budget upper bound y <= 20.
    # So there is no integer-feasible solution.
    #
    # If we allow fractional shifts (continuous LP), the feasible region is:
    # y in [500/21, 20], and we minimize 3y, so choose y = 500/21.
    # Then x = 2y = 1000/21.
    #
    # The question asks for the optimal objective value (minimum number of workers).
    # That is 3y = 3 * (500/21) = 1500/21.
    #
    # Return this as a float.
    return 1500.0 / 21.0
```",71.42857142857143,False,100070.42857142857,1.0007142928572041,2.3578600883483887,
154,95.0,"```python
def solve():
    # Let x = number of cart servers
    #     y = number of hand servers
    #
    # Objective: minimize total refills
    #   R = 5x + 20y
    #
    # Constraints:
    #   1) Customer interactions: 70x + 85y = 4000
    #   2) At least 70% of shifts by cart: x >= 0.7(x + y)
    #   3) At least 3 hand servers: y >= 3
    #   4) x, y >= 0
    #
    # From 2): x >= 0.7x + 0.7y  =>  0.3x >= 0.7y  =>  x >= (7/3) y

    # Express x from the interaction constraint:
    #   70x + 85y = 4000  =>  x = (4000 - 85y) / 70

    best_refills = None

    # We search over feasible y (hand servers).
    # y must be at least 3, and such that x >= 0 and x >= (7/3)*y.
    # Also x must be nonnegative, so 4000 - 85y >= 0 => y <= 4000/85.
    max_y = int(4000 // 85)  # upper bound for y to keep x >= 0

    for y in range(3, max_y + 1):
        x = (4000 - 85 * y) / 70.0
        if x < 0:
            continue
        if x < (7.0 / 3.0) * y:
            continue
        # Feasible (x, y); compute refills
        refills = 5.0 * x + 20.0 * y
        if best_refills is None or refills < best_refills:
            best_refills = refills

    # Return the optimal objective value as a float
    return float(best_refills)
```",327.5,False,232.5,2.44736842102687,2.5596821308135986,
155,133200.0,"```python
def solve():
    # We solve the LP:
    # Maximize 400x + 260y
    # subject to:
    # 60x + 45y <= 20000   (mover time)
    # 20x + 25y <= 13000   (setup time)
    # x >= 0, y >= 0
    
    # The optimal solution of a 2-variable LP lies at a corner (feasible vertex).
    # Candidate corners come from intersections of constraints and axes.
    
    # 1) Intersection with axes:
    #    a) x = 0:
    #       45y <= 20000  -> y <= 20000/45
    #       25y <= 13000  -> y <= 13000/25
    #       So y = min(20000/45, 13000/25)
    y1 = min(20000.0 / 45.0, 13000.0 / 25.0)
    x1 = 0.0
    
    #    b) y = 0:
    #       60x <= 20000  -> x <= 20000/60
    #       20x <= 13000  -> x <= 13000/20
    #       So x = min(20000/60, 13000/20)
    x2 = min(20000.0 / 60.0, 13000.0 / 20.0)
    y2 = 0.0
    
    # 2) Intersection of the two constraint lines:
    #    60x + 45y = 20000
    #    20x + 25y = 13000
    #
    # Solve the system:
    # From second: 20x + 25y = 13000
    # Multiply by 3: 60x + 75y = 39000
    # Subtract first: (60x+75y) - (60x+45y) = 39000 - 20000
    #                 30y = 19000 -> y = 19000/30
    y3 = 19000.0 / 30.0
    # Plug back into 20x + 25y = 13000:
    x3 = (13000.0 - 25.0 * y3) / 20.0
    
    # Check feasibility (nonnegative and satisfy constraints)
    candidates = []
    for x, y in [(x1, y1), (x2, y2), (x3, y3)]:
        if x >= 0 and y >= 0:
            if 60.0 * x + 45.0 * y <= 20000.0 + 1e-9 and 20.0 * x + 25.0 * y <= 13000.0 + 1e-9:
                candidates.append((x, y))
    
    # Evaluate objective 400x + 260y at each feasible candidate
    best_value = None
    for x, y in candidates:
        value = 400.0 * x + 260.0 * y
        if best_value is None or value > best_value:
            best_value = value
    
    return float(best_value)
```",133333.3333333333,False,133.33333333331393,0.001001001001000848,3.2806217670440674,
156,217.0,"```python
def solve():
    # We want to maximize: 2.50*x1 + 3.55*x2
    # Subject to:
    #   x1 <= 50
    #   x2 <= 40
    #   x1 + x2 <= 70
    #   x1 >= 0, x2 >= 0
    #
    # We'll enumerate all corner points of the feasible region and
    # compute the objective value at each, then return the maximum.

    corners = []

    # Potential corner points come from intersections of constraints:
    # 1) (0, 0)
    corners.append((0.0, 0.0))

    # 2) (50, 0) from x1=50, x2=0
    if 50 <= 70:
        corners.append((50.0, 0.0))

    # 3) (0, 40) from x1=0, x2=40
    if 40 <= 70:
        corners.append((0.0, 40.0))

    # 4) (50, 40) from x1=50, x2=40 (check x1+x2<=70)
    if 50 + 40 <= 70:
        corners.append((50.0, 40.0))

    # 5) Intersection of x1=50 and x1+x2=70 -> x2=20
    x1, x2 = 50.0, 70.0 - 50.0
    if 0 <= x2 <= 40:
        corners.append((x1, x2))

    # 6) Intersection of x2=40 and x1+x2=70 -> x1=30
    x2 = 40.0
    x1 = 70.0 - 40.0
    if 0 <= x1 <= 50:
        corners.append((x1, x2))

    # Remove duplicates (if any)
    unique_corners = []
    seen = set()
    for x1, x2 in corners:
        key = (round(x1, 10), round(x2, 10))
        if key not in seen:
            seen.add(key)
            unique_corners.append((x1, x2))

    # Evaluate objective at each corner
    best_value = float('-inf')
    for x1, x2 in unique_corners:
        value = 2.50 * x1 + 3.55 * x2
        if value > best_value:
            best_value = value

    return best_value
```",217.0,True,0.0,0.0,2.9693727493286133,
157,78.0,"```python
def solve():
    # We define:
    # x = number of taxi rides
    # y = number of company car rides
    #
    # Constraints:
    # 1) Employee capacity: 2x + 3y >= 500
    # 2) At most 60% of rides are company cars: y <= 0.6(x + y)
    #    => y <= 0.6x + 0.6y
    #    => 0.4y <= 0.6x
    #    => y <= 1.5x
    # 3) At least 30 company car rides: y >= 30
    # 4) x, y >= 0 and (implicitly) integer, since rides are discrete.
    #
    # Objective: minimize x (number of taxi rides).
    #
    # We will brute-force over integer y and compute the minimal feasible x.
    # From 2x + 3y >= 500 => x >= (500 - 3y)/2
    # From y <= 1.5x      => x >= y / 1.5
    #
    # For each integer y >= 30, we compute the smallest integer x satisfying:
    #   x >= max((500 - 3y)/2, y/1.5, 0)
    # and check feasibility. We search over a reasonable range for y.
    #
    # Upper bound for y:
    # If we used only company cars: 3y >= 500 => y >= 167 (approx).
    # So y in [30, 200] is more than enough.

    best_x = None

    for y in range(30, 201):
        # Compute lower bounds on x from constraints
        lb1 = (500 - 3 * y) / 2.0  # from 2x + 3y >= 500
        lb2 = y / 1.5              # from y <= 1.5x
        lb3 = 0.0                  # non-negativity

        x_min = max(lb1, lb2, lb3)

        # x must be integer and at least x_min
        # If x_min is already > some large bound, skip
        if x_min > 1000:
            continue

        # Smallest integer >= x_min
        x = int(x_min) if x_min == int(x_min) else int(x_min) + 1

        # Check feasibility explicitly
        if 2 * x + 3 * y >= 500 and y <= 1.5 * x and y >= 30 and x >= 0:
            if best_x is None or x < best_x:
                best_x = x

    # Return the optimal objective value (minimal number of taxi rides) as float
    return float(best_x)
```",78.0,True,0.0,0.0,3.502431631088257,
158,23.5,"```python
def solve():
    # We solve the LP:
    # Minimize  6.5*h + 4*w
    # s.t.
    #   800h + 450w >= 2200   (calories)
    #   19h  + 12w  >= 50     (protein)
    #   20h  + 10w  >= 70     (carbs)
    #   h, w >= 0
    #
    # For two variables, the optimum lies at a corner (intersection of constraints or axes).
    # We'll enumerate all candidate corner points formed by pairs of constraints and axes,
    # check feasibility, and take the minimum cost.

    import math

    # Helper to solve a 2x2 linear system:
    # a1*x + b1*y = c1
    # a2*x + b2*y = c2
    def solve_2x2(a1, b1, c1, a2, b2, c2):
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-12:
            return None  # parallel or nearly parallel
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return x, y

    # Constraints in >= form:
    # 1) 800h + 450w >= 2200
    # 2) 19h  + 12w  >= 50
    # 3) 20h  + 10w  >= 70
    #
    # We'll consider intersections of:
    # (1)&(2), (1)&(3), (2)&(3),
    # and each constraint with h=0 or w=0,
    # plus the axes intersections that individually satisfy all constraints.

    candidates = []

    # Intersections of pairs of constraints (as equalities)
    # (1) & (2)
    sol = solve_2x2(800, 450, 2200, 19, 12, 50)
    if sol is not None:
        candidates.append(sol)

    # (1) & (3)
    sol = solve_2x2(800, 450, 2200, 20, 10, 70)
    if sol is not None:
        candidates.append(sol)

    # (2) & (3)
    sol = solve_2x2(19, 12, 50, 20, 10, 70)
    if sol is not None:
        candidates.append(sol)

    # Intersections with h = 0
    # For each constraint, solve for w and then check all constraints.
    # 1) 800*0 + 450w >= 2200 -> w >= 2200/450
    w1 = 2200.0 / 450.0
    candidates.append((0.0, w1))

    # 2) 19*0 + 12w >= 50 -> w >= 50/12
    w2 = 50.0 / 12.0
    candidates.append((0.0, w2))

    # 3) 20*0 + 10w >= 70 -> w >= 70/10 = 7
    w3 = 70.0 / 10.0
    candidates.append((0.0, w3))

    # Intersections with w = 0
    # 1) 800h + 450*0 >= 2200 -> h >= 2200/800
    h1 = 2200.0 / 800.0
    candidates.append((h1, 0.0))

    # 2) 19h + 12*0 >= 50 -> h >= 50/19
    h2 = 50.0 / 19.0
    candidates.append((h2, 0.0))

    # 3) 20h + 10*0 >= 70 -> h >= 70/20 = 3.5
    h3 = 70.0 / 20.0
    candidates.append((h3, 0.0))

    # Also consider the possibility that a single constraint is binding
    # and others are slack, but those are already covered by the axis
    # intersections above and the pairwise intersections.

    def feasible(h, w):
        if h < -1e-9 or w < -1e-9:
            return False
        # Enforce non-negativity strictly
        h = max(h, 0.0)
        w = max(w, 0.0)
        if 800 * h + 450 * w < 2200 - 1e-9:
            return False
        if 19 * h + 12 * w < 50 - 1e-9:
            return False
        if 20 * h + 10 * w < 70 - 1e-9:
            return False
        return True

    best_cost = math.inf

    for h, w in candidates:
        if feasible(h, w):
            cost = 6.5 * h + 4.0 * w
            if cost < best_cost:
                best_cost = cost

    # Return the optimal objective value as float
    return float(best_cost)
```",22.75,False,0.75,0.031914893615663194,6.1290977001190186,
159,333.0,"```python
def solve():
    # We maximize total items: x + y
    # x = basketballs, y = footballs
    # Constraints:
    # 1) Material: 5x + 3y <= 1500
    # 2) Time:     x + 2y <= 750
    # 3) Demand:   x >= 3y
    # 4) Minimum footballs: y >= 50
    # 5) x, y >= 0
    
    # This is a 2-variable LP; we can solve by checking corner points of the feasible region.
    # We'll compute all candidate intersection points of constraint boundaries and
    # then keep those that satisfy all inequalities, and pick the one with max x + y.
    
    candidates = []
    
    # Helper to add candidate if feasible
    def add_if_feasible(x, y):
        # Check feasibility with a small tolerance for float arithmetic
        eps = 1e-9
        if x < -eps or y < -eps:
            return
        if 5*x + 3*y > 1500 + eps:
            return
        if x + 2*y > 750 + eps:
            return
        if x < 3*y - eps:
            return
        if y < 50 - eps:
            return
        candidates.append((x, y))
    
    # 1) Intersection of:
    #    5x + 3y = 1500
    #    x + 2y = 750
    # Solve:
    # From second: x = 750 - 2y
    # Plug into first: 5(750 - 2y) + 3y = 1500
    # 3750 - 10y + 3y = 1500 -> 3750 - 7y = 1500 -> 7y = 2250 -> y = 2250/7
    y = 2250.0 / 7.0
    x = 750.0 - 2.0 * y
    add_if_feasible(x, y)
    
    # 2) Intersection of:
    #    5x + 3y = 1500
    #    x = 3y
    # Plug x = 3y: 5(3y) + 3y = 1500 -> 15y + 3y = 1500 -> 18y = 1500 -> y = 1500/18
    y = 1500.0 / 18.0
    x = 3.0 * y
    add_if_feasible(x, y)
    
    # 3) Intersection of:
    #    5x + 3y = 1500
    #    y = 50
    y = 50.0
    x = (1500.0 - 3.0 * y) / 5.0
    add_if_feasible(x, y)
    
    # 4) Intersection of:
    #    x + 2y = 750
    #    x = 3y
    # Plug x = 3y: 3y + 2y = 750 -> 5y = 750 -> y = 150
    y = 150.0
    x = 3.0 * y
    add_if_feasible(x, y)
    
    # 5) Intersection of:
    #    x + 2y = 750
    #    y = 50
    y = 50.0
    x = 750.0 - 2.0 * y
    add_if_feasible(x, y)
    
    # 6) Intersection of:
    #    x = 3y
    #    y = 50
    y = 50.0
    x = 3.0 * y
    add_if_feasible(x, y)
    
    # Also consider potential corners on axes that satisfy y >= 50:
    # y = 50, x = 0
    y = 50.0
    x = 0.0
    add_if_feasible(x, y)
    
    # Now find the candidate with maximum x + y
    best_value = float('-inf')
    for x, y in candidates:
        value = x + y
        if value > best_value:
            best_value = value
    
    return float(best_value)
```",333.3333333333333,False,0.3333333333333144,0.0010010010009979381,5.1178154945373535,
160,29.0,"```python
def solve():
    # Let x = number of golf carts, y = number of pull carts
    # Constraints:
    # 1) 4x + y >= 80          (capacity)
    # 2) x <= 0.6(x + y)       (at most 60% are golf carts)
    #    => x <= 1.5y
    # Objective: minimize x + y
    
    # We solve analytically:
    # From x <= 1.5y and 4x + y >= 80, to minimize x + y we use equality in both:
    # x = 1.5y and 4x + y = 80
    # Substitute: 4(1.5y) + y = 80 => 6y + y = 80 => 7y = 80 => y = 80/7, x = 120/7
    # Objective value = x + y = 200/7
    
    return 200.0 / 7.0
```",28.571428571428573,False,0.42857142857142705,0.014778325122643059,2.0719594955444336,
161,1990.0,"```python
def solve():
    # We maximize honey: 5x + 20y
    # x = small bottles, y = large bottles
    # Constraints:
    # 1) x <= 300
    # 2) y <= 100
    # 3) x >= 2y
    # 4) x + y <= 200
    # 5) y >= 50
    # 6) x, y >= 0
    
    best_value = float('-inf')
    
    # y must be between 50 and 100 (from constraints 2 and 5)
    for y in range(50, 101):
        # From x >= 2y and x + y <= 200 and x <= 300
        x_min = 2 * y
        x_max = min(300, 200 - y)
        
        if x_min <= x_max and x_max >= 0:
            x = x_max  # choose largest feasible x to maximize honey
            value = 5 * x + 20 * y
            if value > best_value:
                best_value = value
    
    return float(best_value)
```",1990.0,True,0.0,0.0,2.2412712574005127,
162,70.0,"```python
def solve():
    # We want to maximize total jars: x (glass) + y (plastic)
    # Subject to:
    # 1) 250x + 300y <= 20000
    # 2) y >= 2x
    # 3) x >= 20
    # 4) x, y >= 0 and integers
    
    best_value = -1.0
    
    # Upper bound on x from honey constraint alone: 250x <= 20000 -> x <= 80
    # Also x >= 20
    for x in range(20, 81):
        # From y >= 2x
        y_min = 2 * x
        
        # From 250x + 300y <= 20000 -> 300y <= 20000 - 250x
        remaining = 20000 - 250 * x
        if remaining < 0:
            continue
        y_max = remaining // 300  # integer y
        
        if y_max < y_min:
            continue
        
        # To maximize x + y, choose largest feasible y
        y = y_max
        total_jars = x + y
        
        if total_jars > best_value:
            best_value = float(total_jars)
    
    return best_value
```",70.0,True,0.0,0.0,2.4224143028259277,
163,268.0,"```python
def solve():
    # We want to minimize the total number of teachers: x + y
    # where:
    # x = number of staff teachers
    # y = number of substitute teachers
    #
    # Constraints:
    # 1) Hours: 6x + 3y >= 1000
    # 2) Budget: 300x + 100y <= 40000
    # 3) x, y >= 0 and integers
    #
    # We'll brute force over feasible integer x and y, since bounds are small.
    
    best_value = None  # minimal x + y
    # Upper bounds: from budget constraint
    # 300x <= 40000 -> x <= 133.33 -> x <= 133
    # 100y <= 40000 -> y <= 400
    for x in range(134):  # 0..133
        # From budget: 300x + 100y <= 40000 -> y <= (40000 - 300x)/100
        max_y = int((40000 - 300 * x) // 100)
        if max_y < 0:
            continue
        # From hours: 6x + 3y >= 1000 -> y >= (1000 - 6x)/3
        min_y_float = (1000 - 6 * x) / 3.0
        min_y = int(min_y_float) if min_y_float == int(min_y_float) else int(min_y_float) + 1
        if min_y < 0:
            min_y = 0
        if min_y > max_y:
            continue
        # For fixed x, the objective x + y is minimized by taking the smallest feasible y
        y = min_y
        value = x + y
        if best_value is None or value < best_value:
            best_value = value

    # Return the minimal total number of teachers as a float
    return float(best_value)
```",268.0,True,0.0,0.0,2.933777093887329,
164,80000.0,"```python
def solve():
    # Let x = number of premium desktops
    #     y = number of regular desktops
    #
    # Maximize profit: 500x + 300y
    # Subject to:
    #   1) x + y <= 200          (sales limit)
    #   2) 2000x + 1000y <= 300000  (budget)
    #   3) x >= 0, y >= 0
    #
    # We can solve this small LP by enumerating corner points of the feasible region.
    # Corner points come from intersections of constraints:
    #   - (0,0)
    #   - Intersections with axes:
    #       From x + y = 200: (0,200), (200,0)
    #       From 2000x + 1000y = 300000: (0,300), (150,0)
    #   - Intersection of x + y = 200 and 2000x + 1000y = 300000

    candidates = []

    # 1) (0,0)
    candidates.append((0.0, 0.0))

    # 2) From x + y = 200 with nonnegativity:
    #    (0,200) and (200,0), but must also satisfy budget.
    pts = [(0.0, 200.0), (200.0, 0.0)]
    for x, y in pts:
        if x + y <= 200 + 1e-9 and 2000 * x + 1000 * y <= 300000 + 1e-9:
            candidates.append((x, y))

    # 3) From 2000x + 1000y = 300000 with nonnegativity:
    #    (0,300) and (150,0), but must also satisfy sales limit.
    pts = [(0.0, 300.0), (150.0, 0.0)]
    for x, y in pts:
        if x >= 0 and y >= 0 and x + y <= 200 + 1e-9:
            candidates.append((x, y))

    # 4) Intersection of x + y = 200 and 2000x + 1000y = 300000
    #    From x + y = 200 => y = 200 - x
    #    Substitute: 2000x + 1000(200 - x) = 300000
    #                2000x + 200000 - 1000x = 300000
    #                1000x = 100000 => x = 100, y = 100
    x_int, y_int = 100.0, 100.0
    if x_int >= 0 and y_int >= 0 and x_int + y_int <= 200 + 1e-9 and \
       2000 * x_int + 1000 * y_int <= 300000 + 1e-9:
        candidates.append((x_int, y_int))

    # Evaluate objective at all candidate points
    best_profit = float('-inf')
    for x, y in candidates:
        profit = 500 * x + 300 * y
        if profit > best_profit:
            best_profit = profit

    return float(best_profit)
```",80000.0,True,0.0,0.0,5.416095733642578,
165,7500.0,"```python
def solve():
    # Let x = number of patients with electronic thermometer
    #     y = number of patients with regular thermometer
    #
    # Maximize:  x + y
    # Subject to:
    #   3x + 2y <= 15000        (time constraint)
    #   x >= 2y                 (at least twice as many electronic as regular)
    #   y >= 50                 (at least 50 regular)
    #   x, y >= 0
    #
    # This is a small 2-variable LP; we can solve it analytically via corner points.

    # From x >= 2y and y >= 50, we know y >= 50 and x >= 100.
    # The time constraint is 3x + 2y <= 15000.
    #
    # For fixed y, to maximize x + y, we want x as large as possible:
    #   x <= (15000 - 2y) / 3  from time
    #   x >= 2y                from ratio
    #
    # Feasibility requires:
    #   2y <= (15000 - 2y) / 3
    #   6y <= 15000 - 2y
    #   8y <= 15000
    #   y <= 1875
    #
    # Also y >= 50, so y in [50, 1875].
    #
    # For each feasible y, best x is min( (15000 - 2y)/3, 2y ).
    # The objective is f(y) = x + y.
    #
    # The switch point where (15000 - 2y)/3 = 2y:
    #   15000 - 2y = 6y
    #   15000 = 8y
    #   y = 1875
    #
    # On [50, 1875), we have 2y < (15000 - 2y)/3, so x = 2y and
    #   f(y) = 3y, increasing in y, so best at y = 1875.
    #
    # At y = 1875, x = 2y = 3750, and time is exactly used:
    #   3*3750 + 2*1875 = 15000.
    #
    # So the optimal solution is x = 3750, y = 1875, with
    #   max patients = 3750 + 1875 = 5625.

    return float(3750 + 1875)
```",5625.0,False,1875.0,0.24999999999996667,3.6657824516296387,
166,24.0,"```python
def solve():
    # We need integer numbers of trips:
    # Let v = van trips, t = truck trips
    # Constraints:
    # 1) Capacity: 50v + 80t >= 1500
    # 2) Budget: 30v + 50t <= 1000
    # 3) Advertising: v > t
    # 4) v, t >= 0 and integers
    #
    # Objective: minimize total trips v + t

    best_value = None  # minimal v + t
    # Upper bounds for search (from budget constraint):
    # 30v + 50t <= 1000 => v <= 1000/30, t <= 1000/50
    max_v = 1000 // 30 + 1
    max_t = 1000 // 50 + 1

    for v in range(max_v + 1):
        for t in range(max_t + 1):
            if v <= t:  # must have v > t
                continue
            if 30 * v + 50 * t > 1000:
                continue
            if 50 * v + 80 * t < 1500:
                continue

            trips = v + t
            if best_value is None or trips < best_value:
                best_value = trips

    # The function should return the optimal objective value (minimal total trips)
    return float(best_value) if best_value is not None else None
```",24.0,True,0.0,0.0,2.116895914077759,
167,48.0,"```python
def solve():
    # We minimize total trips: x (freight) + y (air)
    # Subject to:
    # 1) Capacity: 5x + 3y >= 200
    # 2) Budget: 300x + 550y <= 20000
    # 3) Air proportion: 3y >= 0.3*(5x + 3y)  ->  21y >= 3x  ->  x <= 7y
    # 4) At least 5 freight trips: x >= 5
    # 5) x, y >= 0 and integer
    
    best_value = None
    
    # Upper bounds for search:
    # From budget: 300x <= 20000 -> x <= 66
    # From capacity alone: 5x >= 200 -> x >= 40, but we will just search a safe range.
    max_x = 100
    max_y = 100
    
    for x in range(5, max_x + 1):  # x >= 5
        for y in range(0, max_y + 1):
            # Capacity constraint
            if 5 * x + 3 * y < 200:
                continue
            # Budget constraint
            if 300 * x + 550 * y > 20000:
                continue
            # Air proportion constraint: x <= 7y
            if x > 7 * y:
                continue
            # Feasible point
            trips = x + y
            if best_value is None or trips < best_value:
                best_value = trips
    
    # Return the minimal total number of trips as float
    return float(best_value if best_value is not None else 0.0)
```",43.0,False,5.0,0.10416666666449653,2.461581230163574,
168,89.0,"```python
def solve():
    # We need integers c (canoes) and d (diesel boats)
    # Constraints:
    # 1) 10c + 15d >= 1000
    # 2) c >= 3d
    # Objective: minimize c + d
    
    best_value = None
    
    # Upper bound for d: if all fish were carried by diesel boats
    # 15d >= 1000 -> d >= 1000/15 â‰ˆ 66.67, so d up to, say, 100
    for d in range(0, 101):
        # c must be at least 3d (environmental rule)
        c_min_rule = 3 * d
        
        # c must also satisfy fish requirement:
        # 10c + 15d >= 1000 -> c >= (1000 - 15d)/10
        required_c = (1000 - 15 * d) / 10.0
        if required_c < 0:
            required_c = 0  # no negative canoes
        
        # c must be integer and satisfy both constraints
        c = int(required_c)
        if 10 * c + 15 * d < 1000:
            c += 1
        if c < c_min_rule:
            c = c_min_rule
        
        # Check feasibility
        if 10 * c + 15 * d >= 1000 and c >= 3 * d:
            total = c + d
            if best_value is None or total < best_value:
                best_value = total
    
    # Return the optimal objective value as float
    return float(best_value)
```",89.0,True,0.0,0.0,2.249694347381592,
169,18.0,"```python
def solve():
    # Let x = number of motion-activated machines
    #     y = number of manual machines
    #
    # Constraints:
    # 1) Drops: 50x + 75y >= 1000
    # 2) Energy: 30x + 20y <= 500
    # 3) At most 40% manual: y <= (2/3) * x
    # 4) At least 3 motion-activated: x >= 3
    # 5) x, y are nonnegative integers
    #
    # Objective: minimize x + y
    
    best_value = None
    
    # We can bound x and y reasonably:
    # From energy: 30x <= 500 -> x <= 16 (integer)
    # From drops with y=0: 50x >= 1000 -> x >= 20, but that violates energy,
    # so we know we need some y. We'll just search a reasonable range.
    
    # Upper bounds (loose but safe for this small problem):
    max_x = 100
    max_y = 100
    
    for x in range(3, max_x + 1):  # x >= 3
        # From y <= (2/3)x, y is at most floor(2x/3)
        y_max_manual_ratio = (2 * x) // 3
        
        # From energy: 30x + 20y <= 500 -> y <= (500 - 30x)/20
        if 30 * x > 500:
            continue
        y_max_energy = (500 - 30 * x) // 20
        
        # Overall upper bound for y
        y_upper = min(y_max_manual_ratio, y_max_energy, max_y)
        if y_upper < 0:
            continue
        
        # From drops: 50x + 75y >= 1000 -> y >= (1000 - 50x)/75
        # y must be integer, so take ceiling
        if 50 * x >= 1000:
            y_lower = 0
        else:
            num = 1000 - 50 * x
            y_lower = (num + 75 - 1) // 75  # integer ceiling
        
        if y_lower < 0:
            y_lower = 0
        
        if y_lower > y_upper:
            continue
        
        # For minimal x + y, choose smallest feasible y in [y_lower, y_upper]
        y = y_lower
        total = x + y
        if best_value is None or total < best_value:
            best_value = total
    
    # Return the optimal objective value as float
    return float(best_value if best_value is not None else 0.0)
```",17.0,False,1.0,0.05555555555246913,3.5105528831481934,
170,80000.0,"```python
def solve():
    # Let x = money in apartments, y = money in townhouses
    # Constraints:
    # 1) x + y = 600000
    # 2) x <= 200000
    # 3) x >= 0.5 * y
    # Objective: maximize 0.10*x + 0.15*y
    
    # From x + y = 600000 => y = 600000 - x
    # Substitute into x >= 0.5*y:
    # x >= 0.5*(600000 - x)
    # x >= 300000 - 0.5x
    # 1.5x >= 300000
    # x >= 200000
    
    # Combine with x <= 200000 => x = 200000
    # Then y = 600000 - 200000 = 400000
    
    x = 200000.0
    y = 400000.0
    optimal_profit = 0.10 * x + 0.15 * y
    return optimal_profit
```",80000.0,True,0.0,0.0,1.5055959224700928,
171,101.81818181818184,"```python
def solve():
    # We solve the LP:
    # Minimize:  5x + 6y
    # Subject to:
    #   5x + 7y >= 80   (vitamin C)
    #   3x + 5y >= 70   (vitamin A)
    #   x >= 2y         (preference)
    #   x, y >= 0
    #
    # We'll find all candidate corner points formed by intersections of
    # constraint boundaries and keep the feasible one with minimum objective.

    import math

    def is_feasible(x, y, tol=1e-9):
        if x < -tol or y < -tol:
            return False
        if 5*x + 7*y < 80 - tol:
            return False
        if 3*x + 5*y < 70 - tol:
            return False
        if x < 2*y - tol:
            return False
        return True

    def obj(x, y):
        return 5*x + 6*y

    candidates = []

    # 1) Intersection of 5x + 7y = 80 and 3x + 5y = 70
    # Solve the system:
    # 5x + 7y = 80
    # 3x + 5y = 70
    # Using elimination:
    # Multiply first eq by 3: 15x + 21y = 240
    # Multiply second eq by 5: 15x + 25y = 350
    # Subtract: (15x+25y)-(15x+21y) = 350-240 => 4y = 110 => y = 27.5
    # Then 3x + 5*27.5 = 70 => 3x + 137.5 = 70 => 3x = -67.5 => x = -22.5
    x1, y1 = -22.5, 27.5
    candidates.append((x1, y1))

    # 2) Intersection of 5x + 7y = 80 and x = 2y
    # Substitute x = 2y:
    # 5*(2y) + 7y = 80 => 10y + 7y = 80 => 17y = 80 => y = 80/17, x = 160/17
    y2 = 80.0 / 17.0
    x2 = 2.0 * y2
    candidates.append((x2, y2))

    # 3) Intersection of 3x + 5y = 70 and x = 2y
    # 3*(2y) + 5y = 70 => 6y + 5y = 70 => 11y = 70 => y = 70/11, x = 140/11
    y3 = 70.0 / 11.0
    x3 = 2.0 * y3
    candidates.append((x3, y3))

    # 4) Intersections with axes and x=2y where applicable

    # With y = 0:
    # 5x >= 80 => x >= 16
    # 3x >= 70 => x >= 70/3
    # x >= 2*0 => x >= 0
    # So minimal x on y=0 is max(16, 70/3)
    x4 = max(16.0, 70.0 / 3.0)
    y4 = 0.0
    candidates.append((x4, y4))

    # With x = 0:
    # 7y >= 80 => y >= 80/7
    # 5y >= 70 => y >= 14
    # x >= 2y => 0 >= 2y => y <= 0
    # No feasible point with x=0, so skip.

    # With x = 2y and y = 0: already covered as (0,0) but it's infeasible anyway.

    best_val = math.inf
    for x, y in candidates:
        if is_feasible(x, y):
            val = obj(x, y)
            if val < best_val:
                best_val = val

    return float(best_val)
```",101.81818181818181,True,2.842170943040401e-14,2.7914178904586914e-16,7.077450513839722,
172,368.0,"```python
def solve():
    # We want to minimize total time:
    #   Minimize: 3x + 5y
    # Subject to:
    #   x + y >= 100
    #   x >= 30
    #   x <= 2y
    #   x, y >= 0
    #
    # This is a 2-variable linear program. We'll solve it analytically by
    # checking all corner points of the feasible region.
    #
    # Constraints rewritten:
    #   y >= 100 - x
    #   y >= x / 2
    #   x >= 30
    #
    # The feasible region is the intersection of:
    #   x >= 30
    #   y >= 100 - x
    #   y >= x/2
    #
    # Candidate corner points come from intersections of boundary lines:
    # 1) x = 30 with y = 100 - x  -> (30, 70)
    # 2) x = 30 with y = x/2      -> (30, 15) but this fails x + y >= 100
    # 3) y = 100 - x with y = x/2 -> 100 - x = x/2 -> x = 200/3, y = 50/3
    #
    # Check feasibility:
    # (30, 70): x + y = 100, x >= 30, x <= 2y -> 30 <= 140, feasible
    # (200/3, 50/3): x + y = 250/3 >= 100, x >= 30, x <= 2y -> 200/3 <= 100/3? No, infeasible
    #
    # So the only feasible corner is (30, 70).
    # Objective value: 3*30 + 5*70 = 90 + 350 = 440

    x_opt = 30.0
    y_opt = 70.0
    optimal_value = 3.0 * x_opt + 5.0 * y_opt
    return float(optimal_value)
```",440.0,False,72.0,0.19565217391251183,3.3760008811950684,
173,6300.0,"```python
def solve():
    # Let x = number of ship trips, y = number of plane trips
    # Objective: minimize fuel = 500x + 300y
    # Constraints:
    # 1) 40x + 20y >= 500   (containers)
    # 2) y <= 10            (at most 10 plane trips)
    # 3) x >= y             (at least 50% of trips are by ship)
    # 4) x, y >= 0
    #
    # We assume x, y can be real (not necessarily integers).
    #
    # We'll search over all relevant corner points of the feasible region.

    best_val = float('inf')

    # Helper to check feasibility and update best value
    def check_point(x, y):
        nonlocal best_val
        if x < 0 or y < 0:
            return
        if 40 * x + 20 * y < 500:
            return
        if y > 10:
            return
        if x < y:
            return
        val = 500 * x + 300 * y
        if val < best_val:
            best_val = val

    # Candidate 1: Intersection of container constraint and x = y
    # 40x + 20x = 500 -> 60x = 500 -> x = 500/60, y = 500/60
    x = 500.0 / 60.0
    y = x
    check_point(x, y)

    # Candidate 2: Intersection of container constraint and y = 10
    # 40x + 20*10 = 500 -> 40x + 200 = 500 -> 40x = 300 -> x = 7.5
    x = 7.5
    y = 10.0
    check_point(x, y)

    # Candidate 3: Intersection of container constraint and y = 0
    # 40x = 500 -> x = 12.5
    x = 12.5
    y = 0.0
    check_point(x, y)

    # Candidate 4: Intersection of x = y and y = 10 -> x = 10, y = 10
    x = 10.0
    y = 10.0
    check_point(x, y)

    # Candidate 5: Intersection of x = y and y = 0 -> x = 0, y = 0
    x = 0.0
    y = 0.0
    check_point(x, y)

    # Candidate 6: Intersection of y = 10 and x = 0
    x = 0.0
    y = 10.0
    check_point(x, y)

    # Also check along boundaries by simple sampling (optional but safe)
    # Sample y in [0,10], set x = max(y, (500 - 20y)/40) if needed
    for i in range(101):
        y = 10.0 * i / 100.0
        # Minimum x from container constraint
        x_req = max(0.0, (500.0 - 20.0 * y) / 40.0)
        # Also must satisfy x >= y
        x = max(x_req, y)
        check_point(x, y)

    return best_val
```",6250.0,False,50.0,0.007936507936506677,5.738713502883911,
174,260.0,"```python
def solve():
    # Let x = number of large ship trips
    #     y = number of small ship trips
    #
    # Objective: minimize pollution P = 20x + 15y
    #
    # Constraints:
    # 1) Capacity: 2000x + 800y >= 20000
    # 2) At most 7 large trips: x <= 7
    # 3) At least 40% of trips are small:
    #       y >= 0.4(x + y)  ->  0.6y >= 0.4x  ->  3y >= 2x  ->  y >= (2/3)x
    # 4) x, y >= 0
    #
    # We assume x, y are real (not necessarily integers), as is standard in LP.
    #
    # We'll solve this small LP by enumerating the intersection points of the
    # constraint boundaries and checking feasibility and objective value.

    import math

    best_val = float('inf')

    def check_and_update(x, y):
        nonlocal best_val
        # Feasibility checks with a small tolerance
        eps = 1e-9
        if x < -eps or y < -eps:
            return
        if 2000 * x + 800 * y + eps < 20000:
            return
        if x - 7 > eps:
            return
        if y + eps < (2.0 / 3.0) * x:
            return
        val = 20 * x + 15 * y
        if val < best_val:
            best_val = val

    # Candidate points come from intersections of:
    # A: 2000x + 800y = 20000
    # B: x = 7
    # C: y = (2/3)x
    # D: x = 0
    # E: y = 0

    # 1) A âˆ© B: 2000*7 + 800y = 20000
    x = 7.0
    y = (20000 - 2000 * x) / 800.0
    check_and_update(x, y)

    # 2) A âˆ© C: 2000x + 800*(2/3 x) = 20000
    #    2000x + (1600/3)x = 20000
    #    (7600/3)x = 20000
    x = 20000 * 3.0 / 7600.0
    y = (2.0 / 3.0) * x
    check_and_update(x, y)

    # 3) A âˆ© D: x = 0 -> 800y = 20000
    x = 0.0
    y = 20000.0 / 800.0
    check_and_update(x, y)

    # 4) A âˆ© E: y = 0 -> 2000x = 20000
    x = 20000.0 / 2000.0
    y = 0.0
    check_and_update(x, y)

    # 5) B âˆ© C: x = 7, y = (2/3)*7
    x = 7.0
    y = (2.0 / 3.0) * x
    check_and_update(x, y)

    # 6) B âˆ© E: x = 7, y = 0
    x = 7.0
    y = 0.0
    check_and_update(x, y)

    # 7) C âˆ© D: x = 0 -> y = 0
    x = 0.0
    y = 0.0
    check_and_update(x, y)

    # 8) D âˆ© E: (0,0) already checked

    # Return the optimal objective value
    return best_val
```",252.5,False,7.5,0.028846153846042902,4.915554046630859,
175,960.0,"```python
def solve():
    # Let m = number of medium carts, l = number of large carts
    # Constraints:
    # 1) 2m + 4l <= 60  (horses)
    # 2) m = 3l         (given relation)
    # 3) m >= 5, l >= 5
    #
    # Objective: maximize 30m + 70l
    
    # From m = 3l, substitute into horse constraint:
    # 2(3l) + 4l <= 60 -> 6l + 4l <= 60 -> 10l <= 60 -> l <= 6
    # Also l >= 5, so l is in [5, 6]
    #
    # We check both feasible integer values of l and pick the best.
    
    best_value = float('-inf')
    
    for l in range(5, 7):  # l = 5 or 6
        m = 3 * l
        # Check horse constraint
        if 2 * m + 4 * l <= 60 and m >= 5 and l >= 5:
            value = 30 * m + 70 * l
            if value > best_value:
                best_value = value
    
    return float(best_value)
```",960.0,True,0.0,0.0,2.6636464595794678,
176,6794.0,"```python
def solve():
    # We solve the LP:
    # Minimize T = 10w + 8p
    # s.t.
    #   5w + 7p >= 3000   (meat)
    #   3w + 5p >= 2500   (rice)
    #   w >= 3p           (at least 3 times as many wraps as platters)
    #   w, p >= 0
    
    # In 2D, the optimum of a linear program lies at a vertex of the feasible region.
    # Vertices come from intersections of constraint boundaries.
    # We'll enumerate candidate intersection points and pick the feasible one
    # with minimum objective value.
    
    candidates = []
    
    # Helper to check feasibility
    def feasible(w, p):
        if w < 0 or p < 0:
            return False
        if 5*w + 7*p < 3000 - 1e-9:
            return False
        if 3*w + 5*p < 2500 - 1e-9:
            return False
        if w < 3*p - 1e-9:
            return False
        return True
    
    # 1) Intersection of meat and rice constraints:
    #   5w + 7p = 3000
    #   3w + 5p = 2500
    # Solve:
    # From second: 3w = 2500 - 5p => w = (2500 - 5p)/3
    # Plug into first:
    # 5*(2500 - 5p)/3 + 7p = 3000
    # (12500 - 25p)/3 + 7p = 3000
    # 12500 - 25p + 21p = 9000
    # 12500 - 4p = 9000
    # 4p = 3500 => p = 875
    # w = (2500 - 5*875)/3 = (2500 - 4375)/3 = -1875/3 = -625 (infeasible)
    w = -625.0
    p = 875.0
    if feasible(w, p):
        candidates.append((w, p))
    
    # 2) Intersection of meat and w = 3p:
    #   5w + 7p = 3000
    #   w = 3p
    # => 5*(3p) + 7p = 3000 => 15p + 7p = 22p = 3000 => p = 3000/22
    p = 3000.0 / 22.0
    w = 3.0 * p
    if feasible(w, p):
        candidates.append((w, p))
    
    # 3) Intersection of rice and w = 3p:
    #   3w + 5p = 2500
    #   w = 3p
    # => 3*(3p) + 5p = 9p + 5p = 14p = 2500 => p = 2500/14
    p = 2500.0 / 14.0
    w = 3.0 * p
    if feasible(w, p):
        candidates.append((w, p))
    
    # 4) Intersections with axes and w=3p, but they won't satisfy >= constraints
    #    for such large RHS; still, we can check a few systematically.
    
    # Intersection of meat with p = 0:
    # 5w = 3000 => w = 600
    w = 600.0
    p = 0.0
    if feasible(w, p):
        candidates.append((w, p))
    
    # Intersection of rice with p = 0:
    # 3w = 2500 => w = 2500/3
    w = 2500.0 / 3.0
    p = 0.0
    if feasible(w, p):
        candidates.append((w, p))
    
    # Intersection of meat with w = 0:
    # 7p = 3000 => p = 3000/7
    w = 0.0
    p = 3000.0 / 7.0
    if feasible(w, p):
        candidates.append((w, p))
    
    # Intersection of rice with w = 0:
    # 5p = 2500 => p = 500
    w = 0.0
    p = 500.0
    if feasible(w, p):
        candidates.append((w, p))
    
    # Also consider intersection of w=3p with axes:
    # w = 3p and p=0 => w=0
    w = 0.0
    p = 0.0
    if feasible(w, p):
        candidates.append((w, p))
    
    # Now evaluate objective at all feasible candidates
    best_val = float('inf')
    for w, p in candidates:
        val = 10.0 * w + 8.0 * p
        if val < best_val:
            best_val = val
    
    # If for some reason we didn't find any candidate (shouldn't happen),
    # we can do a simple search along w=3p line where both >= constraints hold.
    if best_val == float('inf'):
        # Parameterize w = 3p, p >= 0.
        # Meat: 5*(3p) + 7p = 22p >= 3000 => p >= 3000/22
        # Rice: 3*(3p) + 5p = 14p >= 2500 => p >= 2500/14
        p_min = max(3000.0 / 22.0, 2500.0 / 14.0)
        w = 3.0 * p_min
        best_val = 10.0 * w + 8.0 * p_min
    
    return float(best_val)
```",6785.714285714286,False,8.285714285713766,0.0012195634803815933,5.5322442054748535,
177,67.0,"```python
def solve():
    # Let s = number of small wagons, l = number of large wagons
    # Constraints:
    # 1) 20s + 50l = 2000
    # 2) s >= 2l
    # 3) l >= 10
    # Objective: minimize s + l
    
    best_value = None
    
    # Since 50l <= 2000, l <= 40. Also l >= 10.
    for l in range(10, 41):
        # From 20s + 50l = 2000 => s = (2000 - 50l) / 20
        numerator = 2000 - 50 * l
        if numerator % 20 != 0:
            continue  # s must be integer
        s = numerator // 20
        
        if s < 0:
            continue
        
        # Check s >= 2l
        if s < 2 * l:
            continue
        
        total_wagons = s + l
        if best_value is None or total_wagons < best_value:
            best_value = total_wagons
    
    # Return the optimal objective value as float
    return float(best_value)
```",67.0,True,0.0,0.0,1.632143259048462,
178,226.0,"```python
def solve():
    # We maximize 10x + 7y
    # Subject to:
    # 30x + 50y <= 1200  (vitamin C)
    # 40x + 30y <= 1500  (vitamin D)
    # y > x              (pills more popular than shots)
    # x <= 10            (at most 10 batches of shots)
    # x, y >= 0
    
    best_value = float('-inf')
    
    # Since x <= 10 and resources are limited, we can bound y as well.
    # From vitamin C: 50y <= 1200 -> y <= 24
    # From vitamin D: 30y <= 1500 -> y <= 50
    # So y <= 24 is a safe upper bound.
    
    for x in range(0, 11):  # x from 0 to 10 inclusive
        for y in range(0, 25):  # y from 0 to 24 inclusive
            if y <= x:  # must have y > x
                continue
            if 30 * x + 50 * y > 1200:
                continue
            if 40 * x + 30 * y > 1500:
                continue
            
            value = 10 * x + 7 * y
            if value > best_value:
                best_value = value
    
    return float(best_value)
```",226.0,True,0.0,0.0,2.26253342628479,
179,582.0,"```python
def solve():
    # We maximize vitamin D: 10x + 12y
    # Subject to:
    # 1) Vitamin C: 8x + 6y <= 300
    # 2) Preference: y >= 3x
    # 3) At least 3 orange: x >= 3
    # 4) x, y >= 0
    
    # This is a 2-variable LP; we can solve analytically by checking corner points.
    # Constraints:
    #   C1: 8x + 6y <= 300
    #   C2: y >= 3x
    #   C3: x >= 3
    
    # The feasible region is bounded by:
    #   x >= 3
    #   y >= 3x
    #   8x + 6y <= 300
    
    # Corner points come from intersections of:
    #   (i) x = 3 with C1 and C2
    #   (ii) y = 3x with C1
    #   (iii) Any intersection with axes, but x>=3 and y>=3x already handle that.
    
    # 1) Intersection of x = 3 and y = 3x:
    x1 = 3.0
    y1 = 3.0 * x1  # y = 9
    # Check C1: 8*3 + 6*9 = 24 + 54 = 78 <= 300, so feasible.
    
    # 2) Intersection of x = 3 and C1: 8*3 + 6y = 300 -> 24 + 6y = 300 -> y = 46
    x2 = 3.0
    y2 = (300.0 - 8.0 * x2) / 6.0  # 46
    # Check C2: y >= 3x -> 46 >= 9, so feasible.
    
    # 3) Intersection of y = 3x and C1:
    #    8x + 6(3x) = 300 -> 8x + 18x = 300 -> 26x = 300 -> x = 300/26
    x3 = 300.0 / 26.0
    y3 = 3.0 * x3
    # Check C3: x >= 3
    # 300/26 â‰ˆ 11.538 > 3, so feasible.
    
    # Evaluate objective 10x + 12y at these points
    def obj(x, y):
        return 10.0 * x + 12.0 * y
    
    candidates = [
        obj(x1, y1),
        obj(x2, y2),
        obj(x3, y3)
    ]
    
    return max(candidates)
```",582.0,True,0.0,0.0,3.0734193325042725,
180,375.0,"```python
def solve():
    # We solve the LP:
    # Maximize 7.5 x + 5 y
    # subject to:
    # 600 x + 525 y <= 30000   (milk)
    # 10 x + 5 y <= 500        (honey)
    # x >= 0, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) Axes:
    #    x = 0: from honey 5y <= 500 -> y <= 100
    #           from milk 525y <= 30000 -> y <= 30000/525
    y_axis = min(500 / 5.0, 30000 / 525.0)
    x0_y = y_axis
    profit_x0_y = 7.5 * 0 + 5 * x0_y

    #    y = 0: from honey 10x <= 500 -> x <= 50
    #           from milk 600x <= 30000 -> x <= 50
    x_axis = min(500 / 10.0, 30000 / 600.0)
    x_y0 = x_axis
    profit_x_y0 = 7.5 * x_y0 + 5 * 0

    # 2) Intersection of the two constraints:
    #    600x + 525y = 30000
    #    10x + 5y = 500
    # From second: 10x + 5y = 500 -> 2x + y = 100 -> y = 100 - 2x
    # Substitute into first:
    # 600x + 525(100 - 2x) = 30000
    # 600x + 52500 - 1050x = 30000
    # -450x = -22500 -> x = 50, then y = 0
    # So the intersection is (50, 0), already found as axis corner.

    # 3) Origin (0,0)
    profit_0_0 = 0.0

    # Best profit among feasible corners
    best_profit = max(profit_x0_y, profit_x_y0, profit_0_0)
    return float(best_profit)
```",375.0,True,0.0,0.0,3.586193084716797,
181,480.0,"```python
def solve():
    # We solve the LP:
    # Maximize 8x + 10y
    # subject to:
    # 3x + 5y <= 300  (heating)
    # 5x + 8y <= 300  (cooling)
    # x, y >= 0
    
    # Corner points come from intersections of constraints and axes.
    # 1) Intersections with axes:
    #    a) x = 0:
    #       3*0 + 5y <= 300 -> y <= 60
    #       5*0 + 8y <= 300 -> y <= 37.5
    #       So feasible y = 37.5, point (0, 37.5)
    #
    #    b) y = 0:
    #       3x <= 300 -> x <= 100
    #       5x <= 300 -> x <= 60
    #       So feasible x = 60, point (60, 0)
    #
    # 2) Intersection of 3x + 5y = 300 and 5x + 8y = 300:
    #    Solve:
    #      3x + 5y = 300
    #      5x + 8y = 300
    #    Multiply first by 5: 15x + 25y = 1500
    #    Multiply second by 3: 15x + 24y = 900
    #    Subtract: (15x+25y) - (15x+24y) = 1500 - 900 -> y = 600
    #    Plug back: 3x + 5*600 = 300 -> 3x + 3000 = 300 -> 3x = -2700 -> x = -900
    #    This point (-900, 600) is infeasible (x < 0), so it is not in the feasible region.
    #
    # Feasible corner points: (0, 0), (60, 0), (0, 37.5)
    #
    # Evaluate objective:
    # (0, 0): 8*0 + 10*0 = 0
    # (60, 0): 8*60 + 10*0 = 480
    # (0, 37.5): 8*0 + 10*37.5 = 375
    #
    # Maximum profit is 480 at (60, 0).
    
    return float(480.0)
```",480.0,True,0.0,0.0,3.788700580596924,
182,65000.0,"```python
def solve():
    # We interpret the problem as a linear program:
    # Let x1, x2, x3 be the amounts bet on basketball, horse, and soccer, respectively.
    # Total money: x1 + x2 + x3 = 100000
    # Loss probabilities: 0.5, 0.25, 0.10
    # Average chance of losing (weighted by money) <= 0.30:
    #   (0.5*x1 + 0.25*x2 + 0.10*x3) / 100000 <= 0.30
    #   => 0.5*x1 + 0.25*x2 + 0.10*x3 <= 30000
    #
    # Payout per dollar: 1.2, 0.5, 0.1
    # Objective: maximize total payout = 1.2*x1 + 0.5*x2 + 0.1*x3
    #
    # Nonnegativity: x1, x2, x3 >= 0
    #
    # This is a 3-variable LP with 2 equality/inequality constraints (plus nonnegativity).
    # We can solve it by enumerating basic feasible solutions (corner points).
    #
    # Constraints in standard form:
    # (1) x1 + x2 + x3 = 100000
    # (2) 0.5*x1 + 0.25*x2 + 0.10*x3 <= 30000
    #
    # We'll consider all combinations where up to 2 variables are basic and the rest are zero,
    # and also where the inequality is active (turned into equality) or inactive.
    #
    # Because there are only 3 variables, we can systematically enumerate candidate corner points.

    import math

    best_value = -math.inf

    # Helper to check feasibility and update best objective
    def consider(x1, x2, x3):
        nonlocal best_value
        # Nonnegativity
        if x1 < -1e-9 or x2 < -1e-9 or x3 < -1e-9:
            return
        # Enforce small negative numerical noise to zero
        x1c = max(0.0, x1)
        x2c = max(0.0, x2)
        x3c = max(0.0, x3)
        # Total money constraint
        if abs(x1c + x2c + x3c - 100000) > 1e-6:
            return
        # Loss constraint
        if 0.5 * x1c + 0.25 * x2c + 0.10 * x3c - 30000 > 1e-6:
            return
        # Objective
        val = 1.2 * x1c + 0.5 * x2c + 0.1 * x3c
        if val > best_value:
            best_value = val

    # 1) Vertices with inequality possibly inactive:
    # Set two variables to zero, solve for the third from x1 + x2 + x3 = 100000

    # Case A: x2 = x3 = 0
    x1 = 100000.0
    x2 = 0.0
    x3 = 0.0
    consider(x1, x2, x3)

    # Case B: x1 = x3 = 0
    x1 = 0.0
    x2 = 100000.0
    x3 = 0.0
    consider(x1, x2, x3)

    # Case C: x1 = x2 = 0
    x1 = 0.0
    x2 = 0.0
    x3 = 100000.0
    consider(x1, x2, x3)

    # 2) Vertices where inequality is active (turned into equality):
    # System:
    #   x1 + x2 + x3 = 100000
    #   0.5*x1 + 0.25*x2 + 0.10*x3 = 30000
    #
    # With one variable set to zero, solve 2x2 system.

    # Case D: x1 = 0
    #   x2 + x3 = 100000
    #   0.25*x2 + 0.10*x3 = 30000
    # Solve:
    #   x3 = 100000 - x2
    #   0.25*x2 + 0.10*(100000 - x2) = 30000
    #   0.25*x2 + 10000 - 0.10*x2 = 30000
    #   0.15*x2 = 20000 => x2 = 133333.333..., x3 = -33333.333... (infeasible)
    x1 = 0.0
    x2 = 20000.0 / 0.15  # 133333.333...
    x3 = 100000.0 - x2
    consider(x1, x2, x3)

    # Case E: x2 = 0
    #   x1 + x3 = 100000
    #   0.5*x1 + 0.10*x3 = 30000
    #   x3 = 100000 - x1
    #   0.5*x1 + 0.10*(100000 - x1) = 30000
    #   0.5*x1 + 10000 - 0.10*x1 = 30000
    #   0.40*x1 = 20000 => x1 = 50000, x3 = 50000
    x2 = 0.0
    x1 = 20000.0 / 0.40  # 50000
    x3 = 100000.0 - x1
    consider(x1, x2, x3)

    # Case F: x3 = 0
    #   x1 + x2 = 100000
    #   0.5*x1 + 0.25*x2 = 30000
    #   x2 = 100000 - x1
    #   0.5*x1 + 0.25*(100000 - x1) = 30000
    #   0.5*x1 + 25000 - 0.25*x1 = 30000
    #   0.25*x1 = 5000 => x1 = 20000, x2 = 80000
    x3 = 0.0
    x1 = 5000.0 / 0.25  # 20000
    x2 = 100000.0 - x1
    consider(x1, x2, x3)

    # Return the best objective value found
    return float(best_value)
```",65000.0,True,0.0,0.0,7.107059955596924,
183,20.0,"```python
def solve():
    # We want to minimize total buses: x + y
    # Subject to:
    # 1) Capacity: 20x + 50y >= 500
    # 2) Large bus limit: y <= 0.2(x + y)  ->  4y <= x
    # 3) x, y are nonnegative integers
    
    best_value = None
    
    # We can bound search: even if all buses were large (capacity 50),
    # we'd need at most 500/50 = 10 buses. But large buses are limited
    # to 20% of total, so total buses will be larger. A safe upper bound
    # is, say, 100 buses.
    max_buses = 100
    
    for x in range(max_buses + 1):
        for y in range(max_buses + 1):
            # Capacity constraint
            if 20 * x + 50 * y < 500:
                continue
            # Large bus proportion constraint: 4y <= x
            if 4 * y > x:
                continue
            total_buses = x + y
            if best_value is None or total_buses < best_value:
                best_value = total_buses
    
    # Return the minimal total number of buses as a float
    return float(best_value)
```",20.0,True,0.0,0.0,2.3955986499786377,
184,118.0,"```python
def solve():
    # We solve the LP:
    # Minimize:  F = 7x + 10y
    # Subject to:
    #   10x + 15y >= 130   (protein)
    #   12x +  8y >= 120   (iron)
    #   y >= 2x            (at least twice as many chicken meals)
    #   x >= 0, y >= 0
    
    # The optimum of a linear program with linear constraints occurs at a vertex
    # (intersection of constraint boundaries). We enumerate all candidate
    # intersections of pairs of constraints, then keep those that satisfy all
    # constraints, and pick the one with minimal objective value.
    
    # We'll represent constraints in the form a1*x + b1*y >= c1 (for the first two),
    # and y - 2x >= 0 for the third, plus x >= 0, y >= 0.
    
    # Helper to solve a 2x2 linear system:
    # a1*x + b1*y = c1
    # a2*x + b2*y = c2
    def solve_2x2(a1, b1, c1, a2, b2, c2):
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-12:
            return None  # parallel or nearly parallel
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)
    
    # List of constraints in "">= form"" plus nonnegativity:
    # We'll check feasibility directly rather than encoding them symbolically.
    def feasible(x, y):
        eps = 1e-9
        if x < -eps or y < -eps:
            return False
        if 10 * x + 15 * y < 130 - eps:
            return False
        if 12 * x + 8 * y < 120 - eps:
            return False
        if y < 2 * x - eps:
            return False
        return True
    
    candidates = []
    
    # 1) Intersection of protein and iron:
    p = solve_2x2(10, 15, 130, 12, 8, 120)
    if p is not None:
        candidates.append(p)
    
    # 2) Protein and y = 2x:
    # 10x + 15y = 130, y = 2x -> 10x + 15*(2x) = 130 -> 40x = 130
    x = 130.0 / 40.0
    y = 2.0 * x
    candidates.append((x, y))
    
    # 3) Iron and y = 2x:
    # 12x + 8y = 120, y = 2x -> 12x + 8*(2x) = 120 -> 28x = 120
    x = 120.0 / 28.0
    y = 2.0 * x
    candidates.append((x, y))
    
    # 4) Protein with x = 0:
    # 10*0 + 15y = 130 -> y = 130/15
    x = 0.0
    y = 130.0 / 15.0
    candidates.append((x, y))
    
    # 5) Iron with x = 0:
    # 12*0 + 8y = 120 -> y = 120/8 = 15
    x = 0.0
    y = 15.0
    candidates.append((x, y))
    
    # 6) Protein with y = 0:
    # 10x = 130 -> x = 13
    x = 13.0
    y = 0.0
    candidates.append((x, y))
    
    # 7) Iron with y = 0:
    # 12x = 120 -> x = 10
    x = 10.0
    y = 0.0
    candidates.append((x, y))
    
    # 8) y = 2x with x = 0 -> (0,0)
    candidates.append((0.0, 0.0))
    
    best_val = None
    for (x, y) in candidates:
        if feasible(x, y):
            val = 7.0 * x + 10.0 * y
            if (best_val is None) or (val < best_val):
                best_val = val
    
    # best_val is the minimal fat intake
    return float(best_val)
```",115.71428571428571,False,2.285714285714292,0.019370460048262046,5.2486419677734375,
185,16.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 2x + 3y
    # Subject to:
    #   5x + 4y >= 40  (iron)
    #   10x + 15y >= 50 (calcium)
    #   x, y >= 0
    #
    # Since it's a 2-variable LP, we can solve analytically by checking corner points.
    
    # Corner 1: Intersection of the two constraint lines
    # 5x + 4y = 40
    # 10x + 15y = 50
    # Solve:
    # From first: x = (40 - 4y)/5
    # Substitute into second:
    # 10*(40 - 4y)/5 + 15y = 50
    # 2*(40 - 4y) + 15y = 50
    # 80 - 8y + 15y = 50
    # 80 + 7y = 50
    # 7y = -30 -> y = -30/7 (infeasible since y >= 0)
    # So the intersection is not in the feasible region.
    
    # Corner 2: Satisfy iron constraint at equality with y = 0
    # 5x >= 40 -> x = 40/5 = 8
    x1, y1 = 8.0, 0.0
    # Check calcium: 10*8 = 80 >= 50 (feasible)
    cost1 = 2 * x1 + 3 * y1
    
    # Corner 3: Satisfy calcium constraint at equality with x = 0
    # 15y >= 50 -> y = 50/15
    x2, y2 = 0.0, 50.0 / 15.0
    # Check iron: 4*(50/15) = 200/15 >= 40? 200/15 â‰ˆ 13.33 < 40 (infeasible)
    # So this point is not feasible.
    
    # Since the feasible region is unbounded but the objective has positive
    # coefficients, the minimum will occur at a boundary point.
    # The only feasible corner among these is (8, 0).
    # Also, any increase in y or x from this point increases cost.
    
    return float(cost1)
```",16.0,True,0.0,0.0,3.5868520736694336,
186,-99999.0,"```python
def solve():
    # We minimize gelatine: 20x + 60y
    # Subject to:
    # 1) Antibiotics: 30x + 65y <= 35000
    # 2) Demand: x > y  (more first-dose than second-dose)
    # 3) At least 40 second-dose: y >= 40
    # 4) x, y >= 0
    #
    # Since gelatine per unit:
    #   first-dose: 20
    #   second-dose: 60
    # first-dose uses less gelatine, so for a fixed antibiotics usage,
    # we prefer more x and fewer y.
    #
    # The minimum y allowed is 40, and we want y as small as possible.
    # So set y = 40 and use remaining antibiotics for x.
    #
    # Antibiotics constraint:
    #   30x + 65*40 <= 35000
    #   30x + 2600 <= 35000
    #   30x <= 32400
    #   x <= 1080
    #
    # Also need x > y = 40, which is satisfied by x = 1080.
    #
    # Objective value at (x, y) = (1080, 40):
    #   20*1080 + 60*40 = 21600 + 2400 = 24000
    
    return float(24000.0)
```",24000.0,False,123999.0,1.2400024000239878,2.561386823654175,
187,11.0,"```python
def solve():
    # We want to minimize x + y
    # subject to:
    # 120x + 30y >= 600
    # y >= 2x
    # x, y >= 0
    #
    # Since the problem is small and discrete (numbers of units),
    # we can brute-force over a reasonable range of integers.
    #
    # Upper bound: if we used only trams, 30y >= 600 -> y >= 20.
    # If we used only trains, 120x >= 600 -> x >= 5.
    # So searching x in [0, 20], y in [0, 40] is more than enough.

    best = None

    for x in range(0, 21):      # trains
        for y in range(0, 41):  # trams
            if 120 * x + 30 * y >= 600 and y >= 2 * x:
                total_units = x + y
                if best is None or total_units < best:
                    best = total_units

    # best holds the minimal total number of units
    return float(best)
```",11.0,True,0.0,0.0,2.148300886154175,
188,46000.0,"```python
def solve():
    # We solve the LP by enumerating all basic feasible solutions (BFS)
    # Variables: x1 (Pi TV), x2 (Beta Video), x3 (Gamma Live)
    # Maximize: 2000*x1 + 5000*x2 + 9000*x3
    #
    # Constraints:
    # 1) Budget: 1200*x1 + 2000*x2 + 4000*x3 <= 20000
    # 2) Beta limit: x2 <= 8
    # 3) Gamma fraction: x3 <= (1/3)*(x1 + x2 + x3)  ->  2*x3 <= x1 + x2
    # 4) Pi fraction: x1 >= 0.2*(x1 + x2 + x3)      ->  4*x1 >= x2 + x3
    # 5) x1, x2, x3 >= 0
    #
    # We convert inequalities to equalities by considering them active (tight)
    # or inactive (slack) and solve all combinations of 3 active constraints
    # (since we have 3 variables). Then we check feasibility and compute the
    # objective value.

    import itertools

    # Each constraint is represented as (A, b, type)
    # where A is [a1, a2, a3] for a1*x1 + a2*x2 + a3*x3 (<= or >=) b.
    # We'll convert >= to <= by multiplying by -1.
    # Types: 'le' for <=, 'ge' for >=, 'eq' for equality (not used directly here).
    constraints = []

    # 1) Budget: 1200*x1 + 2000*x2 + 4000*x3 <= 20000
    constraints.append(([1200.0, 2000.0, 4000.0], 20000.0, 'le'))

    # 2) Beta limit: x2 <= 8
    constraints.append(([0.0, 1.0, 0.0], 8.0, 'le'))

    # 3) Gamma fraction: 2*x3 <= x1 + x2  ->  -x1 - x2 + 2*x3 <= 0
    constraints.append(([-1.0, -1.0, 2.0], 0.0, 'le'))

    # 4) Pi fraction: 4*x1 >= x2 + x3  ->  -4*x1 + x2 + x3 <= 0
    constraints.append(([-4.0, 1.0, 1.0], 0.0, 'le'))

    # 5) Nonnegativity: x1 >= 0, x2 >= 0, x3 >= 0  ->  -xi <= 0
    constraints.append(([-1.0, 0.0, 0.0], 0.0, 'le'))  # x1 >= 0
    constraints.append(([0.0, -1.0, 0.0], 0.0, 'le'))  # x2 >= 0
    constraints.append(([0.0, 0.0, -1.0], 0.0, 'le'))  # x3 >= 0

    # Objective coefficients
    c = [2000.0, 5000.0, 9000.0]

    def solve_3x3(A, b):
        # Solve A x = b for 3x3 using Cramer's rule or Gaussian elimination.
        # A is 3x3 list of lists, b is length-3 list.
        # Return (solution_list, success_bool).
        # We'll use a simple Gaussian elimination with partial pivoting.
        M = [row[:] + [b_i] for row, b_i in zip(A, b)]  # augmented matrix 3x4

        # Forward elimination
        for col in range(3):
            # Find pivot
            pivot_row = max(range(col, 3), key=lambda r: abs(M[r][col]))
            if abs(M[pivot_row][col]) < 1e-9:
                return None, False
            # Swap
            if pivot_row != col:
                M[col], M[pivot_row] = M[pivot_row], M[col]
            # Eliminate
            for r in range(col + 1, 3):
                factor = M[r][col] / M[col][col]
                for k in range(col, 4):
                    M[r][k] -= factor * M[col][k]

        # Back substitution
        x = [0.0, 0.0, 0.0]
        for i in reversed(range(3)):
            if abs(M[i][i]) < 1e-9:
                return None, False
            s = M[i][3]
            for j in range(i + 1, 3):
                s -= M[i][j] * x[j]
            x[i] = s / M[i][i]
        return x, True

    def is_feasible(x):
        # Check all constraints (<= form) and nonnegativity with tolerance
        tol = 1e-7
        x1, x2, x3 = x
        if x1 < -tol or x2 < -tol or x3 < -tol:
            return False
        for A, b, _ in constraints:
            lhs = A[0] * x1 + A[1] * x2 + A[2] * x3
            if lhs - b > 1e-6:  # violates <=
                return False
        return True

    best_val = float(""-inf"")

    # Enumerate all combinations of 3 constraints to be active (as equalities)
    n_con = len(constraints)
    for idxs in itertools.combinations(range(n_con), 3):
        A_eq = []
        b_eq = []
        for i in idxs:
            A, b, _ = constraints[i]
            A_eq.append(A)
            b_eq.append(b)
        x, ok = solve_3x3(A_eq, b_eq)
        if not ok:
            continue
        if not is_feasible(x):
            continue
        val = c[0] * x[0] + c[1] * x[1] + c[2] * x[2]
        if val > best_val:
            best_val = val

    # Also check some vertices that may come from intersection of 2 constraints
    # with one variable set to zero (to be safe).
    # For each pair of constraints and each variable fixed to 0, solve 2x2.
    def solve_2x2(A2, b2):
        # A2: 2x2, b2: length-2
        a, b = A2[0]
        c_, d = A2[1]
        det = a * d - b * c_
        if abs(det) < 1e-9:
            return None, False
        x = (b2[0] * d - b * b2[1]) / det
        y = (a * b2[1] - b2[0] * c_) / det
        return [x, y], True

    for i, j in itertools.combinations(range(n_con), 2):
        for fixed_var in range(3):  # 0->x1=0, 1->x2=0, 2->x3=0
            A2 = []
            b2 = []
            for k in (i, j):
                A, b = constraints[k]
                # Remove fixed_var column
                row = [A[m] for m in range(3) if m != fixed_var]
                A2.append(row)
                b2.append(b)
            sol2, ok = solve_2x2(A2, b2)
            if not ok:
                continue
            # Reconstruct full x
            x = [0.0, 0.0, 0.0]
            idx = 0
            for m in range(3):
                if m == fixed_var:
                    x[m] = 0.0
                else:
                    x[m] = sol2[idx]
                    idx += 1
            if not is_feasible(x):
                continue
            val = c[0] * x[0] + c[1] * x[1] + c[2] * x[2]
            if val > best_val:
                best_val = val

    return float(best_val)
```",,False,,,9.732242345809937,
189,7000.0,"```python
def solve():
    # We model the problem as a linear program:
    # Let x = sq. ft. for phones, y = sq. ft. for laptops.
    # Maximize: 50x + 70y
    # Subject to:
    #   1) Space: x + y <= 100
    #   2) Cost: 12x + 15y <= 5000
    #   3) Labor: 2x + 3y <= 2000
    #   4) x >= 0, y >= 0
    #
    # We solve by enumerating all corner points formed by intersections
    # of the constraint lines and checking feasibility and objective value.

    import math

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if x + y > 100 + 1e-9:
            return False
        if 12 * x + 15 * y > 5000 + 1e-9:
            return False
        if 2 * x + 3 * y > 2000 + 1e-9:
            return False
        return True

    # Objective function
    def objective(x, y):
        return 50 * x + 70 * y

    candidates = []

    # Intersections with axes
    # x = 0
    #   space: y <= 100
    #   cost: 15y <= 5000 -> y <= 5000/15
    #   labor: 3y <= 2000 -> y <= 2000/3
    # So potential points: (0,0), (0,100), (0,5000/15), (0,2000/3)
    axis_points = [
        (0.0, 0.0),
        (0.0, 100.0),
        (0.0, 5000.0 / 15.0),
        (0.0, 2000.0 / 3.0),
        # y = 0
        (0.0, 0.0),
        (100.0, 0.0),
        (5000.0 / 12.0, 0.0),
        (2000.0 / 2.0, 0.0),
    ]
    candidates.extend(axis_points)

    # Intersections of pairs of constraint lines:
    # 1) x + y = 100
    # 2) 12x + 15y = 5000
    # 3) 2x + 3y = 2000

    # Intersection of (1) and (2):
    # x + y = 100
    # 12x + 15y = 5000
    # Solve:
    # From first: x = 100 - y
    # 12(100 - y) + 15y = 5000
    # 1200 - 12y + 15y = 5000
    # 3y = 3800 -> y = 3800/3, x = 100 - 3800/3
    y = 3800.0 / 3.0
    x = 100.0 - y
    candidates.append((x, y))

    # Intersection of (1) and (3):
    # x + y = 100
    # 2x + 3y = 2000
    # From first: x = 100 - y
    # 2(100 - y) + 3y = 2000
    # 200 - 2y + 3y = 2000
    # y = 1800, x = 100 - 1800
    y = 1800.0
    x = 100.0 - y
    candidates.append((x, y))

    # Intersection of (2) and (3):
    # 12x + 15y = 5000
    # 2x + 3y = 2000
    # Multiply second by 6: 12x + 18y = 12000
    # Subtract first: 3y = 7000 -> y = 7000/3
    # Then 2x + 3*(7000/3) = 2000 -> 2x + 7000 = 2000 -> x = -2500
    y = 7000.0 / 3.0
    x = -2500.0
    candidates.append((x, y))

    best_val = -math.inf
    for x, y in candidates:
        if feasible(x, y):
            val = objective(x, y)
            if val > best_val:
                best_val = val

    # Return the optimal objective value as float
    return float(best_val)
```",7000.0,True,0.0,0.0,5.327083587646484,
190,677.5,"```python
def solve():
    # Let T = number of throwing games, C = number of climbing games
    # Objective: maximize 15T + 8C
    # Constraints:
    # 1) Prize cost: 2T + 3C <= 100
    # 2) At least twice as many throwing as climbing: T >= 2C
    # 3) At least 5 climbing games: C >= 5
    # 4) T, C >= 0
    #
    # This is a small 2-variable LP; we can solve it analytically by checking corner points.
    
    best_value = float('-inf')
    
    # The feasible region is bounded by:
    # C >= 5
    # T >= 2C
    # 2T + 3C <= 100
    #
    # We can find candidate corner points by intersecting these lines.
    
    # 1) Intersection of T = 2C and 2T + 3C = 100
    # Substitute T = 2C into 2T + 3C = 100:
    # 2*(2C) + 3C = 100 -> 4C + 3C = 100 -> 7C = 100 -> C = 100/7, T = 200/7
    C1 = 100.0 / 7.0
    T1 = 2.0 * C1
    if C1 >= 5 and 2*T1 + 3*C1 <= 100 + 1e-9 and T1 >= 2*C1 - 1e-9:
        val1 = 15*T1 + 8*C1
        if val1 > best_value:
            best_value = val1
    
    # 2) Intersection of C = 5 and T = 2C
    C2 = 5.0
    T2 = 2.0 * C2
    if 2*T2 + 3*C2 <= 100 + 1e-9:
        val2 = 15*T2 + 8*C2
        if val2 > best_value:
            best_value = val2
    
    # 3) Intersection of C = 5 and 2T + 3C = 100
    C3 = 5.0
    T3 = (100.0 - 3.0*C3) / 2.0
    if T3 >= 2*C3 - 1e-9 and T3 >= 0:
        val3 = 15*T3 + 8*C3
        if val3 > best_value:
            best_value = val3
    
    # Also check the boundary where C = 5 and T is as large as allowed by cost:
    # This is already covered by point 3.
    # And boundary where T = 2C and C is as large as allowed by cost:
    # This is already covered by point 1.
    
    # Return the best objective value found
    return best_value
```",677.5,True,0.0,0.0,3.790576457977295,
191,79000.0,"```python
def solve():
    # We solve the LP by enumerating corner points of the feasible region.
    # Variables:
    #   T = hectares of tomatoes
    #   P = hectares of potatoes
    #
    # Maximize: 350*T + 600*P
    #
    # Subject to:
    #   1) T + P <= 140
    #   2) T >= P        (more tomatoes than potatoes)
    #   3) T <= 2P       (at most twice the amount of tomatoes as potatoes)
    #   4) T >= 20
    #   5) P >= 30
    
    # We'll find all intersection points of the boundary lines and
    # keep those that satisfy all constraints, then evaluate the objective.
    
    import math
    
    # Helper to check feasibility
    def feasible(T, P):
        eps = 1e-9
        if T + P > 140 + eps:
            return False
        if T < P - eps:
            return False
        if T > 2*P + eps:
            return False
        if T < 20 - eps:
            return False
        if P < 30 - eps:
            return False
        return True
    
    # List of candidate points from intersecting boundary lines:
    candidates = []
    
    # Boundaries as equations:
    # a) T + P = 140
    # b) T = P
    # c) T = 2P
    # d) T = 20
    # e) P = 30
    
    # 1) Intersection of T + P = 140 and T = P
    #    => 2T = 140 => T = 70, P = 70
    candidates.append((70.0, 70.0))
    
    # 2) Intersection of T + P = 140 and T = 2P
    #    => 2P + P = 140 => 3P = 140 => P = 140/3, T = 280/3
    P = 140.0 / 3.0
    T = 2.0 * P
    candidates.append((T, P))
    
    # 3) Intersection of T + P = 140 and T = 20
    #    => 20 + P = 140 => P = 120
    candidates.append((20.0, 120.0))
    
    # 4) Intersection of T + P = 140 and P = 30
    #    => T + 30 = 140 => T = 110
    candidates.append((110.0, 30.0))
    
    # 5) Intersection of T = P and T = 20
    #    => T = 20, P = 20
    candidates.append((20.0, 20.0))
    
    # 6) Intersection of T = P and P = 30
    #    => T = 30, P = 30
    candidates.append((30.0, 30.0))
    
    # 7) Intersection of T = 2P and P = 30
    #    => T = 60, P = 30
    candidates.append((60.0, 30.0))
    
    # 8) Intersection of T = 2P and T = 20
    #    => 20 = 2P => P = 10
    candidates.append((20.0, 10.0))
    
    # 9) Intersection of T = 20 and P = 30
    candidates.append((20.0, 30.0))
    
    # Evaluate feasible candidates
    best_value = -math.inf
    for T, P in candidates:
        if feasible(T, P):
            value = 350.0 * T + 600.0 * P
            if value > best_value:
                best_value = value
    
    return float(best_value)
```",66500.0,False,12500.0,0.1582278481012638,3.979128837585449,
192,2500.0,"```python
def solve():
    # We model:
    # L = number of labradors
    # G = number of golden retrievers
    #
    # Maximize: 7L + 10G
    # Subject to:
    # 5L + 6G <= 1500        (treats)
    # G >= 50                (at least 50 goldens)
    # L <= 1.5 * G           (at most 60% labradors: L / (L+G) <= 0.6 -> L <= 1.5G)
    # L, G >= 0
    #
    # This is a 2-variable LP; we can solve it by checking corner points of the feasible region.

    best_value = float('-inf')

    # Helper to check feasibility and update best value
    def consider(L, G):
        nonlocal best_value
        if L < 0 or G < 0:
            return
        if G < 50:
            return
        if L > 1.5 * G + 1e-9:  # small tolerance
            return
        if 5 * L + 6 * G > 1500 + 1e-9:
            return
        value = 7 * L + 10 * G
        if value > best_value:
            best_value = value

    # Candidate corner points come from intersections of constraints:
    # 1) 5L + 6G = 1500 with L = 1.5G
    #    => 5(1.5G) + 6G = 1500 => 7.5G + 6G = 13.5G = 1500 => G = 1500/13.5
    G = 1500.0 / 13.5
    L = 1.5 * G
    consider(L, G)

    # 2) 5L + 6G = 1500 with G = 50
    G = 50.0
    L = (1500.0 - 6 * G) / 5.0
    consider(L, G)

    # 3) L = 1.5G with G = 50
    G = 50.0
    L = 1.5 * G
    consider(L, G)

    # 4) Boundary where treats fully used and L = 0
    L = 0.0
    G = 1500.0 / 6.0
    consider(L, G)

    # 5) Boundary where treats fully used and G = 50 (already considered above),
    #    but also check G = 50 with L from other constraints:
    G = 50.0
    L = 0.0
    consider(L, G)

    # 6) Also check where L = 1.5G and treats not necessarily tight but G at minimum 50
    #    (already considered as case 3).

    # The best_value is the optimal objective value (continuous LP).
    return float(best_value)
```",2500.0,True,0.0,0.0,4.010824680328369,
193,65.0,"```python
def solve():
    # We want to minimize total concerts: z = x + y
    # x = number of pop concerts, y = number of R&B concerts
    
    # Constraints:
    # 1) Audience: 100x + 240y >= 10000
    # 2) Practice days: 2x + 4y <= 180
    # 3) R&B limit: y <= 0.4(x + y)  ->  0.6y <= 0.4x  ->  3y <= 2x  ->  y <= (2/3)x
    # 4) x, y >= 0
    
    # Since the problem is small and linear, we can brute-force over reasonable integer values.
    # Upper bounds:
    # From practice: 2x + 4y <= 180 -> x + 2y <= 90, so x <= 90 and y <= 45.
    
    best_value = None
    
    for x in range(0, 91):      # x from 0 to 90
        for y in range(0, 46):  # y from 0 to 45
            # Check constraints
            if 100 * x + 240 * y < 10000:
                continue
            if 2 * x + 4 * y > 180:
                continue
            if 3 * y > 2 * x:  # y <= (2/3)x
                continue
            
            total_concerts = x + y
            if best_value is None or total_concerts < best_value:
                best_value = total_concerts
    
    # The function should return the optimal objective value (minimal total concerts) as float.
    return float(best_value)
```",65.0,True,0.0,0.0,2.460428237915039,
194,175.0,"```python
def solve():
    # We solve the LP:
    # Minimize: 14x + 25y
    # Subject to:
    #   30x + 60y >= 400  (Calcium)
    #   50x + 10y >= 50   (Magnesium)
    #   x >= 0, y >= 0
    
    # We'll solve analytically by checking:
    # 1) Intersection of the two constraint lines
    # 2) Intersection with axes (where one variable is zero)
    # and then picking the feasible point with minimum cost.
    
    best_cost = float('inf')
    
    # Helper to check feasibility and update best cost
    def check_point(x, y):
        nonlocal best_cost
        if x < 0 or y < 0:
            return
        if 30*x + 60*y >= 400 and 50*x + 10*y >= 50:
            cost = 14*x + 25*y
            if cost < best_cost:
                best_cost = cost
    
    # 1) Intersection of the two constraints:
    # 30x + 60y = 400
    # 50x + 10y = 50
    # Solve the system:
    # From second: 50x + 10y = 50 -> 5x + y = 5 -> y = 5 - 5x
    # Substitute into first:
    # 30x + 60(5 - 5x) = 400
    # 30x + 300 - 300x = 400
    # -270x = 100
    # x = -100/270 (negative, so infeasible)
    x_inter = -100.0 / 270.0
    y_inter = 5 - 5 * x_inter
    check_point(x_inter, y_inter)  # will be rejected due to x < 0
    
    # 2) Intersection with x-axis (y = 0)
    # Calcium: 30x >= 400 -> x >= 400/30
    # Magnesium: 50x >= 50 -> x >= 1
    # So x >= max(400/30, 1) = 400/30
    x = 400.0 / 30.0
    y = 0.0
    check_point(x, y)
    
    # 3) Intersection with y-axis (x = 0)
    # Calcium: 60y >= 400 -> y >= 400/60
    # Magnesium: 10y >= 50 -> y >= 5
    # So y >= max(400/60, 5) = 20/3
    x = 0.0
    y = 20.0 / 3.0
    check_point(x, y)
    
    # best_cost now holds the minimum cost among feasible candidates
    return float(best_cost)
```",166.66666666666669,False,8.333333333333314,0.047619047618775404,3.384290933609009,
195,800.0,"```python
def solve():
    # We solve the LP by brute force over integer numbers of bridges.
    # Let x = number of beam bridges, y = number of truss bridges.
    # Constraints:
    # 1) 30x + 50y <= 600  (Popsicle sticks)
    # 2) 5x + 8y <= 100    (Glue)
    # 3) y <= 5            (At most 5 truss bridges)
    # 4) x > y             (Number of beam bridges must be larger than truss bridges)
    # 5) x, y >= 0 and integers
    #
    # Objective: maximize 40x + 60y
    
    best_value = float('-inf')
    
    # Upper bounds for search (from resource constraints)
    max_x_sticks = 600 // 30  # 20
    max_x_glue = 100 // 5     # 20
    max_x = min(max_x_sticks, max_x_glue)
    max_y_sticks = 600 // 50  # 12
    max_y_glue = 100 // 8     # 12
    max_y = min(max_y_sticks, max_y_glue, 5)  # also y <= 5
    
    for x in range(max_x + 1):
        for y in range(max_y + 1):
            if x <= y:
                continue  # must have x > y
            if 30 * x + 50 * y > 600:
                continue
            if 5 * x + 8 * y > 100:
                continue
            value = 40 * x + 60 * y
            if value > best_value:
                best_value = value
    
    return float(best_value)
```",800.0,True,0.0,0.0,2.7597289085388184,
196,110.0,"```python
def solve():
    # We solve the LP:
    # Minimize S = 20x + 15y
    # Subject to:
    #   30x + 20y >= 100   (protein)
    #   350x + 300y >= 2000 (calories)
    #   y <= (7/13) * x     (omega at most 35% of total)
    #   x >= 0, y >= 0
    #
    # We'll find all candidate corner points formed by intersections of
    # the constraint boundaries and check feasibility and objective value.
    
    INF = float('inf')
    
    def is_feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 30*x + 20*y < 100 - 1e-9:
            return False
        if 350*x + 300*y < 2000 - 1e-9:
            return False
        if y - (7.0/13.0)*x > 1e-9:
            return False
        return True
    
    candidates = []
    
    # 1) Intersection of protein and calories:
    # 30x + 20y = 100
    # 350x + 300y = 2000
    # Solve:
    # From first: y = (100 - 30x)/20
    # Plug into second:
    # 350x + 300*(100 - 30x)/20 = 2000
    # 350x + 15*(100 - 30x) = 2000
    # 350x + 1500 - 450x = 2000
    # -100x = 500 -> x = -5 (infeasible, but we still compute)
    x1 = -5.0
    y1 = (100 - 30*x1)/20.0
    candidates.append((x1, y1))
    
    # 2) Intersection of protein and omega-ratio:
    # 30x + 20y = 100
    # y = (7/13)x
    # 30x + 20*(7/13)x = 100
    # x*(30 + 140/13) = 100
    # 30 = 390/13, so 30 + 140/13 = 530/13
    # x = 100 * 13 / 530 = 1300/530 = 130/53
    x2 = 130.0/53.0
    y2 = (7.0/13.0)*x2
    candidates.append((x2, y2))
    
    # 3) Intersection of calories and omega-ratio:
    # 350x + 300y = 2000
    # y = (7/13)x
    # 350x + 300*(7/13)x = 2000
    # 350x + (2100/13)x = 2000
    # 350 = 4550/13, so sum = 6650/13
    # x = 2000 * 13 / 6650 = 26000/6650 = 260/66.5 = 520/133
    x3 = 520.0/133.0
    y3 = (7.0/13.0)*x3
    candidates.append((x3, y3))
    
    # 4) Intersections with axes:
    # x = 0 with protein: 20y = 100 -> y = 5
    x4, y4 = 0.0, 5.0
    candidates.append((x4, y4))
    
    # x = 0 with calories: 300y = 2000 -> y = 2000/300
    x5, y5 = 0.0, 2000.0/300.0
    candidates.append((x5, y5))
    
    # y = 0 with protein: 30x = 100 -> x = 100/30
    x6, y6 = 100.0/30.0, 0.0
    candidates.append((x6, y6))
    
    # y = 0 with calories: 350x = 2000 -> x = 2000/350
    x7, y7 = 2000.0/350.0, 0.0
    candidates.append((x7, y7))
    
    # Also consider the intersection of protein and calories already done,
    # and intersection of each with y=0 or x=0 are above.
    
    best_val = INF
    for x, y in candidates:
        if is_feasible(x, y):
            val = 20.0*x + 15.0*y
            if val < best_val:
                best_val = val
    
    # Return the optimal objective value as float
    return best_val
```",109.77443609022556,False,0.2255639097744364,0.0020505809979307803,14.337982177734375,
197,19.0,"```python
def solve():
    # We need to minimize total animals: x (camels) + y (horses)
    # Subject to:
    # 1) 50x + 60y >= 1000  (packages)
    # 2) 20x + 30y <= 450   (food)
    # 3) y <= x             (horses not exceed camels)
    # 4) x, y >= 0 and integers (implicitly, since animals are discrete)
    #
    # We'll brute-force over reasonable integer ranges for x and y.
    # From food constraint: 20x + 30y <= 450 -> x <= 22.5, y <= 15
    # So we can search x in [0, 23], y in [0, 16].

    best_value = None

    for x in range(0, 24):      # camels
        for y in range(0, 24):  # horses (upper bound generous but small)
            # Check constraints
            if 50 * x + 60 * y < 1000:
                continue
            if 20 * x + 30 * y > 450:
                continue
            if y > x:
                continue

            total_animals = x + y
            if best_value is None or total_animals < best_value:
                best_value = total_animals

    # The function should return the optimal objective value (minimum number of animals)
    return float(best_value if best_value is not None else 0.0)
```",19.0,True,0.0,0.0,2.767881393432617,
198,-99999.0,"```python
def solve():
    # We need to solve the LP:
    # Minimize: 4x + 5y
    # Subject to:
    #   3x + 6y >= 40   (sleep-inducing)
    #   5x + 1y >= 50   (anti-inflammatory)
    #   x >= 0, y >= 0
    #
    # We'll solve this by checking all corner points of the feasible region.
    # Corner points come from intersections of constraint lines and axes.

    best = float('inf')

    # 1) Intersection of the two constraint lines:
    #    3x + 6y = 40
    #    5x +  y = 50
    # Solve the system:
    # From second: y = 50 - 5x
    # Substitute into first:
    # 3x + 6(50 - 5x) = 40
    # 3x + 300 - 30x = 40
    # -27x = -260
    # x = 260/27
    x = 260.0 / 27.0
    y = 50.0 - 5.0 * x
    if x >= 0 and y >= 0:
        cost = 4.0 * x + 5.0 * y
        if cost < best:
            best = cost

    # 2) Intersection with x-axis (y = 0):
    #    3x >= 40  -> x >= 40/3
    #    5x >= 50  -> x >= 10
    # So the smallest feasible x on x-axis is x = 10, y = 0
    x = 10.0
    y = 0.0
    cost = 4.0 * x + 5.0 * y
    if cost < best:
        best = cost

    # 3) Intersection with y-axis (x = 0):
    #    6y >= 40 -> y >= 40/6 = 20/3
    #    y >= 50
    # So the smallest feasible y on y-axis is y = 50, x = 0
    x = 0.0
    y = 50.0
    cost = 4.0 * x + 5.0 * y
    if cost < best:
        best = cost

    return best
```",40.0,False,100039.0,1.00040000400003,3.277492046356201,
199,14.0,"```python
def solve():
    # We solve the LP:
    # Maximize  6x + 7y
    # subject to:
    #   6x + 5y <= 10   (apples)
    #   6y      <= 20   (bananas)
    #   30x +20y <= 80  (grapes)
    #   x, y >= 0
    
    # This is a 2-variable LP; we can solve it by checking all corner points
    # formed by intersections of constraint lines and axes.
    
    import math

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 6*x + 5*y > 10 + 1e-9:
            return False
        if 6*y > 20 + 1e-9:
            return False
        if 30*x + 20*y > 80 + 1e-9:
            return False
        return True

    # Collect candidate points (corner points)
    candidates = []

    # 1) Intersections with axes
    # y = 0
    # From 6x + 5y <= 10 -> x <= 10/6
    # From 30x + 20y <= 80 -> x <= 80/30
    x_max_y0 = min(10/6.0, 80/30.0)
    candidates.append((0.0, 0.0))
    candidates.append((x_max_y0, 0.0))

    # x = 0
    # From 6x + 5y <= 10 -> y <= 10/5 = 2
    # From 6y <= 20 -> y <= 20/6
    # From 30x + 20y <= 80 -> y <= 80/20 = 4
    y_max_x0 = min(2.0, 20/6.0, 4.0)
    candidates.append((0.0, y_max_x0))

    # 2) Pairwise intersections of constraint boundaries:
    # a) 6x + 5y = 10 and 6y = 20
    #    => y = 20/6, plug into first
    y = 20/6.0
    x = (10 - 5*y) / 6.0
    candidates.append((x, y))

    # b) 6x + 5y = 10 and 30x + 20y = 80
    # Solve the system:
    # 6x + 5y = 10
    # 30x + 20y = 80
    # Multiply first eqn by 4: 24x + 20y = 40
    # Subtract from second: 6x = 40 -> x = 40/6
    x = 40/6.0
    y = (10 - 6*x) / 5.0
    candidates.append((x, y))

    # c) 6y = 20 and 30x + 20y = 80
    # y = 20/6
    y = 20/6.0
    x = (80 - 20*y) / 30.0
    candidates.append((x, y))

    best_val = -math.inf
    for x, y in candidates:
        if feasible(x, y):
            val = 6*x + 7*y
            if val > best_val:
                best_val = val

    return float(best_val)
```",14.0,True,0.0,0.0,4.504465341567993,
200,100.0,"```python
def solve():
    # We need to minimize space: 5E + 2L
    # Subject to:
    # 1) Capacity: 20E + 8L >= 400
    # 2) At least three times more escalators than elevators: E >= 3L
    # 3) At least 2 elevators: L >= 2
    #
    # E, L are assumed continuous (linear programming).
    #
    # We'll solve this small LP by enumerating corner points of the feasible region.
    # Constraints in standard form:
    #   (A) 20E + 8L >= 400
    #   (B) E - 3L >= 0
    #   (C) L - 2 >= 0
    #
    # Convert >= to equalities for intersections:
    #   A_eq: 20E + 8L = 400
    #   B_eq: E - 3L = 0
    #   C_eq: L = 2
    #
    # Candidate corner points come from intersecting pairs of boundary lines,
    # then checking feasibility.

    candidates = []

    # Intersection of A_eq and B_eq:
    # From B_eq: E = 3L
    # Substitute into A_eq: 20*(3L) + 8L = 400 -> 60L + 8L = 400 -> 68L = 400
    L = 400.0 / 68.0
    E = 3.0 * L
    candidates.append((E, L))

    # Intersection of A_eq and C_eq:
    # From C_eq: L = 2
    # Substitute into A_eq: 20E + 8*2 = 400 -> 20E + 16 = 400 -> 20E = 384 -> E = 19.2
    L = 2.0
    E = 384.0 / 20.0
    candidates.append((E, L))

    # Intersection of B_eq and C_eq:
    # From C_eq: L = 2
    # From B_eq: E = 3L = 6
    L = 2.0
    E = 6.0
    candidates.append((E, L))

    # Now check feasibility and compute objective 5E + 2L
    best_value = None
    for E, L in candidates:
        # Check constraints:
        if 20*E + 8*L >= 400 - 1e-9 and E >= 3*L - 1e-9 and L >= 2 - 1e-9:
            value = 5*E + 2*L
            if best_value is None or value < best_value:
                best_value = value

    return float(best_value)
```",100.0,True,0.0,0.0,4.609620809555054,
201,2000.0,"```python
def solve():
    # Let x = slices of cheesecake, y = slices of caramel cake
    # Maximize sugar: 40x + 50y
    # Subject to:
    # 1) 200x + 250y <= 10000  (calories)
    # 2) x >= 3y               (at least 3 times as many cheesecake slices)
    # 3) y >= 3                (at least 3 caramel slices)
    # 4) x, y >= 0 and integer (implicitly, since slices are countable)
    #
    # We'll brute-force over integer y and compute feasible x that maximizes sugar.
    
    best_value = float('-inf')
    
    # Upper bound for y from calories: 250y <= 10000 -> y <= 40
    for y in range(3, 41):  # y >= 3
        # From x >= 3y
        x_min = 3 * y
        
        # From calories: 200x + 250y <= 10000 -> x <= (10000 - 250y) / 200
        max_x_cal = (10000 - 250 * y) // 200  # integer floor
        
        if max_x_cal < x_min:
            continue  # no feasible x for this y
        
        x = max_x_cal  # choose largest feasible x to maximize sugar
        
        sugar = 40 * x + 50 * y
        if sugar > best_value:
            best_value = sugar
    
    return float(best_value)
```",2000.0,True,0.0,0.0,3.074279546737671,
202,1125.0,"```python
def solve():
    # We formulate the LP:
    # Let x = acres with small wells, y = acres with large wells.
    # Maximize:  Z = 2x + 5y
    # Subject to:
    #   1) Land:        x + y <= 300
    #   2) Drill bits:  5x + 10y <= 2500
    #   3) Pollution:   10x + 20y <= 4500
    #   4) x >= 0, y >= 0
    #
    # Note that constraints 2 and 3 are equivalent:
    #   5x + 10y <= 2500  -> divide by 5 -> x + 2y <= 500
    #   10x + 20y <= 4500 -> divide by 10 -> x + 2y <= 450
    # The pollution constraint (x + 2y <= 450) is tighter, so the drill-bit
    # constraint is redundant. We keep:
    #   x + y <= 300
    #   x + 2y <= 450
    #   x, y >= 0
    #
    # The feasible region is a polygon; we check its corner points:
    #   A: (0, 0)
    #   B: intersection of x + y = 300 and x + 2y = 450
    #   C: intersection of x + 2y = 450 with x = 0
    #   D: intersection of x + y = 300 with y = 0
    #
    # Compute intersection B:
    #   From x + y = 300 -> x = 300 - y
    #   Substitute into x + 2y = 450:
    #       300 - y + 2y = 450 -> 300 + y = 450 -> y = 150
    #       x = 300 - 150 = 150
    #
    # C: x = 0, x + 2y = 450 -> y = 225
    # D: y = 0, x + y = 300 -> x = 300
    #
    # Evaluate objective Z = 2x + 5y at each corner:
    #   A: (0, 0)     -> Z = 0
    #   B: (150, 150) -> Z = 2*150 + 5*150 = 300 + 750 = 1050
    #   C: (0, 225)   -> Z = 5*225 = 1125
    #   D: (300, 0)   -> Z = 2*300 = 600
    #
    # Maximum is 1125 at (x, y) = (0, 225).
    #
    # The function must return the optimal objective value as a float.
    return float(1125.0)
```",1125.0,True,0.0,0.0,3.9945197105407715,
203,1552.0,"```python
def solve():
    # We want to maximize 10x + 8y
    # subject to:
    # 5x + 7y <= 1000  (rare inert gas)
    # 6x + 3y <= 800   (treated water)
    # x, y >= 0
    
    # The optimum of a 2-variable LP with linear constraints occurs at a corner point.
    # Candidate corner points come from intersections of constraint lines and axes.
    
    # 1) Intersection of 5x + 7y = 1000 and 6x + 3y = 800
    # Solve the system:
    # 5x + 7y = 1000
    # 6x + 3y = 800
    
    # From second: 6x + 3y = 800 -> divide by 3: 2x + y = 800/3 -> y = 800/3 - 2x
    # Substitute into first:
    # 5x + 7(800/3 - 2x) = 1000
    # 5x + 5600/3 - 14x = 1000
    # -9x + 5600/3 = 1000
    # -9x = 1000 - 5600/3 = (3000 - 5600)/3 = -2600/3
    # x = (2600/3) / 9 = 2600 / 27
    x_intersect = 2600.0 / 27.0
    # y = 800/3 - 2x
    y_intersect = 800.0 / 3.0 - 2.0 * x_intersect
    
    # Check feasibility (should be feasible by construction)
    def feasible(x, y):
        return (x >= 0 and y >= 0 and
                5*x + 7*y <= 1000 + 1e-9 and
                6*x + 3*y <= 800 + 1e-9)
    
    candidates = []
    
    # Intersection point
    if feasible(x_intersect, y_intersect):
        candidates.append((x_intersect, y_intersect))
    
    # 2) Intersections with axes:
    # x = 0:
    # 5*0 + 7y <= 1000 -> y <= 1000/7
    # 6*0 + 3y <= 800 -> y <= 800/3
    y_max_x0 = min(1000.0/7.0, 800.0/3.0)
    candidates.append((0.0, y_max_x0))
    
    # y = 0:
    # 5x <= 1000 -> x <= 200
    # 6x <= 800 -> x <= 800/6 = 400/3
    x_max_y0 = min(200.0, 400.0/3.0)
    candidates.append((x_max_y0, 0.0))
    
    # Evaluate objective 10x + 8y at all candidates
    best_value = float('-inf')
    for x, y in candidates:
        if feasible(x, y):
            value = 10.0 * x + 8.0 * y
            if value > best_value:
                best_value = value
    
    return best_value
```",1555.5555555555557,False,3.5555555555556566,0.002290950744557581,4.71298360824585,
204,750.0,"```python
def solve():
    # We want to maximize 5x + 7y
    # subject to:
    # 3x + 5y <= 500  (gold)
    # 2x + 3y <= 300  (wires)
    # x, y >= 0
    
    # This is a 2-variable LP; the optimum lies at a corner of the feasible region.
    # We'll enumerate all corner points formed by intersections of constraints and axes.
    
    best_value = 0.0
    
    # Candidate 1: intersection of both constraints
    # Solve:
    # 3x + 5y = 500
    # 2x + 3y = 300
    # Using elimination:
    # From second: 2x = 300 - 3y => x = (300 - 3y)/2
    # Substitute into first:
    # 3*(300 - 3y)/2 + 5y = 500
    # (900 - 9y)/2 + 5y = 500
    # 900 - 9y + 10y = 1000
    # 900 + y = 1000 => y = 100
    # Then x = (300 - 3*100)/2 = 0
    x = 0.0
    y = 100.0
    if 3*x + 5*y <= 500 + 1e-9 and 2*x + 3*y <= 300 + 1e-9 and x >= -1e-9 and y >= -1e-9:
        value = 5*x + 7*y
        if value > best_value:
            best_value = value
    
    # Candidate 2: intersection of gold constraint with x-axis (y = 0)
    # 3x <= 500 => x = 500/3
    x = 500.0 / 3.0
    y = 0.0
    if 3*x + 5*y <= 500 + 1e-9 and 2*x + 3*y <= 300 + 1e-9 and x >= -1e-9 and y >= -1e-9:
        value = 5*x + 7*y
        if value > best_value:
            best_value = value
    
    # Candidate 3: intersection of wire constraint with x-axis (y = 0)
    # 2x <= 300 => x = 150
    x = 150.0
    y = 0.0
    if 3*x + 5*y <= 500 + 1e-9 and 2*x + 3*y <= 300 + 1e-9 and x >= -1e-9 and y >= -1e-9:
        value = 5*x + 7*y
        if value > best_value:
            best_value = value
    
    # Candidate 4: intersection of gold constraint with y-axis (x = 0)
    # 5y <= 500 => y = 100
    x = 0.0
    y = 100.0
    if 3*x + 5*y <= 500 + 1e-9 and 2*x + 3*y <= 300 + 1e-9 and x >= -1e-9 and y >= -1e-9:
        value = 5*x + 7*y
        if value > best_value:
            best_value = value
    
    # Candidate 5: intersection of wire constraint with y-axis (x = 0)
    # 3y <= 300 => y = 100
    x = 0.0
    y = 100.0
    if 3*x + 5*y <= 500 + 1e-9 and 2*x + 3*y <= 300 + 1e-9 and x >= -1e-9 and y >= -1e-9:
        value = 5*x + 7*y
        if value > best_value:
            best_value = value
    
    # Candidate 6: origin
    x = 0.0
    y = 0.0
    if 3*x + 5*y <= 500 + 1e-9 and 2*x + 3*y <= 300 + 1e-9 and x >= -1e-9 and y >= -1e-9:
        value = 5*x + 7*y
        if value > best_value:
            best_value = value
    
    return float(best_value)
```",750.0,True,0.0,0.0,6.947753667831421,
205,200.0,"```python
def solve():
    # We solve the LP:
    # Maximize:  8x + 10y
    # Subject to:
    #   3x + 5y <= 200   (metal)
    #   5x + 8y <= 300   (acid)
    #   2x + 3y <= 50    (heat)
    #   x >= 0, y >= 0
    #
    # Since it's 2D, we can solve by checking all corner points of the feasible region.

    import math

    def intersect(a1, b1, c1, a2, b2, c2):
        # Solve:
        # a1 x + b1 y = c1
        # a2 x + b2 y = c2
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-12:
            return None
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)

    # Constraints in form a x + b y <= c
    constraints = [
        (3.0, 5.0, 200.0),  # metal
        (5.0, 8.0, 300.0),  # acid
        (2.0, 3.0, 50.0)    # heat
    ]

    # Candidate points: intersections of each pair of constraints, and with axes.
    candidates = []

    # Intersections of constraint pairs
    for i in range(len(constraints)):
        for j in range(i + 1, len(constraints)):
            p = intersect(*constraints[i], *constraints[j])
            if p is not None:
                candidates.append(p)

    # Intersections with x = 0 and y = 0
    # For each constraint a x + b y <= c:
    # with x = 0 -> y = c / b
    # with y = 0 -> x = c / a
    for (a, b, c) in constraints:
        if abs(b) > 1e-12:
            candidates.append((0.0, c / b))
        if abs(a) > 1e-12:
            candidates.append((c / a, 0.0))

    # Also include origin
    candidates.append((0.0, 0.0))

    def feasible(x, y):
        if x < -1e-9 or y < -1e-9:
            return False
        for (a, b, c) in constraints:
            if a * x + b * y - c > 1e-9:
                return False
        return True

    best_val = -math.inf
    for (x, y) in candidates:
        if feasible(x, y):
            val = 8.0 * x + 10.0 * y
            if val > best_val:
                best_val = val

    return best_val
```",200.0,True,0.0,0.0,3.602816343307495,
206,610.0,"```python
def solve():
    # Let x = number of kayak trips, y = number of motorboat trips
    # Constraints:
    # 1) 4x + 5y >= 550          (people capacity)
    # 2) y <= 25                 (motorboat trip limit)
    # 3) x + y > 0 and x >= 0, y >= 0
    # 4) At least 75% of trips by kayak:
    #    x >= 3y  (since x / (x + y) >= 0.75  =>  x >= 3y)
    #
    # Objective: minimize total time T = 5x + 3y (minutes)
    #
    # x, y are integers (trips).
    #
    # We'll brute-force over feasible integer y and compute minimal feasible x.

    best_time = None

    for y in range(0, 26):  # y <= 25
        # From x >= 3y
        x_min_ratio = 3 * y

        # From capacity: 4x + 5y >= 550  =>  x >= (550 - 5y)/4
        required_x = (550 - 5 * y)
        if required_x <= 0:
            x_min_capacity = 0
        else:
            # ceiling division for integers
            x_min_capacity = (required_x + 3) // 4

        x_min = max(x_min_ratio, x_min_capacity)

        # Need at least one trip in total if there are people to move
        if x_min + y <= 0:
            continue

        # Compute time
        time = 5 * x_min + 3 * y

        if best_time is None or time < best_time:
            best_time = time

    # Return the optimal objective value as float
    return float(best_time)
```",610.0,True,0.0,0.0,2.377610921859741,
207,50.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 5x1 + 6x2
    # Subject to:
    #   3x1 + 5x2 <= 80   (red)
    #   4x1 + 3x2 <= 70   (blue)
    #   x1 + 2x2 <= 10    (smelly gas)
    #   x1 >= 0, x2 >= 0
    #
    # We'll find all candidate corner points (intersections of constraint lines and axes),
    # check feasibility, and evaluate the objective.

    import math

    def intersect(a1, b1, c1, a2, b2, c2):
        # Solve:
        # a1 x + b1 y = c1
        # a2 x + b2 y = c2
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-9:
            return None
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)

    # Constraints in equality form for intersections:
    # 1) 3x1 + 5x2 = 80
    # 2) 4x1 + 3x2 = 70
    # 3) x1 + 2x2 = 10

    candidates = []

    # Intersections of pairs of constraint lines
    pairs = [
        ((3, 5, 80), (4, 3, 70)),
        ((3, 5, 80), (1, 2, 10)),
        ((4, 3, 70), (1, 2, 10)),
    ]

    for (a1, b1, c1), (a2, b2, c2) in pairs:
        pt = intersect(a1, b1, c1, a2, b2, c2)
        if pt is not None:
            candidates.append(pt)

    # Intersections with axes (x1=0 or x2=0) for each constraint
    # x1 = 0
    # 3*0 + 5x2 <= 80 -> x2 <= 16
    candidates.append((0.0, 0.0))
    candidates.append((0.0, 80.0 / 5.0))  # from red
    candidates.append((0.0, 70.0 / 3.0))  # from blue
    candidates.append((0.0, 10.0 / 2.0))  # from smelly

    # x2 = 0
    candidates.append((80.0 / 3.0, 0.0))  # from red
    candidates.append((70.0 / 4.0, 0.0))  # from blue
    candidates.append((10.0, 0.0))        # from smelly

    # Check feasibility and compute objective
    best_val = -math.inf
    for x1, x2 in candidates:
        if x1 < -1e-9 or x2 < -1e-9:
            continue
        if 3 * x1 + 5 * x2 > 80 + 1e-9:
            continue
        if 4 * x1 + 3 * x2 > 70 + 1e-9:
            continue
        if x1 + 2 * x2 > 10 + 1e-9:
            continue
        val = 5 * x1 + 6 * x2
        if val > best_val:
            best_val = val

    return float(best_val)
```",50.0,True,0.0,0.0,4.179491996765137,
208,819.0,"```python
def solve():
    # We solve the LP:
    # Maximize 12L + 5S
    # subject to:
    #   10L + 7S <= 1000
    #   S >= 5L
    #   L >= 10
    #   L, S >= 0
    
    best_profit = float('-inf')
    best_L = None
    best_S = None

    # Since 10L + 7S <= 1000 and S >= 0, L is at most 100 (if S=0).
    # We'll brute-force over integer L and S that satisfy constraints.
    for L in range(0, 101):
        for S in range(0, 1010):  # upper bound from 7S <= 1000 -> S <= ~142, 1010 is safe
            if 10 * L + 7 * S <= 1000 and S >= 5 * L and L >= 10:
                profit = 12 * L + 5 * S
                if profit > best_profit:
                    best_profit = profit
                    best_L = L
                    best_S = S

    # The problem asks to return the optimal objective value (max profit).
    return float(best_profit)
```",819.0,True,0.0,0.0,1.741934061050415,
209,890.0,"```python
def solve():
    # We want to maximize profit:
    # Let x = number of plush toys, y = number of dolls
    # Cost constraint: 3x + 2y <= 700
    # Profit: 4x + 2y
    # Bounds: 90 <= x <= 190
    #         y <= 2x
    #         x, y >= 0
    
    best_profit = float('-inf')
    
    # Since costs and bounds are small, we can brute force over integer x, y
    for x in range(90, 191):  # x from 90 to 190 inclusive
        # y must satisfy:
        # 3x + 2y <= 700  -> y <= (700 - 3x)/2
        # y <= 2x
        # y >= 0
        max_y_cost = (700 - 3 * x) // 2
        max_y_bound = 2 * x
        max_y = min(max_y_cost, max_y_bound)
        if max_y < 0:
            continue
        
        # Profit is increasing in y (coefficient 2 > 0), so take largest feasible y
        y = max_y
        
        profit = 4 * x + 2 * y
        if profit > best_profit:
            best_profit = profit
    
    return float(best_profit)
```",890.0,True,0.0,0.0,1.7756152153015137,
210,310.0,"```python
def solve():
    # We solve the LP:
    # Minimize 30x + 25y
    # s.t.
    #   100x + 80y >= 1000
    #   x <= 6
    #   y >= x          (at least 50% of trips by boat)
    #   x, y >= 0
    
    # Since it's a 2-variable LP with small bounds, we can brute-force
    # over a reasonable grid and find the minimum.
    # x and y represent number of trips; they can be fractional in LP.
    
    best_val = None
    # Search over x in [0, 6] with small step
    step = 0.001
    x = 0.0
    while x <= 6.0000001:
        # y must be at least x and also satisfy mail constraint:
        # 100x + 80y >= 1000  =>  y >= (1000 - 100x)/80
        y_min_mail = (1000.0 - 100.0 * x) / 80.0
        if y_min_mail < 0:
            y_min_mail = 0.0
        y_start = max(x, y_min_mail)
        # If even at y_start the mail constraint is not satisfied, skip
        if 100.0 * x + 80.0 * y_start < 1000.0:
            x += step
            continue
        # For fixed x, objective increases with y (since 25 > 0),
        # so optimal y is the smallest feasible y, i.e., y_start.
        val = 30.0 * x + 25.0 * y_start
        if (best_val is None) or (val < best_val):
            best_val = val
        x += step
    
    return best_val
```",305.55624999999975,False,4.44375000000025,0.014334677419309405,3.3496265411376953,
211,555.0,"```python
def solve():
    # We model:
    # x = number of bus trips
    # y = number of car trips
    #
    # Constraints:
    # 1) Capacity: 20x + 6y >= 300
    # 2) Bus trip limit: x <= 10
    # 3) At least 60% trips by car: y >= 1.5x
    # 4) x, y >= 0
    #
    # Objective: minimize total time T = 30x + 15y
    #
    # This is a small LP; we can brute-force over a reasonable range of x, y.
    # Since x <= 10 and capacity requires 6y >= 300 - 20x, we can bound y.
    # We'll search over integer x, y (trips are naturally integer).
    
    best_value = None
    
    # x is bounded by 0 to 10
    for x in range(0, 11):
        # From capacity: 20x + 6y >= 300 -> y >= (300 - 20x)/6 if RHS positive
        min_y_capacity = 0
        rhs = 300 - 20 * x
        if rhs > 0:
            min_y_capacity = rhs / 6.0
        
        # From car-trip proportion: y >= 1.5x
        min_y_ratio = 1.5 * x
        
        # Overall lower bound on y
        min_y = max(min_y_capacity, min_y_ratio, 0.0)
        
        # y must be integer trips, so start from ceil(min_y)
        y_start = int(-(-min_y // 1))  # ceiling without math
        
        # We don't know an explicit upper bound, but capacity and objective
        # suggest we don't need very large y. We'll search up to a safe bound.
        # Max y if x=0: 6y >= 300 -> y >= 50. So 0..60 is safe.
        for y in range(y_start, 61):
            # Check constraints explicitly
            if 20 * x + 6 * y < 300:
                continue
            if y < 1.5 * x:
                continue
            if x > 10 or x < 0 or y < 0:
                continue
            
            value = 30 * x + 15 * y
            if best_value is None or value < best_value:
                best_value = value
    
    # Return the optimal objective value as float
    return float(best_value)
```",555.0,True,0.0,0.0,3.173255443572998,
212,430.7692307692307,"```python
def solve():
    # Let x = bowls of salmon, y = bowls of eggs
    # Minimize sodium: 80x + 20y
    # Subject to:
    # 1) Calories: 300x + 200y >= 2000
    # 2) Protein: 15x + 8y >= 90
    # 3) Egg limit: y <= (2/3)x   (from y <= 0.4(x + y))
    # 4) x, y >= 0

    # We'll solve analytically by checking all relevant corner points of the feasible region.

    import math

    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 300 * x + 200 * y < 2000:
            return False
        if 15 * x + 8 * y < 90:
            return False
        if y > (2.0 / 3.0) * x + 1e-9:  # small tolerance
            return False
        return True

    def sodium(x, y):
        return 80.0 * x + 20.0 * y

    candidates = []

    # Intersection of calories and protein:
    # 300x + 200y = 2000
    # 15x + 8y = 90
    # Solve:
    # From second: 15x + 8y = 90
    # Multiply by 20: 300x + 160y = 1800
    # Subtract from first: (300x+200y)-(300x+160y)=2000-1800 => 40y=200 => y=5
    # Then 15x + 8*5 = 90 => 15x + 40 = 90 => 15x = 50 => x = 50/15 = 10/3
    x1 = 10.0 / 3.0
    y1 = 5.0
    candidates.append((x1, y1))

    # Intersection of calories and egg limit:
    # 300x + 200y = 2000
    # y = (2/3)x
    # 300x + 200*(2/3)x = 2000 => 300x + (400/3)x = 2000
    # (900/3 + 400/3)x = 2000 => (1300/3)x = 2000 => x = 2000 * 3 / 1300
    x2 = 2000.0 * 3.0 / 1300.0
    y2 = (2.0 / 3.0) * x2
    candidates.append((x2, y2))

    # Intersection of protein and egg limit:
    # 15x + 8y = 90
    # y = (2/3)x
    # 15x + 8*(2/3)x = 90 => 15x + (16/3)x = 90
    # (45/3 + 16/3)x = 90 => (61/3)x = 90 => x = 90 * 3 / 61
    x3 = 90.0 * 3.0 / 61.0
    y3 = (2.0 / 3.0) * x3
    candidates.append((x3, y3))

    # Intersections with axes:

    # x-axis (y = 0) with calories: 300x = 2000 => x = 2000/300
    x4 = 2000.0 / 300.0
    y4 = 0.0
    candidates.append((x4, y4))

    # x-axis (y = 0) with protein: 15x = 90 => x = 6
    x5 = 6.0
    y5 = 0.0
    candidates.append((x5, y5))

    # y-axis (x = 0) with calories: 200y = 2000 => y = 10
    x6 = 0.0
    y6 = 10.0
    candidates.append((x6, y6))

    # y-axis (x = 0) with protein: 8y = 90 => y = 90/8
    x7 = 0.0
    y7 = 90.0 / 8.0
    candidates.append((x7, y7))

    # Filter feasible candidates and compute minimal sodium
    best_val = float('inf')
    for x, y in candidates:
        if feasible(x, y):
            val = sodium(x, y)
            if val < best_val:
                best_val = val

    # In case numerical issues miss the true optimum, we can also
    # do a small search over a reasonable grid around the candidates.
    # This is optional but keeps us robust without external libraries.

    # Determine rough bounds from constraints:
    # From calories alone with only salmon: x >= 2000/300 ~ 6.67
    # From protein alone with only salmon: x >= 6
    # From calories alone with only eggs: y >= 10
    # From protein alone with only eggs: y >= 11.25
    # But egg limit ties x and y, so we search in a moderate box.
    max_x = 50.0
    step = 0.05
    x_val = 0.0
    while x_val <= max_x:
        # y must be >= 0 and <= (2/3)x_val
        y_max = (2.0 / 3.0) * x_val
        y_val = 0.0
        while y_val <= y_max + 1e-9:
            if feasible(x_val, y_val):
                val = sodium(x_val, y_val)
                if val < best_val:
                    best_val = val
            y_val += step
        x_val += step

    return float(best_val)
```",430.7692307692307,True,0.0,0.0,6.113430738449097,
213,40.0,"```python
def solve():
    # We want to minimize x + y
    # Subject to:
    # 10x + 6y >= 300   (hours)
    # 300x + 100y <= 7000  (budget)
    # x, y >= 0 and integers (number of firefighters)
    #
    # We'll brute force over a reasonable range of x and y.
    # Upper bounds:
    # From budget: 300x <= 7000 -> x <= 23.33 -> x <= 23
    # Similarly, 100y <= 7000 -> y <= 70
    # We'll search within these bounds.

    best_value = None  # minimal x + y
    best_solution = None

    for x in range(0, 24):  # 0 to 23
        for y in range(0, 71):  # 0 to 70
            hours = 10 * x + 6 * y
            cost = 300 * x + 100 * y

            if hours >= 300 and cost <= 7000:
                total_firefighters = x + y
                if best_value is None or total_firefighters < best_value:
                    best_value = total_firefighters
                    best_solution = (x, y)

    # The problem asks for the optimal objective value (minimal number of firefighters)
    # as a float.
    return float(best_value if best_value is not None else 0.0)
```",40.0,True,0.0,0.0,1.8767669200897217,
214,225.00000000000003,"```python
def solve():
    # Let x = amount in clothing (7%), y = amount in tech (10%)
    # Constraints:
    # 1) x + y = 3000
    # 2) x >= 4y
    # 3) y <= 500
    # 4) x, y >= 0
    #
    # Objective: maximize 0.07x + 0.10y
    #
    # From x + y = 3000 => x = 3000 - y
    # Substitute into x >= 4y:
    # 3000 - y >= 4y  =>  3000 >= 5y  =>  y <= 600
    #
    # So y must satisfy: y <= 500 (given) and y <= 600 (from ratio), and y >= 0.
    # Thus 0 <= y <= 500.
    #
    # Objective as function of y:
    # f(y) = 0.07(3000 - y) + 0.10y
    #      = 0.07*3000 - 0.07y + 0.10y
    #      = 210 + 0.03y
    #
    # This is increasing in y, so maximize y within feasible range: y = 500.
    # Then x = 3000 - 500 = 2500.
    #
    # Optimal objective value:
    x = 2500.0
    y = 500.0
    optimal_value = 0.07 * x + 0.10 * y
    return optimal_value
```",225.00000000000003,True,0.0,0.0,2.7637314796447754,
215,30.0,"```python
def solve():
    # Let x = square miles using heap leaching
    #     y = square miles using vat leaching
    #
    # Maximize: 3x + 5y
    # Subject to:
    # 1) Land: x + y <= 100
    # 2) Machines: 10x + 20y <= 100  -> x + 2y <= 10
    # 3) Wastewater: 8x + 17y <= 90
    # 4) x >= 0, y >= 0
    #
    # We'll solve by enumerating all corner points formed by intersections
    # of the constraint lines and checking feasibility.

    import math

    # Helper to check feasibility
    def feasible(x, y):
        if x < -1e-9 or y < -1e-9:
            return False
        if x + y > 100 + 1e-9:
            return False
        if x + 2*y > 10 + 1e-9:
            return False
        if 8*x + 17*y > 90 + 1e-9:
            return False
        return True

    # Collect candidate points (corner intersections)
    candidates = []

    # Intersections with axes
    # x = 0 with each constraint
    # x + 2y = 10 -> y = 5
    candidates.append((0.0, 5.0))
    # 8x + 17y = 90 with x=0 -> y = 90/17
    candidates.append((0.0, 90.0/17.0))
    # x + y = 100 with x=0 -> y = 100
    candidates.append((0.0, 100.0))

    # y = 0 with each constraint
    # x + 2y = 10 -> x = 10
    candidates.append((10.0, 0.0))
    # 8x + 17y = 90 with y=0 -> x = 90/8
    candidates.append((90.0/8.0, 0.0))
    # x + y = 100 with y=0 -> x = 100
    candidates.append((100.0, 0.0))

    # Intersections between pairs of non-axis constraints

    # 1) x + 2y = 10 and 8x + 17y = 90
    # Solve:
    # x = 10 - 2y
    # 8(10 - 2y) + 17y = 90 -> 80 - 16y + 17y = 90 -> y = 10
    # Then x = 10 - 2*10 = -10
    candidates.append((-10.0, 10.0))

    # 2) x + 2y = 10 and x + y = 100
    # From x + 2y = 10 and x + y = 100:
    # subtract: (x+2y) - (x+y) = 10 - 100 -> y = -90
    # then x = 100 - y = 190
    candidates.append((190.0, -90.0))

    # 3) 8x + 17y = 90 and x + y = 100
    # From x = 100 - y
    # 8(100 - y) + 17y = 90 -> 800 - 8y + 17y = 90 -> 9y = -710 -> y = -710/9
    # x = 100 - y
    y = -710.0 / 9.0
    x = 100.0 - y
    candidates.append((x, y))

    # Always include origin
    candidates.append((0.0, 0.0))

    best_val = -math.inf
    for x, y in candidates:
        if feasible(x, y):
            val = 3.0 * x + 5.0 * y
            if val > best_val:
                best_val = val

    # Return the optimal objective value
    return float(best_val)
```",30.0,True,0.0,0.0,6.863429069519043,
216,60.0,"```python
def solve():
    # We need to minimize C + T subject to:
    # 1) 30C + 40T >= 2000
    # 2) T <= C/2
    # 3) C >= 15
    # 4) C, T are nonnegative integers
    
    best_value = None
    
    # Upper bound for C: if we used only containers, 30C >= 2000 => C >= 2000/30 â‰ˆ 66.67
    # So C up to, say, 100 is more than enough.
    for C in range(15, 101):
        # T must satisfy oil requirement: 40T >= 2000 - 30C
        required_oil = 2000 - 30 * C
        if required_oil <= 0:
            T_min_oil = 0
        else:
            # Ceiling division for T_min_oil = ceil(required_oil / 40)
            T_min_oil = (required_oil + 39) // 40
        
        # T must also satisfy T <= C/2, so T_max = floor(C/2)
        T_max = C // 2
        
        if T_min_oil <= T_max:
            T = T_min_oil
            value = C + T
            if best_value is None or value < best_value:
                best_value = value
    
    # Return the optimal objective value as float
    return float(best_value)
```",60.0,True,0.0,0.0,1.948296308517456,
217,256500.0,"```python
def solve():
    # Let x = number of personal licenses
    #     y = number of commercial licenses
    #
    # Maximize profit: 450x + 1200y
    # Subject to:
    #   1) x + y <= 300          (sales limit)
    #   2) 550x + 2000y <= 400000 (cost limit)
    #   3) x >= 0, y >= 0
    #
    # We'll solve this small LP by checking the corner points of the feasible region.

    # Corner 1: (0, 0)
    x1, y1 = 0.0, 0.0
    profit1 = 450 * x1 + 1200 * y1

    # Corner 2: intersection of x + y = 300 with y = 0  -> (300, 0)
    x2, y2 = 300.0, 0.0
    # Check feasibility with cost constraint
    if 550 * x2 + 2000 * y2 <= 400000:
        profit2 = 450 * x2 + 1200 * y2
    else:
        profit2 = float('-inf')

    # Corner 3: intersection of 550x + 2000y = 400000 with x = 0 -> (0, 400000/2000)
    x3, y3 = 0.0, 400000.0 / 2000.0
    # Check feasibility with sales constraint
    if x3 + y3 <= 300:
        profit3 = 450 * x3 + 1200 * y3
    else:
        profit3 = float('-inf')

    # Corner 4: intersection of x + y = 300 and 550x + 2000y = 400000
    # From x + y = 300 -> x = 300 - y
    # Substitute into cost constraint:
    # 550(300 - y) + 2000y = 400000
    # 165000 - 550y + 2000y = 400000
    # 1450y = 235000
    # y = 235000 / 1450
    y4 = 235000.0 / 1450.0
    x4 = 300.0 - y4
    # Check non-negativity (should be satisfied analytically, but we verify)
    if x4 >= 0 and y4 >= 0:
        profit4 = 450 * x4 + 1200 * y4
    else:
        profit4 = float('-inf')

    # Take the maximum profit among feasible corners
    best_profit = max(profit1, profit2, profit3, profit4)
    return float(best_profit)
```",256551.72413793104,False,51.724137931043515,0.00020165355918535407,2.869248390197754,
218,1970.0,"```python
def solve():
    # Let s = number of small containers, l = number of large containers
    # Constraints:
    # 1) s = 3l
    # 2) s >= 5
    # 3) l >= 3
    # 4) People: 1*s + 3*l <= 100
    #
    # Substitute s = 3l into people constraint:
    # 3l + 3l <= 100 -> 6l <= 100 -> l <= 100/6
    #
    # Also l >= 3 and s >= 5 -> 3l >= 5 -> l >= 5/3, so l >= 3 dominates.
    #
    # So feasible l are 3 <= l <= floor(100/6).
    # Objective: maximize sand = 20s + 50l = 20*(3l) + 50l = 110l
    # So we choose the largest feasible l.

    max_l = int(100 // 6)  # floor(100/6)
    # Ensure lower bound l >= 3
    if max_l < 3:
        return 0.0  # No feasible solution, theoretically shouldn't happen here

    l = max_l
    s = 3 * l
    sand = 20 * s + 50 * l
    return float(sand)
```",1760.0,False,210.0,0.1065989847715195,2.253485918045044,
219,70.0,"```python
def solve():
    # We solve the LP:
    # Minimize 20x + 35y
    # subject to:
    # 4x + 12y >= 15   (calcium)
    # 7x + 10y >= 20   (vitamin)
    # 10x + 16y >= 20  (protein)
    # x, y >= 0
    
    # Since it's a 2-variable LP, we can solve by checking all corner points
    # formed by intersections of constraint lines and axes.
    
    import math

    # Helper to solve a 2x2 linear system:
    # a1*x + b1*y = c1
    # a2*x + b2*y = c2
    def solve_system(a1, b1, c1, a2, b2, c2):
        det = a1 * b2 - a2 * b1
        if abs(det) < 1e-12:
            return None  # parallel or nearly parallel
        x = (c1 * b2 - c2 * b1) / det
        y = (a1 * c2 - a2 * c1) / det
        return (x, y)

    # Constraints in equality form for intersections:
    # 1: 4x + 12y = 15
    # 2: 7x + 10y = 20
    # 3: 10x + 16y = 20

    candidates = []

    # Intersections of each pair of constraint lines
    pairs = [
        (4, 12, 15, 7, 10, 20),   # 1 & 2
        (4, 12, 15, 10, 16, 20),  # 1 & 3
        (7, 10, 20, 10, 16, 20)   # 2 & 3
    ]

    for a1, b1, c1, a2, b2, c2 in pairs:
        sol = solve_system(a1, b1, c1, a2, b2, c2)
        if sol is not None:
            candidates.append(sol)

    # Intersections with axes: x=0 and y=0 for each constraint
    # For x = 0:
    # 4*0 + 12y >= 15 -> y >= 15/12
    # 7*0 + 10y >= 20 -> y >= 20/10
    # 10*0 + 16y >= 20 -> y >= 20/16
    # The feasible point on x=0 is y = max(15/12, 20/10, 20/16)
    y_axis_y = max(15.0 / 12.0, 20.0 / 10.0, 20.0 / 16.0)
    candidates.append((0.0, y_axis_y))

    # For y = 0:
    # 4x >= 15 -> x >= 15/4
    # 7x >= 20 -> x >= 20/7
    # 10x >= 20 -> x >= 20/10
    # The feasible point on y=0 is x = max(15/4, 20/7, 20/10)
    x_axis_x = max(15.0 / 4.0, 20.0 / 7.0, 20.0 / 10.0)
    candidates.append((x_axis_x, 0.0))

    # Filter feasible points and compute objective
    best_val = math.inf

    for x, y in candidates:
        if x < -1e-9 or y < -1e-9:
            continue
        # Check constraints with tolerance
        if (4 * x + 12 * y >= 15 - 1e-9 and
            7 * x + 10 * y >= 20 - 1e-9 and
            10 * x + 16 * y >= 20 - 1e-9):
            cost = 20 * x + 35 * y
            if cost < best_val:
                best_val = cost

    return float(best_val)
```",60.79545454545455,False,9.204545454545453,0.131493506491628,5.121126174926758,
220,40.0,"```python
def solve():
    # We want to minimize total number of staff: x + y
    # x = number of full-time staff (40 hours, $1280)
    # y = number of part-time staff (15 hours, $450)
    #
    # Constraints:
    # 1) 40x + 15y >= 1000  (hours requirement)
    # 2) 1280x + 450y <= 31500 (budget)
    # 3) x, y >= 0 and integers
    #
    # We'll brute-force over a reasonable range of x and y, since the numbers are small.

    best_value = None  # minimal x + y
    # Upper bounds: from hours and budget
    # Max full-time from budget: 31500 / 1280 ~ 24.6 -> 25
    # Max part-time from budget: 31500 / 450 = 70
    # Also from hours: 1000/40 = 25 full-time, 1000/15 ~ 67 part-time
    # So search in a modest range.
    for x in range(0, 26):  # 0..25
        for y in range(0, 71):  # 0..70
            hours = 40 * x + 15 * y
            cost = 1280 * x + 450 * y
            if hours >= 1000 and cost <= 31500:
                total_staff = x + y
                if best_value is None or total_staff < best_value:
                    best_value = total_staff

    # The function should return the optimal objective value (minimal number of staff) as float
    return float(best_value)
```",40.0,True,0.0,0.0,2.425705909729004,
221,125.49295774647888,"```python
def solve():
    # We solve the LP:
    # Minimize:  5x + 9y   (vitamin D)
    # Subject to:
    #   13x +  8y >= 220   (nitrogen)
    #    5x + 14y >= 160   (phosphoric acid)
    #    6x +  6y <= 350   (vitamin A)
    #   x >= 0, y >= 0
    
    # We'll solve this by enumerating all candidate corner points formed by
    # intersections of constraint boundaries and axes, then checking feasibility
    # and objective value.
    
    import math

    def is_feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 13*x + 8*y < 220 - 1e-9:
            return False
        if 5*x + 14*y < 160 - 1e-9:
            return False
        if 6*x + 6*y > 350 + 1e-9:
            return False
        return True

    def obj(x, y):
        return 5*x + 9*y

    candidates = []

    # 1) Intersections of pairs of constraint boundaries

    # a) 13x + 8y = 220  and  5x + 14y = 160
    # Solve the 2x2 system
    # Using Cramer's rule
    A11, A12, B1 = 13.0, 8.0, 220.0
    A21, A22, B2 = 5.0, 14.0, 160.0
    det = A11*A22 - A12*A21
    if abs(det) > 1e-12:
        x = (B1*A22 - A12*B2) / det
        y = (A11*B2 - B1*A21) / det
        candidates.append((x, y))

    # b) 13x + 8y = 220  and  6x + 6y = 350
    A11, A12, B1 = 13.0, 8.0, 220.0
    A21, A22, B2 = 6.0, 6.0, 350.0
    det = A11*A22 - A12*A21
    if abs(det) > 1e-12:
        x = (B1*A22 - A12*B2) / det
        y = (A11*B2 - B1*A21) / det
        candidates.append((x, y))

    # c) 5x + 14y = 160  and  6x + 6y = 350
    A11, A12, B1 = 5.0, 14.0, 160.0
    A21, A22, B2 = 6.0, 6.0, 350.0
    det = A11*A22 - A12*A21
    if abs(det) > 1e-12:
        x = (B1*A22 - A12*B2) / det
        y = (A11*B2 - B1*A21) / det
        candidates.append((x, y))

    # 2) Intersections with axes (x=0 or y=0) for each boundary

    # With x = 0:
    # 13*0 + 8y = 220 -> y = 220/8
    candidates.append((0.0, 220.0/8.0))
    # 5*0 + 14y = 160 -> y = 160/14
    candidates.append((0.0, 160.0/14.0))
    # 6*0 + 6y = 350 -> y = 350/6
    candidates.append((0.0, 350.0/6.0))

    # With y = 0:
    # 13x + 8*0 = 220 -> x = 220/13
    candidates.append((220.0/13.0, 0.0))
    # 5x + 14*0 = 160 -> x = 160/5
    candidates.append((160.0/5.0, 0.0))
    # 6x + 6*0 = 350 -> x = 350/6
    candidates.append((350.0/6.0, 0.0))

    best_val = math.inf

    for x, y in candidates:
        if is_feasible(x, y):
            val = obj(x, y)
            if val < best_val:
                best_val = val

    # Return the minimum vitamin D amount
    return float(best_val)
```",125.49295774647888,True,0.0,0.0,5.050630569458008,
222,8.0,"```python
def solve():
    # We want to minimize x + y
    # Subject to:
    # 100x + 50y >= 500   (sandwiches)
    # 8x + 3y <= 35       (employees)
    # x, y >= 0 and integers (number of stores)
    #
    # We'll brute-force over a reasonable range of x and y.
    # Upper bounds:
    # - From employees: x <= 35/8 ~ 4.375 -> x <= 4
    # - From sandwiches alone: if only dine-in, x >= 5; but employees limit to 4,
    #   so we must use some trucks. We'll just search a bit wider safely.
    
    best_value = None
    
    # Reasonable search bounds:
    # x: 0 to 35 (but employees will cut it down)
    # y: 0 to 35
    for x in range(36):
        for y in range(36):
            # Check constraints
            if 100 * x + 50 * y >= 500 and 8 * x + 3 * y <= 35:
                value = x + y
                if best_value is None or value < best_value:
                    best_value = value
    
    # Return the minimal number of stores as a float
    return float(best_value)
```",8.0,True,0.0,0.0,2.2539095878601074,
223,16500.0,"```python
def solve():
    # We maximize 200s + 500l
    # Subject to:
    # 1) s >= 3l
    # 2) s <= 100
    # 3) l <= 50
    # 4) s + l <= 60
    # 5) l >= 10
    #
    # s, l are integers (numbers of crates).
    #
    # We'll brute force over feasible integer (s, l) pairs.

    best_value = float('-inf')

    for l in range(10, 51):  # l between 10 and 50 inclusive
        # From s >= 3l and s + l <= 60, we get:
        # s >= 3l
        # s <= 60 - l
        s_min = 3 * l
        s_max = min(100, 60 - l)  # also s <= 100

        if s_min > s_max:
            continue  # no feasible s for this l

        # Since objective is increasing in s (200 per small crate),
        # best s for fixed l is s_max.
        s = s_max

        value = 200 * s + 500 * l
        if value > best_value:
            best_value = value

    return float(best_value)
```",16500.0,True,0.0,0.0,3.074237823486328,
224,2400.0,"```python
def solve():
    # We solve the LP:
    # Maximize: 120x + 40y
    # Subject to:
    #   1) x + 4y <= 400        (floor space)
    #   2) x + y <= 60          (budget: 400x + 100y <= 6000 -> 4x + y <= 240 -> x + y <= 60)
    #   3) x <= 0.25y           (at least 80% laptops: y >= 4/5 (x + y) -> x <= 0.25y)
    #   4) x, y >= 0
    #
    # We'll enumerate all intersection points of the constraint boundaries and
    # check feasibility and objective value.

    import math

    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if x + 4 * y > 400 + 1e-9:
            return False
        if x + y > 60 + 1e-9:
            return False
        if x - 0.25 * y > 1e-9:
            return False
        return True

    candidates = []

    # Intersections of pairs of constraints (as equalities):

    # 1) x + 4y = 400 and 2) x + y = 60
    # Subtract: 3y = 340 -> y = 340/3, x = 60 - y
    y = 340.0 / 3.0
    x = 60.0 - y
    candidates.append((x, y))

    # 1) x + 4y = 400 and 3) x = 0.25y
    # 0.25y + 4y = 400 -> 4.25y = 400
    y = 400.0 / 4.25
    x = 0.25 * y
    candidates.append((x, y))

    # 2) x + y = 60 and 3) x = 0.25y
    # 0.25y + y = 60 -> 1.25y = 60
    y = 60.0 / 1.25
    x = 0.25 * y
    candidates.append((x, y))

    # Intersections with axes:

    # x = 0 with constraints:
    #   1) 4y <= 400 -> y <= 100
    #   2) y <= 60
    #   3) 0 <= 0.25y (always for y >= 0)
    # So max y is 60
    candidates.append((0.0, 0.0))
    candidates.append((0.0, 60.0))

    # y = 0 with constraints:
    #   1) x <= 400
    #   2) x <= 60
    #   3) x <= 0 (since x <= 0.25*0)
    # So only (0,0) already added

    best_val = -math.inf
    for x, y in candidates:
        if feasible(x, y):
            val = 120.0 * x + 40.0 * y
            if val > best_val:
                best_val = val

    return best_val
```",3360.0,False,960.0,0.3999999999998333,4.301745414733887,
225,2.3,"```python
def solve():
    # We solve the LP:
    # Minimize:  0.3 x1 + 0.1 x2
    # Subject to:
    #   0.2 x1 + 0.6 x2 <= 6      (pain)
    #   0.3 x1 + 0.2 x2 >= 3      (anxiety)
    #   x1 >= 0, x2 >= 0
    
    # This is a 2-variable LP, so the optimum (if it exists and is bounded)
    # occurs at a corner (intersection of constraints).
    # We'll enumerate candidate corner points and pick the feasible one
    # with minimum objective value.
    
    candidates = []
    
    # Helper to check feasibility
    def feasible(x1, x2):
        if x1 < 0 or x2 < 0:
            return False
        if 0.2 * x1 + 0.6 * x2 > 6 + 1e-9:  # pain <= 6
            return False
        if 0.3 * x1 + 0.2 * x2 < 3 - 1e-9:  # anxiety >= 3
            return False
        return True
    
    # 1) Intersection of pain and anxiety constraints:
    #   0.2 x1 + 0.6 x2 = 6
    #   0.3 x1 + 0.2 x2 = 3
    # Solve the 2x2 system manually:
    # From second: 0.3 x1 = 3 - 0.2 x2 => x1 = (3 - 0.2 x2)/0.3
    # Substitute into first:
    #   0.2 * (3 - 0.2 x2)/0.3 + 0.6 x2 = 6
    # Multiply by 0.3:
    #   0.2*(3 - 0.2 x2) + 0.18 x2 = 1.8
    #   0.6 - 0.04 x2 + 0.18 x2 = 1.8
    #   0.6 + 0.14 x2 = 1.8
    #   0.14 x2 = 1.2 => x2 = 1.2 / 0.14
    x2 = 1.2 / 0.14
    x1 = (3 - 0.2 * x2) / 0.3
    if feasible(x1, x2):
        candidates.append((x1, x2))
    
    # 2) Intersection of anxiety with x1 = 0:
    #   0.3*0 + 0.2 x2 = 3 => x2 = 15
    x1, x2 = 0.0, 15.0
    if feasible(x1, x2):
        candidates.append((x1, x2))
    
    # 3) Intersection of anxiety with x2 = 0:
    #   0.3 x1 + 0*0.2 = 3 => x1 = 10
    x1, x2 = 10.0, 0.0
    if feasible(x1, x2):
        candidates.append((x1, x2))
    
    # 4) Intersection of pain with x1 = 0:
    #   0.2*0 + 0.6 x2 = 6 => x2 = 10
    x1, x2 = 0.0, 10.0
    if feasible(x1, x2):
        candidates.append((x1, x2))
    
    # 5) Intersection of pain with x2 = 0:
    #   0.2 x1 + 0.6*0 = 6 => x1 = 30
    x1, x2 = 30.0, 0.0
    if feasible(x1, x2):
        candidates.append((x1, x2))
    
    # 6) The origin (0,0) as a corner
    x1, x2 = 0.0, 0.0
    if feasible(x1, x2):
        candidates.append((x1, x2))
    
    # Evaluate objective at feasible candidates
    best_val = None
    for x1, x2 in candidates:
        val = 0.3 * x1 + 0.1 * x2
        if best_val is None or val < best_val:
            best_val = val
    
    # Return the optimal objective value as float
    return float(best_val)
```",2.142857142857143,False,0.15714285714285703,0.06832298133675394,5.4558305740356445,
226,72.0,"```python
def solve():
    # We model:
    # x = number of chop saws
    # y = number of steel cutters
    #
    # Constraints:
    # 1) Steel capacity: 25x + 5y >= 520
    # 2) Waste limit:    25x + 3y <= 400
    # 3) x, y >= 0
    #
    # Objective: minimize total number of machines: x + y
    #
    # This is a small LP; we can solve it by enumerating feasible corner points
    # of the continuous relaxation (x, y real, >= 0) and then checking them.
    #
    # Corner points come from intersections of:
    # - 25x + 5y = 520  (steel)
    # - 25x + 3y = 400  (waste)
    # - x = 0
    # - y = 0
    #
    # We'll compute all candidate intersections, keep those that satisfy all
    # inequalities, and pick the one with minimal x + y.

    candidates = []

    # Helper to check feasibility
    def feasible(x, y):
        if x < 0 or y < 0:
            return False
        if 25 * x + 5 * y < 520 - 1e-9:  # steel capacity
            return False
        if 25 * x + 3 * y > 400 + 1e-9:  # waste limit
            return False
        return True

    # 1) Intersection of steel and waste lines:
    #    25x + 5y = 520
    #    25x + 3y = 400
    # Subtract second from first: 2y = 120 -> y = 60
    # Plug back: 25x + 3*60 = 400 -> 25x = 220 -> x = 8.8
    x = 220.0 / 25.0
    y = 60.0
    if feasible(x, y):
        candidates.append((x, y))

    # 2) Intersection of steel line with x = 0:
    #    25*0 + 5y = 520 -> y = 104
    x, y = 0.0, 520.0 / 5.0
    if feasible(x, y):
        candidates.append((x, y))

    # 3) Intersection of steel line with y = 0:
    #    25x = 520 -> x = 20.8
    x, y = 520.0 / 25.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # 4) Intersection of waste line with x = 0:
    #    25*0 + 3y = 400 -> y = 400/3
    x, y = 0.0, 400.0 / 3.0
    if feasible(x, y):
        candidates.append((x, y))

    # 5) Intersection of waste line with y = 0:
    #    25x = 400 -> x = 16
    x, y = 400.0 / 25.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    # 6) Origin (0,0) just in case (it will be infeasible for steel capacity)
    x, y = 0.0, 0.0
    if feasible(x, y):
        candidates.append((x, y))

    if not candidates:
        # No feasible solution
        return float('inf')

    # Minimize x + y over feasible candidates
    best_value = float('inf')
    for x, y in candidates:
        val = x + y
        if val < best_value:
            best_value = val

    return float(best_value)
```",68.8,False,3.200000000000003,0.0444444444438272,5.098592281341553,
227,214.0,"```python
def solve():
    # We solve the LP by enumerating all corner points of the feasible region.
    # Variables:
    #   x = batches of medication patches
    #   y = batches of anti-biotic creams
    #
    # Maximize: 3x + 2y
    #
    # Subject to:
    #   3x + 5y <= 400      (time)
    #   5x + 6y <= 530      (materials)
    #   x + y <= 100        (storage)
    #   y >= 2x             (at least twice as many creams)
    #   x >= 0, y >= 0

    import math

    # Helper to check feasibility with a small tolerance
    def feasible(x, y, eps=1e-9):
        if x < -eps or y < -eps:
            return False
        if 3*x + 5*y > 400 + eps:
            return False
        if 5*x + 6*y > 530 + eps:
            return False
        if x + y > 100 + eps:
            return False
        if y < 2*x - eps:
            return False
        return True

    # Helper to compute objective
    def objective(x, y):
        return 3*x + 2*y

    # Collect candidate points from intersections of constraint boundaries
    candidates = []

    # 1) Intersections of pairs of lines:
    # Lines:
    #   L1: 3x + 5y = 400
    #   L2: 5x + 6y = 530
    #   L3: x + y = 100
    #   L4: y = 2x
    #   L5: x = 0
    #   L6: y = 0

    # We'll solve each pair analytically.

    def add_if_feasible(x, y):
        if feasible(x, y):
            candidates.append((x, y))

    # L1 & L2
    # 3x + 5y = 400
    # 5x + 6y = 530
    # Solve:
    # From first: x = (400 - 5y)/3
    # Substitute into second:
    # 5*(400 - 5y)/3 + 6y = 530
    # (2000 - 25y)/3 + 6y = 530
    # 2000 - 25y + 18y = 1590
    # 2000 - 7y = 1590
    # 7y = 410 -> y = 410/7
    y = 410.0 / 7.0
    x = (400.0 - 5.0 * y) / 3.0
    add_if_feasible(x, y)

    # L1 & L3
    # 3x + 5y = 400
    # x + y = 100 -> x = 100 - y
    # 3(100 - y) + 5y = 400
    # 300 - 3y + 5y = 400
    # 2y = 100 -> y = 50, x = 50
    x, y = 50.0, 50.0
    add_if_feasible(x, y)

    # L1 & L4
    # 3x + 5y = 400
    # y = 2x
    # 3x + 5(2x) = 400 -> 13x = 400 -> x = 400/13, y = 800/13
    x = 400.0 / 13.0
    y = 800.0 / 13.0
    add_if_feasible(x, y)

    # L1 & L5 (x = 0)
    # 3*0 + 5y = 400 -> y = 80
    x, y = 0.0, 80.0
    add_if_feasible(x, y)

    # L1 & L6 (y = 0)
    # 3x = 400 -> x = 400/3
    x, y = 400.0 / 3.0, 0.0
    add_if_feasible(x, y)

    # L2 & L3
    # 5x + 6y = 530
    # x + y = 100 -> x = 100 - y
    # 5(100 - y) + 6y = 530
    # 500 - 5y + 6y = 530
    # y = 30, x = 70
    x, y = 70.0, 30.0
    add_if_feasible(x, y)

    # L2 & L4
    # 5x + 6y = 530
    # y = 2x
    # 5x + 6(2x) = 530 -> 17x = 530 -> x = 530/17, y = 1060/17
    x = 530.0 / 17.0
    y = 1060.0 / 17.0
    add_if_feasible(x, y)

    # L2 & L5 (x = 0)
    # 6y = 530 -> y = 530/6
    x, y = 0.0, 530.0 / 6.0
    add_if_feasible(x, y)

    # L2 & L6 (y = 0)
    # 5x = 530 -> x = 106
    x, y = 106.0, 0.0
    add_if_feasible(x, y)

    # L3 & L4
    # x + y = 100
    # y = 2x
    # x + 2x = 100 -> x = 100/3, y = 200/3
    x = 100.0 / 3.0
    y = 200.0 / 3.0
    add_if_feasible(x, y)

    # L3 & L5 (x = 0)
    # y = 100
    x, y = 0.0, 100.0
    add_if_feasible(x, y)

    # L3 & L6 (y = 0)
    # x = 100
    x, y = 100.0, 0.0
    add_if_feasible(x, y)

    # L4 & L5 (x = 0, y = 2x -> y = 0)
    x, y = 0.0, 0.0
    add_if_feasible(x, y)

    # L4 & L6 (y = 0, y = 2x -> x = 0)
    x, y = 0.0, 0.0
    add_if_feasible(x, y)

    # Also consider pure axis intersections with all constraints:
    # x = 0, satisfy others by bounds:
    #   5y <= 400 -> y <= 80
    #   6y <= 530 -> y <= 530/6
    #   y <= 100
    #   y >= 0
    # So y can be 0 to min(80, 530/6, 100). Endpoints already considered (0,0) and (0,80).
    # y = 0:
    #   3x <= 400 -> x <= 400/3
    #   5x <= 530 -> x <= 106
    #   x <= 100
    #   0 >= 2x -> x <= 0, so only x=0 feasible, already added.

    # Remove duplicates (within tolerance)
    unique = []
    for (x, y) in candidates:
        if not any(abs(x - ux) < 1e-8 and abs(y - uy) < 1e-8 for (ux, uy) in unique):
            unique.append((x, y))

    best_val = -math.inf
    for (x, y) in unique:
        val = objective(x, y)
        if val > best_val:
            best_val = val

    return float(best_val)
```",215.3846153846154,False,1.3846153846153868,0.0064701653486397975,12.801769733428955,
228,8.0,"```python
def solve():
    # We want to minimize the total number of shops: x + y
    # Subject to:
    # 30x + 70y >= 500  (production constraint)
    # 2x + 4y <= 30     (worker constraint)
    # x, y >= 0 and integers
    
    best_value = None  # minimal x + y
    # Since 2x + 4y <= 30, x and y are bounded:
    # x <= 15 when y = 0, and y <= 7 when x = 0
    for x in range(0, 16):      # x can be 0..15
        for y in range(0, 8):   # y can be 0..7
            if 30 * x + 70 * y >= 500 and 2 * x + 4 * y <= 30:
                total_shops = x + y
                if best_value is None or total_shops < best_value:
                    best_value = total_shops

    # Return the minimal number of shops as a float
    return float(best_value)
```",8.0,True,0.0,0.0,2.1022915840148926,
229,2190.0,"```python
def solve():
    # We solve the LP:
    # Maximize 5x + 8y
    # subject to:
    # 30 <= x <= 150
    # 50 <= y <= 180
    # x + y >= 100
    #
    # This is a small 2-variable LP; we can solve it by checking all corner points
    # of the feasible region.
    
    # Candidate corner points come from intersecting the constraint boundaries:
    # x = 30 or 150
    # y = 50 or 180
    # x + y = 100
    #
    # We enumerate all such intersections and keep those that satisfy all constraints.
    
    candidates = []
    
    # 1) Intersections of x bounds with y bounds
    for x in [30, 150]:
        for y in [50, 180]:
            candidates.append((x, y))
    
    # 2) Intersections with x + y = 100
    #    a) x = 30 -> y = 70
    x = 30
    y = 100 - x
    candidates.append((x, y))
    
    #    b) x = 150 -> y = -50 (will be infeasible, but we add and filter later)
    x = 150
    y = 100 - x
    candidates.append((x, y))
    
    #    c) y = 50 -> x = 50
    y = 50
    x = 100 - y
    candidates.append((x, y))
    
    #    d) y = 180 -> x = -80 (likely infeasible)
    y = 180
    x = 100 - y
    candidates.append((x, y))
    
    best_value = None
    
    for x, y in candidates:
        # Check feasibility:
        if 30 <= x <= 150 and 50 <= y <= 180 and x + y >= 100:
            value = 5 * x + 8 * y
            if best_value is None or value > best_value:
                best_value = value
    
    # best_value is the optimal objective value
    return float(best_value)
```",2190.0,True,0.0,0.0,2.609088182449341,
230,26.0,"```python
def solve():
    # We need to minimize total trips: x (planes) + y (trucks)
    # Subject to:
    # 1) Tire capacity: 10x + 6y >= 200
    # 2) Budget: 1000x + 700y <= 22000
    # 3) Plane trips cannot exceed truck trips: x <= y
    # 4) x, y are nonnegative integers

    best_trips = None  # minimal x + y
    # Upper bounds: from budget and tire constraints
    # From budget: 1000x + 700y <= 22000 -> x <= 22, y <= 31 (rough bounds)
    # From tires: 10x + 6y >= 200 -> x <= 20 if y=0, y <= 34 if x=0
    # We'll just use safe small bounds.
    for x in range(0, 23):  # 0..22
        for y in range(0, 35):  # 0..34
            # Constraints
            if 10 * x + 6 * y < 200:
                continue
            if 1000 * x + 700 * y > 22000:
                continue
            if x > y:
                continue

            trips = x + y
            if best_trips is None or trips < best_trips:
                best_trips = trips

    # Return the minimal total number of trips as a float
    return float(best_trips)
```",26.0,True,0.0,0.0,2.695413589477539,
